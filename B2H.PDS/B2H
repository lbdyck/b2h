/*- Rexx -----------------------------------------------------------*/
/*%COPYRIGHT (c) Copyright 2001-2002 AT&T                           */
/*                                                                  */
/* AT&T Global Network Services, PO Box 30021, Tampa, FL 33630, USA */
/*                                                                  */
/* Gary L. Richtmeyer, grichtmeyer@att.com              20 May 2002 */
/*                                                                  */
/*------------------------------------------------------------------*/
/* Lionel B. Dyck, lbdyck@gmail.com                     01 Aug 2017 */
/*   Minor updates - find LBD                                       */
/*------------------------------------------------------------------*/
/* B2H: Convert a Bookmaster, GML, Script/VS or "flat" file to HTML */
/*                                                                  */
/* This program converts a Bookmaster, GML, Script/VS or "flat"     */
/* file into HTML 2, 3 or 4 format.  B2H runs under AIX, Linux, MVS */
/* (OS/390), OS/2, VM/CMS, Windows 9x/ME, Windows NT/2000/XP or     */
/* Unix.  On VM/ESA, B2H can run as a stand-alone EXEC or as a      */
/* CMS Pipeline filter.  On MVS, B2H can run either as a            */
/* stand-alone program or as an MVS/BatchPipeWorks pipeline filter. */
/*                                                                  */
/* Code with platform-dependent logic has an "eyecatcher" comment   */
/* of "!OPSYS!" to assist in identifying their locations.           */
/*                                                                  */
/* Inspired by BOOKHYPE by John Dorval, DORVAL at RHQVM21.          */
/* Initial AIX code provided by David White, DBWHITE at BTVLABVM    */
/* Initial syntax diagram code provided by Ross Patterson,          */
/*    Ross_Patterson@ssw.reston.vmd.sterling.com                    */
/*                                                                  */
/* Usage: B2H file  < ( OptParms <)> >                              */
/*   file     - Input file (using platform-relevent syntax)         */
/*   OptParms - Optional parameters.  See User's Guide or online    */
/*              help for a description.  PD-type parms also valid:  */
/*              DEBUG={YES|NO}          Default: DEBUG=NO           */
/*                         Show various information for problem     */
/*                         determination purposes?  If YES, PD-type */
/*                         data is shown and SHOWPROF=YES and       */
/*                         SHOWSYM=YES is assumed                   */
/*              DUMPVARS - Prompt user to show variables            */
/*              NOERASE  - Don't erase work file when finished      */
/*              SHOWPROF={YES|NO}       Default: SHOWPROF=NO        */
/*                         Show each profile record processed?      */
/*              SHOWSYM={YES|NO}        Default: SHOWSYM=NO         */
/*                         Show each symbol table record processed? */
/*              TRACE=NO                Default: TRACE=NO           */
/*                    '{I/O|PARSE|PGM|ALL} {TERM|DISK}'             */
/*                         Tracing I/O data, program calls,         */
/*                         conversion activity, or all of the above?*/
/*                         If tracing, msgs to disk or terminal?    */
/*              TRACELIST='rtn1 rtn2 ... rtnx'                      */
/*                       - One or more names of subroutines in      */
/*                         which REXX tracing is to be set to "I"   */
/*                                                                  */
/* Called By: User                                                  */
/* Calls To External Routines/Programs:                             */
/*   On AIX/LINUX/UNIX: VISUAL, EDITOR or cat to show online help   */
/*   On MVS:       SYSVAR(), SYSDSN(), LISTDSI(),                   */
/*                 ISPEXEC (if avail), ALLOC/FREE/DELETE/EXECIO     */
/*   On OS/2:      RexxUtil; "E" to show online help                */
/*   On VM:        CMS Pipelines                                    */
/*   On Windows:   NOTEPAD to show online help                      */
/* Input Files: (shown using VM naming conventions)                 */
/*   o  B2H HELPCMS - Help file                                     */
/*   o  B2H PROFILE - Set default parameters                        */
/*   o  B2H SYMBOLS - Define tags and &variable values              */
/*   o  User-specified header, footer, profile and symbol file(s)   */
/*   o  User-specified file to be converted (plus any imbeds)       */
/* Output Files:                                                    */
/*   o  Output HTML file(s)                                         */
/*   o  One temporary work file                                     */
/*   o  Optional log and trace files                                */
/* Dependencies: Format of Bookmaster/GML tags and &symbols         */
/*------------------------------------------------------------------*/
/* Major variables described where created or at end-of-program     */
/*------------------------------------------------------------------*/
/* See file B2H NEWS for details of changes in each release         */
/*------------------------------------------------------------------*/
 
trace 'O'
signal on syntax  name TRAPIT
signal on novalue name TRAPIT
signal on halt    name TRAPIT
parse source  env . exfn exft exfm . where .
parse version rexx_imp rexx_level .
numeric fuzz 1
 
release='R4.7 (390)'; call Time 'Reset'
 
parse value date('S') time('N'),
      with  today_yyyymmdd today_time,
            1   today_yyyy  5  today_month 7  today_day .,
            1 . today_hour ':' today_min  ':' today_sec .
 
parse value '' with ,
  ?centertag ?outputl83 ?outputp83,
  Abbrev. abstract anchortext ansfilel ansfilep apphd1 apphd1x,
  artaltlabel artaltopts bhtft. blankrec,
  bodyhd0 bodyhd0x bodyhd1 bodyhd1x buffer. cellscale_e cellscale_s,
  chans. charset colalignh. colalignv. colHP. colEHP. colshade.,
  commenthead coprext coprnote copyr confignames contact ctable2.,
  currpartl DDname. defcelldata defimbft deftext. defstyle dialog.,
  dmname docdesc. docstyle dottis dottit dottrs dottrt DSNs. DSorg.,
  ecittag edirectstr efigstr efont. endcelltag endrowtag epkstr. erev.,
  escreenstr expdate figcap. figid figtail firsthead figlistfile,
  font. fontname. fosave fp. frameline,
  GoToLabel. GoToLine. hdrline help_file here_list.,
  htag. htmldocid. htmlext htmlx. htmpext,
  ibmcopyr idxvalue. imbed. imbftext. imbpath imgpath index. indexlfile,
  infile. input_dd input_file input_mem,
  labels. lasthdlv ldesc. lenopts lerssep lerstemp. library_save list.,
  logfile logrecs. logstream macroparms mastalt mastimg mc. mctagname metakeys,
  MVSalloc. MVSOutputDsorg MVSsys. nfsave,
  optparms optray. outputl_case outputl_file outputpl_mem outputp_case,
  outputp_file outputp_fn outputp_fn1 outputp_fn2,
  outputp_ft outputp_fm outputp_mem outputp_path owner partdirl. partdirp.,
  partnamel. partnamep. pass1save pass2save pgmpath pgmfn pgmparms,
  platform psstack ptoclfile qid quest. questans questurl,
  rexximp rcoffstr reftype. rev. revchar. revdate revisionchar. rowcol.,
  sare_names sare_. sched. security seqtext. setuptag. shade.,
  source_id. source_id_orig. splitlink. stitle sym. symchars,
  synctl. syndat. synnt. synnt_id synnt_ids syntext_e syntext_s,
  sysvarwfid tabdata_e tabdata_s table2 tableid tabletail,
  tagdef. tagnest tbindnum tcap.,
  tdate tdocnum temp_file tfilenum title title_save titleopt tlistfile,
  toclfile topic_save tpartnum tprtloc trelease tsoprefix,
  tvendor tversion tvolnum ugdoc xlatefrom. xlateto.,
  xmpbeg xmpend xref.
parse value 1 with true,
  1 ?b2hreq 1 ?config. 1 ?cs. 1 ?dlfmt 1 ?figcaptop 1 ?figlistwanted,
  1 ?fnlinkto 1 ?fnlinkfrom 1 ?fontprop. 1 ?ftlink 1 ?ftsep 1 ?glfmt,
  1 ?IFcondx 1 ?ltgt 1 ?mastimg 1 ?msgnum 1 ?noisy,
  1 ?OKtoUse 1 ?questans 1 ?revprop. 1 ?su 1 ?splitlink,
  1 ?TAGatt. 1 ?tagcheck 1 ?TAGvat. 1 ?tlistwanted 1 ?tocindent,
  1 ?wantmeta 1 ?wanttoc 1 ?WriteToLog 1 ?xeditgchk 1 fontprop. 1 revprop.,
  1 tdwidth. 1 tophead 1 tblcolstrt. 1 tblphyscol 1 tblphysrow 1 tblrowstrt.
parse value 0 with false,
  1 ?!!gml,
  1 ?addressflag 1 ?addressprologflag 1 ?annot 1 ?appendix 1 ?artaltlabel,
  1 ?autoimbed 1 ?autolen. 1 ?autolensep 1 ?autosetup 1 ?autosplit.,
  1 ?backm 1 ?choicedl 1 ?coprext,
  1 ?DDmode. 1 ?DDprealloc. 1 ?debug 1 ?dialogflag 1 ?directflag 1 ?direxpand,
  1 ?dlfmterr 1 ?dm 1 ?dumpvars 1 ?eyelog 1 ?eyesay 1 ?eyetrc 1 ?fbc 1 ?figbr,
  1 ?figdescflag 1 ?figflag 1 ?figlistfnd 1 ?figlisthandled,
  1 ?fnflag 1 ?frontm 1 ?gdnum 1 ?glfmterr 1 ?imbedid 1 ?imbftext,
  1 ?index 1 ?indexfnd 1 ?indexref 1 ?labelfnd. 1 ?lenflag,
  1 ?libraryflag 1 ?lines 1 ?linesflag 1 ?listactive. 1 ?litdata,
  1 ?logappend 1 ?LogIsOpen 1 ?mcflag 1 ?noerase 1 ?normalcomplete 1 ?pc,
  1 ?prolog 1 ?pscflag 1 ?pscfound 1 ?questform 1 ?questionflag,
  1 ?revision. 1 ?screenflag 1 ?screenshade 1 ?setup 1 ?showhdrnum,
  1 ?showprof 1 ?showsym 1 ?synfont 1 ?synntflag 1 ?syntaxflag 1 ?tabdataflag,
  1 ?tableflag 1 ?tableprefix 1 ?tableprevrowtemp 1 ?tablethisrowtemp,
  1 ?TAGimmed. 1 ?TAGse. 1 ?TAGvalid. 1 ?tdescflag 1 ?temprow 1 ?tft,
  1 ?thd 1 ?tipagedone 1 ?titleflag 1 ?tlistfnd 1 ?tlisthandled,
  1 ?tocfnd 1 ?topicflag 1 ?traceactive,
  1 ?traceisopen 1 ?trcany 1 ?trcio 1 ?trcparse 1 ?trcpgm 1 ?trace2disk,
  1 ?vnotice 1 ?xeditg 1 ?xlatei 1 ?xlateo,
  1 _BRcount 1 _DDcnt 1 _ce 1 _choicenum 1 _figcapnum 1 _fignum 1 _fnnum,
  1 _gdnum 1 _h0num 1 _h1num 1 _hnum 1 _ignore 1 _ldescnest 1 _li 1 _linum,
  1 _macronest 1 _pknum 1 _PREcount 1 _PTOCcnt 1 _questnum 1 _rc,
  1 _sa 1 _spotnum 1 _synnt 1 _tablenum 1 _tcapnum 1 _toccnt 1 _uc 1 _us,
  1 apdxcnt 1 autobypass 1 bhtft.0 1 bypass. 1 col 1 colconcat.,
  1 colwidthlog. 1 colwidthlogpct. 1 colwidthlog_temp.,
  1 colwidthphys. 1 colwidthphyspct. 1 colwidthphyspct_orig.,
  1 colwidthphys_prev. 1 colwidthphys_temp.,
  1 configcnt 1 ctable2len. 1 currpartnum 1 dirchunk,
  1 figdesc. 1 flatcol 1 fontnest 1 footcount 1 hdrcnt. 1 headnum. 1 here_cnt,
  1 imbftextcase 1 incount. 1 index.0 1 indexcnt 1 infile.0 1 infilecnt,
  1 inwidth 1 lencnt. 1 lentext. 1 linenum 1 linenuml 1 linenums,
  1 listitem. 1 listnest 1 logrecs.0 1 lpc 1 macro. 1 maxwidth,
  1 numberh 1 numcols_logical 1 numcols_physical 1 numcols_physical_prev,
  1 numrows 1 olnest 1 orig_linewidth 1 outcount. 1 pass,
  1 precol 1 prereadnum 1 prevtotlen 1 ptocleast 1 ptocmost,
  1 questdl 1 quit_rc 1 refmax 1 rc 1 rc. 1 revnest 1 revnest.,
  1 row 1 saverec. 1 soc 1 syndat.0 1 syntax_container,
  1 table2len. 1 tagnest. 1 tblcolspan. 1 tblrowspan. 1 thiscol,
  1 tocsuppress 1 totalpartnum 1 xlatecs. 1 xref.0
 
string =,
  'A ADDRESS AE ALIGN ALL AMP AMPD ANS ANSFILE ANSTXT APPENDIX ARRANGE',
  'ARTLABEL ARTLINK AS AUTHOR BOTH CHAR CNT COLS COMPACT CONCAT COPYR COUNTER',
  'DAYS DATE DD DEBUG DIALOG DIALSYS DIALUSER DINGBAT DIRECT DL DOCNUM DOT',
  'DOTTBL DSN DT DVCF E ERROR ETERMHI EXIT FIFO FIG FIGLIST FIGURE',
  'FILE FLAT FM FN FN1 FN2 FOOTER FOOTNOTES FORCE FORM FRAME FROM FT GL',
  'HEADER HEADREC HLP HTMLCMT HTMLCMTL HTMLCMTR HTMLHEAD IBM IBMCOPYR ID IDTXT',
  'IMBED IMG IN INDENT INDEX INDEX0 INDEX1 INDEX2 INDEX3',
  'INDEXENTRYL INDEXENTRYR INDEXTOC INFO INPUT INTERNAL',
  'LBLBOX LEDIHD LEHD LEN LIBRARY LIFO LINK LIST LOG LOGICAL MC MEM MONTHS',
  'MSGNO NAME NAMEFILE NO NONE NONEST NOTE NOTEL NT',
  'OL OLLIST OLTYPE OUT OUTPUTPO OUTPUTPS',
  'PATH PE PG PGM PGMNUM PHYSICAL PRE PRO PROFMODE PS PTOC PTOCLT',
  'QANSREF QUESTION QQREF READ RECNUM RECNUMO REFIDTXT REGINA RESTORE REVNEST',
  'S SAVE SCHEDACTHD SCREEN SCRIPT SCRIPTONLY SEQ SETUP',
  'SL SPOT1 SPOT2 STYLE SYM SYNNT SYNTAX SYS SYSVARW',
  'T2XREF TAG TABLE TAGTBL TD TDESC TEMP TERM TERMHI TFL TH',
  'TIME TITLE TLIST TO TOC TOPIC TR TRACE TSIZE TYPE',
  'UC UL USER USERINP USERMSG VIEW VOLNUM WRITE WARNING YES'
if rexx_level >= 4.00
  then do while string \= ''
    parse var string atom string; call value '!'atom, atom
    end
  else do while string \= ''
    parse var string atom string; interpret '!'atom '= "'atom'"'
    end
 
/*----- define known DCF/GML/Bookie abbreviations -----*/
/*----- (most not documented by DCF/GML/Bookie!)  -----*/
string = '*CENTER CENTRE *COLS COL COLUMN COLUMNS *COMMENTS COMMENT',
         '*COMPACT C *CWIDTHS CWIDTH *DEFAULTS DEFAULT *EXAMPLES EXAMPLE',
         '*FLAGS FLAG *LANGUAGE LANG *MESSAGES MESSAGE',
         '*NUMBYTES NUMBYTE *OMIT O *OPTIONS OPTION *PAGEREF PR',
         '*PARMS PARM *PREREQS PREREQ *PROC P *RESULTS RESULT',
         '*RETCODES RETCODE *XPROC XP'
i = ''
do while string \= ''
  parse var string atom string
  if left(atom,1) = '*'
    then i = substr(atom,2)
    else Abbrev.atom = i
  end
 
/*----- B2H system filespec/DDnames on MVS -----*/       /* !OPSYS! */
  /* --------------------------------------------- *
   | Change the DSnames here before using *CHANGE* |
   * --------------------------------------------- */
MVSsys.!pro.!dd="B2HPRO" ; MVSsys.!pro.!dsn="hlq.B2H.PROFILE"
MVSsys.!sym.!dd="B2HSYM" ; MVSsys.!sym.!dsn="hlq.B2H.SYMBOLS"
MVSsys.!hlp.!dd="B2HHELP"; MVSsys.!hlp.!dsn="hlq.B2H.HELP"
 
tracelist. = 'O'
parse value '1 2 3 4 5 6 7 8 9',                         /* !OPSYS! */
      with  CMS OS2 AIX HPFS WIN95 WINNT MVS LINUX UNIX .
parse value 'CMS OS2 AIX HPFS WIN95 WINNT MVS LINUX UNIX',
      with  platform.CMS platform.OS2 platform.AIX platform.HPFS,
            platform.WIN95 platform.WINNT platform.MVS platform.LINUX,
            platform.UNIX .
destsys=MVS; htmlrel=3; htmlenvs='2+ 3 3+'
 
parse value '2 3.2 4',
      with  htmldocid.2 htmldocid.3 htmldocid.4 .
parse value '+,+,+,|,-,=, , ',
      with  table2.1 ',' table2.2 ',' table2.3 ',' table2.4 ',',
            table2.5 ',' table2.6 ',' table2.7 ',' table2.8
do i = 1 to 8; table2len.i = length(table2.i); end
 
parse value '<DL>,</DL>,<P><DT>,,<DD>,,<DL COMPACT>,</DL>,<DT>,,<DD>,',
  with  list.!dl.0.1 ',' list.!dl.0.2 ',' list.!dl.0.3 ',' list.!dl.0.4 ',',
        list.!dl.0.5 ',' list.!dl.0.6 ',',
        list.!dl.1.1 ',' list.!dl.1.2 ',' list.!dl.1.3 ',' list.!dl.1.4 ',',
        list.!dl.1.5 ',' list.!dl.1.6
parse value '<TABLE CELLPADDING="3">,</TABLE>,' ||,
            '<TR VALIGN="TOP"><TD><P>,</TD>,<TD><P>,</TD></TR>,' ||,
            '<TABLE CELLPADDING="3">,</TABLE>,' ||,
            '<TR VALIGN="TOP"><TD>,</TD>,<TD>,</TD></TR>',
  with  list.!dl.2.1 ',' list.!dl.2.2 ',' list.!dl.2.3 ',' list.!dl.2.4 ',',
        list.!dl.2.5 ',' list.!dl.2.6 ',',
        list.!dl.3.1 ',' list.!dl.3.2 ',' list.!dl.3.3 ',' list.!dl.3.4 ',',
        list.!dl.3.5 ',' list.!dl.3.6
parse value '<SUP>,</SUP>,<DL COMPACT>,</DL>,<P><DT><SUP>,' ||,
            '</SUP></DT>,<DD>,</DD>,<HR>,',
  with  list.!fn.1 ',' list.!fn.2 ',' list.!fn.3 ',' list.!fn.4 ',',
        list.!fn.5 ',' list.!fn.6 ',' list.!fn.7 ',' list.!fn.8 ',',
        list.!fn.9 ',' list.!fn.10 ','
parse value '<DL>,</DL>,<P><DT>,,<DD>,<DD>,,' ||,
            '<P><DT><FONT SIZE="+2"><STRONG>,</STRONG></FONT><P>,' ||,
            '<DL COMPACT>,</DL>,<DT>,,<DD>,<DD>,,' ||,
            '<P><DT><FONT SIZE="+2"><STRONG>,</STRONG></FONT><P>',
  with  list.!gl.0.1 ',' list.!gl.0.2 ',' list.!gl.0.3 ',' list.!gl.0.4 ',',
        list.!gl.0.5 ',' list.!gl.0.6 ',' list.!gl.0.7 ',',
        list.!gl.0.8 ',' list.!gl.0.9 ',',
        list.!gl.1.1 ',' list.!gl.1.2 ',' list.!gl.1.3 ',' list.!gl.1.4 ',',
        list.!gl.1.5 ',' list.!gl.1.6 ',' list.!gl.1.7 ',',
        list.!gl.1.8 ',' list.!gl.1.9
parse value '<TABLE CELLPADDING="3">,</TABLE>,' ||,
            '<TR VALIGN="TOP"><TD><P>,</TD>,<TD><P>,<BR>,</TD></TR>,' ||,
            '<TR><TD COLSPAN="2"><FONT SIZE="+2"><STRONG><P>,' ||,
            '<P></STRONG></FONT></TD></TR>,' ||,
            '<TABLE CELLPADDING="3">,</TABLE>,' ||,
            '<TR VALIGN="TOP"><TD>,</TD>,<TD>,<BR>,</TD></TR>,' ||,
            '<TR><TD COLSPAN="2"><FONT SIZE="+2"><STRONG>,' ||,
            '</STRONG></FONT></TD></TR>',
  with  list.!gl.2.1 ',' list.!gl.2.2 ',' list.!gl.2.3 ',' list.!gl.2.4 ',',
        list.!gl.2.5 ',' list.!gl.2.6 ',' list.!gl.2.7 ',',
        list.!gl.2.8 ',' list.!gl.2.9,
        list.!gl.3.1 ',' list.!gl.3.2 ',' list.!gl.3.3 ',' list.!gl.3.4 ',',
        list.!gl.3.5 ',' list.!gl.3.6 ',' list.!gl.3.7 ',',
        list.!gl.3.8 ',' list.!gl.3.9
parse value '<MENU>,</MENU>,<LI>,</LI>,<STRONG>,</STRONG>',
      with  list.!index.1 ',' list.!index.2 ',' list.!index.3 ',',
            list.!index.4 ',' list.!index.5 ',' list.!index.6
parse value ',<HR>,,<BR>,,<BR>,,',
      with  list.!indextoc.1 ',' list.!indextoc.2 ',',
            list.!indextoc.3 ',' list.!indextoc.4 ',',
            list.!indextoc.5 ',' list.!indextoc.6 ',',
            list.!indextoc.7 ',' list.!indextoc.8
parse value '<OL>,</OL>,<P><LI>,,<OL COMPACT>,</OL>,<LI>,',
  with  list.!notel.0.1 ',' list.!notel.0.2 ',' list.!notel.0.3 ',',
        list.!notel.0.4 ',',
        list.!notel.1.1 ',' list.!notel.1.2 ',' list.!notel.1.3 ',',
        list.!notel.1.4 ','
parse value '<OL>,</OL>,<P><LI>,,<OL COMPACT>,</OL>,<LI>,',
  with  list.!ol.0.1 ',' list.!ol.0.2 ',' list.!ol.0.3 ',' list.!ol.0.4 ',',
        list.!ol.1.1 ',' list.!ol.1.2 ',' list.!ol.1.3 ',' list.!ol.1.4 ','
parse value '<DL>,</DL>,<DD><P>,,<DL COMPACT>,</DL>,<DD>,',
  with  list.!sl.0.1 ',' list.!sl.0.2 ',' list.!sl.0.3 ',' list.!sl.0.4 ',',
        list.!sl.1.1 ',' list.!sl.1.2 ',' list.!sl.1.3 ',' list.!sl.1.4 ','
parse value '<TT>,</TT>,<B>,</B>,<FONT COLOR="BLUE">,</FONT>',
            ',,,,,',
      with  list.!sys.0.1  ',' list.!sys.0.2  ',',
            list.!sys.1.1  ',' list.!sys.1.2  ',',
            list.!sys.2.1  ',' list.!sys.2.2  ',',
            list.!user.0.1 ',' list.!user.0.2 ',',
            list.!user.1.1 ',' list.!user.1.2 ',',
            list.!user.2.1 ',' list.!user.2.2
parse value '<OL>,</OL>,<LI>,</LI>,<P>,<P>,,<BR>',
      with  list.!tfl.0.1 ',' list.!tfl.0.2 ',',
            list.!tfl.0.3 ',' list.!tfl.0.4 ',',
            list.!tfl.1.1 ',' list.!tfl.1.2 ',',
            list.!tfl.1.3 ',' list.!tfl.1.4 ','
parse value '<MENU>,</MENU>,<LI>,,<HR>,',
      with  list.!toc.1 ',' list.!toc.2 ',' list.!toc.3 ',' list.!toc.4 ',',
            list.!toc.5 ',' list.!toc.6 ','
parse value '<UL>,</UL>,<P><LI>,,<UL COMPACT>,</UL>,<LI>,',
  with  list.!ul.0.1 ',' list.!ul.0.2 ',' list.!ul.0.3 ',' list.!ul.0.4 ',',
        list.!ul.1.1 ',' list.!ul.1.2 ',' list.!ul.1.3 ',' list.!ul.1.4 ','
 
/*----- default text for various tags -----*/
vbar       = '&#124;'                  /* vertical bar in HTML      */
bodytag    = '<BODY>'
bordertag. = 'BORDER="1"'
hrtag.     = '<HR>'
htag.      = '<P><I><B>,:&nbsp;</B></I>&nbsp;,:P.,'
htag.0     = '<HR><H1>,</H1>'
htag.1     = '<HR><H1>,</H1>'
htag.2     = '<HR><H2>,</H2>'
htag.3     = '<P><H3>,</H3>'
htag.4     = '<P><H4>,</H4>'
i='XLIGHT'       ;shade.i='BGCOLOR="#DADADA"'
i='LIGHT'        ;shade.i='BGCOLOR="#B0B0B0"'
i='MEDIUM'       ;shade.i='BGCOLOR="#8C8C8C"'
i='DARK'         ;shade.i='BGCOLOR="#6E6E6E"'
i='XDARK'        ;shade.i='BGCOLOR="#585858"'
i='YES'          ;shade.i='BGCOLOR="#B0B0B0"'
i='SCREEN'       ;shade.i='BGCOLOR="#B0B0B0"'
i='ABBREV'       ;deftext.i='List of Abbreviations'
i='ABSTRACT'     ;deftext.i='Abstract'
i='BIBLIOG'      ;deftext.i='Bibliography'
i='GLOSSARY'     ;deftext.i='Glossary'
i='IBMZALI'      ;deftext.i='<HR><B>IBM License Information</B><HR>'
i='IBMZALP'      ;deftext.i='<HR><B>IBM Licensed Program Specifications</B><HR>'
i='INDEXENTRYL'  ;deftext.i='('
i='INDEXENTRYR'  ;deftext.i=')'
i='LEGEND'       ;deftext.i='Legend'
i='LERSAUTH'     ;deftext.i='Authorization'
i='LERSCOMMENTS' ;deftext.i='Comments'
i='LERSCONTEXT'  ;deftext.i='Context'
i='LERSDEFAULTS' ;deftext.i='Defaults'
i='LERSERRCOND'  ;deftext.i='Error Conditions'
i='LERSEXAMPLES' ;deftext.i='Examples'
i='LERSFLAGS'    ;deftext.i='Flags'
i='LERSFORMAT'   ;deftext.i='Format'
i='LERSINTREP'   ;deftext.i='Internal Representation'
i='LERSMESSAGES' ;deftext.i='Messages'
i='LERSOPTIONS'  ;deftext.i='Options'
i='LERSOTHE'     ;deftext.i=''
i='LERSPARMS'    ;deftext.i='Parameters'
i='LERSPREREQS'  ;deftext.i='Prerequisites'
i='LERSPROCESS'  ;deftext.i='Processing'
i='LERSPURPOSE'  ;deftext.i='Purpose'
i='LERSRELATED'  ;deftext.i='Related Information'
i='LERSRESTRICT' ;deftext.i='Restrictions'
i='LERSRESULTS'  ;deftext.i='Results'
i='LERSRETCODES' ;deftext.i='Return Codes'
i='LERSSYSENV'   ;deftext.i='System Environment'
i='LERSUSAGE'    ;deftext.i='Usage'
i='LERSVERSION'  ;deftext.i='Version'
i='MCDEST'       ;deftext.i='Destination'
i='MCMODULE'     ;deftext.i='Module'
i='MCNUMBYTES'   ;deftext.i='Number of Error Bytes'
i='MCORESP'      ;deftext.i='Operator Response'
i='MCPRESP'      ;deftext.i='Programmer Response'
i='MCPROBD'      ;deftext.i='Problem Determination'
i='MCSEVERITY'   ;deftext.i='Severity'
i='MCSPRESP'     ;deftext.i='System Programmer Response'
i='MCSYSACT'     ;deftext.i='System Action'
i='MCURESP'      ;deftext.i='User Response'
i='MCXPL'        ;deftext.i='Explanation'
i='NOTE'         ;deftext.i='Note'
i='NOTEL'        ;deftext.i='Notes'
i='NT'           ;deftext.i='Note'
i='PREFACE'      ;deftext.i='Preface'
i='SAFETY'       ;deftext.i='Safety'
i='SOA'          ;deftext.i='Summary of Amendments'
i='WARRFULL'     ;deftext.i=,
  'This program is warranted as specified in the IBM license.<p>Licensed',
  'Program Specifications may be updated from time to time and such updates',
  'may constitute a change in specifications.<p>For Distributed Systems',
  'License Option (DSLO) Licenses, warranty service, if any, will be',
  'provided only through the Basic License location.<p>Following the',
  'discontinuance of all program services, this program will be provided',
  '"As Is" as specified in the IBM license.'
i='WARRNODSLO'   ;deftext.i=,
  'This program is warranted as specified in the IBM license.<p>Licensed',
  'Program Specifications may be updated from time to time and such updates',
  'may constitute a change in specifications.<p>Following the discontinuance',
  'of all program services, this program will be provided "As Is" as',
  'specified in the IBM license.'
i='WARRASIS'     ;deftext.i='This program is provided "As Is"',
  'as specified in the IBM license.'
deftext.!appendix  = 'Appendix'
deftext.!artlink   = 'View figure.'
deftext.!copyr     = '&copy; Copyright &b2hcopyr. &b2hcoprext'
deftext.!days      = 'Mon Tue Wed Thu Fri Sat Sun'
deftext.!dialsys   = 'System'
deftext.!dialuser  = 'User'
deftext.!docnum    = 'Document Number'
deftext.!figlist   = 'Figures'
deftext.!figure    = 'Figure'
deftext.!htmlcmtl  = '<!-- '
deftext.!htmlcmtr  = ' -->'
deftext.!htmlhead  = '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML &b2hhtmlid//EN">'
deftext.!footnotes = 'Footnotes'
deftext.!ibmcopyr  = '<B>&copy; Copyright International Business Machines',
                     'Corporation &b2hibmcopyr..',
                     'All rights reserved. &b2hcoprext</B>',
                     '<BR>Note to U.S. Government Users -- Documentation',
                     'related to restricted rights -- Use, duplication or',
                     'disclosure is subject to restrictions set forth in',
                     'GSA ADP Schedule contract with IBM Corp.'
deftext.!index     = 'Index'
deftext.!index0    = 'Special Characters'
deftext.!index1    = 'Numerics'
deftext.!index2    = 'See also'
deftext.!index3    = 'See'
deftext.!months    = 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'
deftext.!ptoc      = 'Partial Table-of-Contents'
deftext.!ptoclt    = '(Go to main Table-of-Contents)'
deftext.!qansref   = 'the answer to question'
deftext.!qqref     = 'question'
deftext.!schedacthd= 'Activities'
deftext.!spot1     = 'Ref #'
deftext.!spot2     = ' reference #'
deftext.!synnt     = 'Note:'
deftext.!t2xref    = 'the appropriate section'
deftext.!table     = 'Table'
deftext.!tlist     = 'Tables'
deftext.!toc       = 'Table of Contents'
deftext.!volnum    = 'Volume'
/*----- default syntax diagram "graphic" characters & widths -----*/
deftext._start          = '&gt;&gt;' ;lentext._start          = 2
deftext._middle         = '&gt;'     ;lentext._middle         = 1
deftext._end            = '&gt;&lt;' ;lentext._end            = 2
deftext._fragment_start = vbar       ;lentext._fragment_start = 1
deftext._fragment_end   = vbar       ;lentext._fragment_end   = 1
deftext._fragref_start  = vbar       ;lentext._fragref_start  = 1
deftext._fragref_end    = vbar       ;lentext._fragref_end    = 1
deftext._upperleft      = '+'        ;lentext._upperleft      = 1
deftext._middleleft     = vbar       ;lentext._middleleft     = 1
deftext._lowerleft      = '+'        ;lentext._lowerleft      = 1
deftext._upperright     = '+'        ;lentext._upperright     = 1
deftext._middleright    = vbar       ;lentext._middleright    = 1
deftext._lowerright     = '+'        ;lentext._lowerright     = 1
deftext._teeup          = '+'        ;lentext._teeup          = 1
deftext._teedown        = '+'        ;lentext._teedown        = 1
deftext._teeleft        = vbar       ;lentext._teeleft        = 1
deftext._teeright       = vbar       ;lentext._teeright       = 1
deftext._cross          = '+'        ;lentext._cross          = 1
deftext._dash           = '-'        ;lentext._dash           = 1
deftext._repsepleft     = '&lt;-'    ;lentext._repsepleft     = 2
deftext._repsepright    = '--&lt;'   ;lentext._repsepright    = 3
deftext._repsepjoinl    = 'V'        ;lentext._repsepjoinl    = 1
deftext._repsepjoinr    = '+'        ;lentext._repsepjoinr    = 1
/*----- messages & codes tags -----*/
mctags='DEST MODULE NUMBYTES ORESP PRESP PROBD SEVERITY SPRESP SYSACT URESP XPL'
/*----- default MVS dataset allocation -----*/
/* LBD: changed V to v b */
MVSalloc.        = ,
   'DSORG(PS) LRECL(1024) RECFM(v b) TRACKS    SPACE(5,5) RELEASE'
MVSalloc.!trace  = ,
    'DSORG(PS) LRECL(1024) RECFM(v b) CYLINDERS SPACE(5,5) RELEASE'
MVSalloc.!outputpo = MVSalloc.!outputps 'DIR(10)'
/*----- valid LERS/LEN/LEDI categories -----*/
ledicat='AUTH COMMENTS CONTEXT DEFAULTS ERRCOND EXAMPLES FLAGS FORMAT',
        'INTREP MESSAGES OPTIONS OTHER PARMS PREREQS PROCESS PURPOSE',
        'RELATED RESTRICT RESULTS RETCODES SYSENV USAGE VERSION'
/*----- out-of-sequence msg text -----*/
seqtext.!dialog  ='found outside of a dialog!'
seqtext.!direct  ='found outside of directory list!'
seqtext.!fig     ='found outside of a figure!'
seqtext.!list    ='found outside of a list!'
seqtext.!mc      ='found outside of a message/code list!'
seqtext.!syntax  ='found outside of a syntax diagram!'
seqtext.!table   ='found outside of a table!'
seqtext.!question='found outside of a question!'
/*----- misc definitions -----*/
parse value '_I_ _IW_ _IA_ _IAW_',
      with  !ignore !ignorew !ignoreall !ignoreallw
parse value '-99 0 0 4 8 12 16',
      with  !msgignore rc.!userinp rc.!usermsg,
            rc.!info rc.!warning rc.!error rc.!term
parse value 'ANSR ANSWER FIG FN HDR LEN LI Q SPT TBL',
      with  !ansref !answer !figref !fnref !hdref !lenref !liref !qref,
            !spotref !tref
parse value 'Ans_Ref_ Answer_ Figure_ Footnote_ Header_ Len_ Li_',
            'Q_Ref_ Spot_Ref_ Table_',
      with  reftype.!ansref reftype.!answer reftype.!figref,
            reftype.!fnref reftype.!hdref reftype.!lenref reftype.!liref,
            reftype.!qref reftype.!spotref reftype.!tref
parse value 'gif - 50 999 SHORTDATE',
            '999999 2 0 100 20 3 <P>',
            '999 &PGM 0123456789ABCDEF 0123456789 b2hlink.gif 1ai',
      with  arttype dash max_titlelen minhdlv cms_dateformat,
            noshowlines pdnum pdtype showlines toclimit tocmax tocspacer,
            !totlen !userpgm hexchars numchars artlinkimg olseq
parse value ': : 1 :E :E 2 ; ; 1',
      with  !!gml !!gml_def !!gml_len !!egml !!egml_def !!egml_len,
            !!cw  !!cw_def  !!cw_len
parse value '15'x '09'x '00'x '01'x 'FE'x 'FF'x '15FF15'x,
      with  nl    tab   x00   x01   xFE   xFF   omitrecord
parse value !view !script 'I/O PGM PRS' with artshow source !io !pgm !parse
parse value '0 31 28 31 30 31 30 31 31 30 31 30 31',
      with  d. d.1 d.2 d.3 d.4 d.5 d.6 d.7 d.8 d.9 d.10 d.11 d.12 .
 
_alarmcnt   = 5
?liref      = 2                        /* assume LIREF=NUM          */
?prcnoendtag= !warning                 /* PROCACT='NOENDTAG=WARNING'*/
?prcnoimbed = !error                   /* PROCACT='NOIMBED=ERROR'   */
?prcnoindex = !warning                 /* PROCACT='NOINDEX=WARNING' */
?prcnoper   = !warning                 /* PROCACT='NOPER=WARNING'   */
?prcnoxref  = !error                   /* PROCACT='NOXREF=ERROR'    */
?prcunkopt  = !term                    /* PROCACT='UNKOPT=TERM'     */
?prcunksym  = !term                    /* PROCACT='UNKSYM=TERM'     */
?prcunktag  = !warning                 /* PROCACT='UNKTAG=WARNING'  */
alphalc     = 'abcdefghijklmnopqrstuvwxyz'
alphauc     = translate(alphalc)
alphaucnum  = alphauc || numchars
alphanum    = alphauc || alphalc || numchars
apphd1      = nl                       /* show no value given       */
autosplit   = -1                       /* -1=NO, 0=YES, 1=by header */
b2hdelim    = '02'x                    /* internal delimiter char   */
base36uc    = numchars || alphauc      /* Base36 chars (upper-case) */
base36lc    = numchars || alphalc      /* Base36 chars (lower-case) */
blank       = '&nbsp;'
blanks      = '&nbsp;&nbsp;'
bookpart    = 1                        /* 0=Front, 1=Body, 2=Back   */
break       = '<BR>'; breaklen = 4
choiceqid   = 'INVALIDID'
cmtlen      = 64                       /* HTML comment text width   */
colfill.    = ' '
dialog      = 'LABEL'
dirchar.    = '\'
envname     = 'B2HPATH'
eyecatch.0  = '|-Type---|'
eyecatch.1  = '|MsgNum Type---|'
gmltypes    = 'PK PV APL HP0 HP1 HP2 HP3 HP4 HP5 HP6 HP7 HP8 HP9'
ignoreumsg  = 'not a valid BookMaster/GML tag'
ignorewmsg  = 'has no HTML equivalent'
indextoc    = 50
linewidth.  = 78
llcnt       = 1
msglevel    = rc.!info
newcol_tags = '<BR> <P>'
noperiod    = 'No tag-ending period found'
noyes       = 'NO YES'
noyesval    = '0 1'
outputfm    = 'A'
psc         = 'CHAR HTML'
ptoclevel   = 4
questmethod = 'GET'
qreset      = -1
shades      = 'YES XLIGHT LIGHT MEDIUM DARK XDARK SCREEN'
tagcharsuc  = alphauc'@#$'             /* valid chars in a tag      */
tocret      = 2                        /* assume TOCRET=PTOC        */
 
BOTname     = 'Bot_Of_Page'
FIGLISTname = 'FIGLIST_START'
FTprefix    = 'FT_'
IDXname     = 'INDEX_START'
PTOCname    = 'PToC'
TLISTname   = 'TLIST_START'
TOCname     = 'ToC'
TOPname     = 'Top_Of_Page'
 
/*----- Define initial INDEX translation sort table -----*/
indexxlate  = copies('00'x,256)        /* '00'x = Special character */
string = numchars                      /* '01'x = Numerics          */
do while string \= ''
  parse var string 1 atom 2 string
  indexxlate = overlay('01'x,indexxlate,c2d(atom)+1)
  end
string = alphauc                       /* remainder are themselves  */
do while string \= ''
  parse var string 1 atom 2 string
  indexxlate = overlay(atom,indexxlate,c2d(atom)+1)
  end
 
/*----- internal table and &variable definitions -----*/
i='TDEF'; tagdef.i.99999 = "cols='*' align='L'"
aligntextv. = 'TOP'
i='T'; aligntextv.i='TOP'
i='M'; aligntextv.i='MIDDLE'
i='C'; aligntextv.i='MIDDLE'
i='B'; aligntextv.i='BOTTOM'
aligntexth. = 'LEFT'
i='L'; aligntexth.i='LEFT'
i='C'; aligntexth.i='CENTER'
i='R'; aligntexth.i='RIGHT'
 
/*----- valid parameters on :DOCPROF tag -----*/
docprof_parms =,
  'APPHD1 APPHD1X BODYHD0 BODYHD0X BODYHD1 BODYHD1X DIALOG DUPLEX EPTOC',
  'FBC FIGLIST FMTOC FTSEP HDPREF HEADNUM HYPHEN JUSTIFY KEYBOARD LANGUAGE',
  'LAYOUT LDRDOTS MINDEXNM MINDEXPG OLSEQ OLSTYLE OLXMPC OLXMPS PAGENUM',
  'PSRES PTOC PUNCT QRESET RHRFRULE SCREEN STITLE STYLE STYPE SUBJSEL',
  'TIPAGE TLIST TOC ULSEQ VOLPREF XREFPAGE',
  'CAPBC EQBC FNBC'                    /* IUO extensions            */
 
 
/********************************************************************/
/* Begin program execution                                          */
/********************************************************************/
 
/*----- determine under which REXX I'm running -----*/
if translate(left(rexx_imp,12)) == 'REXX-REGINA_'
  then do
    rexximp = !regina
    env     = translate(uname('S'))
    end
  else rexximp = !ibm
 
/*----- determine platform environment -----*/
currsys = ''
select                                                   /* !OPSYS! */
  when env='AIX'       then currsys=AIX
  when env='AIX/6000'  then currsys=AIX
  when env='CMS'       then currsys=CMS
  when env='LINUX'     then currsys=LINUX
  when env='TSO'       then currsys=MVS
  when env='OS/2'      then currsys=OS2
  when env='UNIX'      then currsys=UNIX
  when env='Windows95' then currsys=WIN95
  when env='WIN32S'    then currsys=WIN95
  when env='WIN95'     then currsys=WIN95
  when env='WIN98'     then currsys=WIN95
  when env='WINME'     then currsys=WIN95
  when env='WindowsNT' then currsys=WINNT
  when env='WINNT'     then currsys=WINNT
  when env='WIN2K'     then currsys=WINNT
  when env='WINXP'     then currsys=WINNT
  otherwise call MsgOut !term 200,'Environment type "'env'" unknown!'
  end
 
/*----- get data from the command line; initialize -----*/
pgmparms = arg(1)
if currsys = MVS                                         /* !OPSYS! */
  then parse var pgmparms input_file     optparms
  else parse var pgmparms input_file '(' optparms
input_file = space(input_file)
optparms   = strip(optparms)
if input_file = '?' then input_file = ''
if left(optparms,1)  = '(' then optparms = substr(optparms,2)
if right(optparms,1) = ')' then optparms = left(optparms,length(optparms)-1)
call Init_Environment
call EraseFile tracefile
temp = translate(optparms)
if wordpos('NOISY',temp) > 0 then ?noisy = true
if wordpos('QUIET',temp) > 0 then ?noisy = false
if \?pipe & ( input_file='' ) then call Show_Help
if input_file \= ''
  then call MsgOut !info 105,,
        'Conversion started:' today_yyyy'-'today_month'-'today_day today_time
 
/*----- initial symbol defines -----*/
string = 'b2hbot b2hnext b2hprev b2htoc b2htop b2hidx b2hthis b2hptoc'
do j=1 by 1 while string\=''
  parse var string atom string
  b2hvars.j = atom
  end
call DefSymbol '$IXB',' ', '$IXI','', '$LIB',0, '$MCS', '.',,
               '$OUT','FILE', '$PASS',1, '$PN',1, '$PSNO',1, '$TWO',0
call DefSymbol '$CW',!!cw, '$DCF', release, '$GML',!!gml, '$EGML',!!egml,,
               '$PARM',optparms, '$SYS',platform.currsys
call DefSymbol 'date',date(), 'time',today_time,,
               '$TAB',tab, '$tab',tab, 'tab',tab
call DefSymbol 'SYSYEAR',substr(today_yyyy,3,2), '$YEAR',today_yyyy,,
               'SYSMONTH',today_month, 'SYSDAYOFM',today_day,,
               'SYSDAYOFW',(date('B')+1)//7 + 1,,
               'SYSDAYOFY',right(date('D'),3,'0'), 'SYSHOUR',today_hour,,
               'SYSMINUTE',today_min, 'SYSSECOND',today_sec
 
/*----- process command line parms -----*/
select                                                   /* !OPSYS! */
 when currsys = CMS then input_file = translate(input_file)
 when currsys = MVS then do
   prevdd=''; input_file=translate(input_file)
   /*----- determine what's been pre-allocated -----*/
   cmd = "LISTALC STATUS HISTORY"
   if ?pipe
     then pipcmd 'var cmd | TSO | stem recs.'
     else do; i=OUTTRAP('RECS.'); address TSO cmd; i=OUTTRAP('OFF'); end
   do i=2 to recs.0
     dsn = word(recs.i,1);
     if dsn='TERMFILE' | dsn='NULLFILE' then iterate i
     i = i + 1
     temp  = recs.i
     dsorg = word(temp,1)
     if words(temp) > 5                /* DD name here?             */
       then thisdd = word(temp,5)      /*   yes, get it's name      */
       else thisdd = prevdd            /*    no, use prev DD name   */
     if dsorg \= 'PO' then parse var dsn dsn '('
     DSNs.thisdd = DSNs.thisdd||dsn' '
     DSorg.dsn   = dsorg
     prevdd      = thisdd
     end; drop recs.
   /*----- determine input file -----*/
   select
     when left(input_file,3) = 'DD:' then do
       parse var input_file 'DD:' input_dd . '(' input_mem . ')'
       input_file = GetDSNbyDD(input_dd,input_mem,'IN',1)
    /* DDname.input_file=input_dd; ?DDprealloc.input_file=1 */
       end
     when left(input_file,1) = "'"     /* fully-qualified dsn?      */
       then parse var input_file "'" input_file . "'"
     otherwise input_file = tsoprefix || input_file
     end
   end
 when wordpos(currsys,OS2 HPFS WIN95 WINNT) > 0
   then if left(input_file,1) = '"'    /* remove " if present       */
     then parse value input_file with 1 _ 2 input_file (_)
 otherwise nop
 end
 
/*----- process options and load system control files -----*/
call SetOpts optparms,0,0,0
call LoadSymbols syssymbol, 'system symbol table'
call LoadProfile sysprofile,'system profile',1,0,1
call SetOpts optparms,1,0,1
synctl._maxwidth = linewidth.llcnt /* Reset in case it changed */
 
/*----- processing for the input file -----*/
input_dsorg = 'PS'                     /* assume input is seq file  */
if ?pipe                               /* am I a pipeline filter?   */
  then do                              /*   yes, set dummy values   */
    parse value '$TEMP$',
          with  input_fn 1 input_fn2,
                input_path input_fn1 input_ft input_fm input_mem
    input_file = 'PIPELINE DATA STREAM'
    input_date=today_yyyy'-'today_month'-'today_day; input_time=today_time
    call DefSymbol 'b2hiall',input_file, 'b2hipath','',,
                   'b2hifile',subword(input_file,1,2),,
                   'b2hidate',input_date, 'b2hitime',input_time
    end
  else do                              /*  no, locate input file    */
    qrc = FindFile(input_file)
    if qrc = 0                         /* was input file found?     */
      then do                          /*   yes, save values        */
        input_file = fp.!all
        input_path = fp.!path
        input_fn   = fp.!fn
        input_fn1  = fp.!fn1
        input_fn2  = fp.!fn2
        input_ft   = fp.!ft
        input_fm   = fp.!fm
        input_mem  = fp.!mem
        call DefSymbol 'b2hiall',input_file, 'b2hipath',input_path
        if currsys = MVS then input_dsorg = SYSDSORG     /* !OPSYS! */
        if currsys = CMS                                 /* !OPSYS! */
          then call DefSymbol 'b2hifile', input_fn input_ft
          else call DefSymbol 'b2hifile', fp.!file
        parse value FileDate(input_file) with input_date input_time .
        call DefSymbol 'b2hidate',input_date, 'b2hitime',input_time
        call Initial_Source_Options
        end
      else call FileNotFound !term,,input_file
    end
 
/*----- platform/filename-related options should now be set -----*/
call SetOpts_FinalProcess
if logfile = ''                        /* log dataset name given?   */
  then ?WriteToLog = false             /*   no, don't use it        */
  else do                              /*   yes, open file & write  */
    if pos('*',logfile) > 0 then do    /*       include filename?   */
      parse value logfile with temp1 '*' temp2
      logfile = temp1 || input_fn || temp2
      end
    if logstream = '' then do          /* log to a disk file?       */
      if \?logappend then call GetReadyForOutput logfile, !log
      call OpenFile logfile,!write,MVSalloc.!log,word('OLD MOD',?logappend+1)
      end
    ?LogIsOpen=true
    do i = 1 to logrecs.0              /* write any queued log recs */
      call WriteLog logrecs.i
      end
    logrecs.0 = 0
  end
call SetOpts_GlobalCheck
call SetDestSysDefaults
call Set_SplitLink
if currsys = destsys
  then temp = platform.currsys
  else temp = platform.currsys'-'platform.destsys
call DefSymbol 'b2hplatc',platform.currsys, 'b2hplat',temp,,
               'b2hplatd',platform.destsys, 'b2hsig',pgmfn release,,
               'b2hparttop','',             'b2hpartbot',''
 
/*----- processing for the *physical* output file -----*/
outputp_dsorg = 'PS'
select
  when outputp_file = '' then do       /* set name if not given     */
    if input_mem = ''                  /* include member name?      */
      then temp = input_fn2
      else temp = input_fn2'.'input_mem
    outputp_file=OutFileName(,,input_fn1,temp,htmpext,,currsys,!physical)
    end
  when currsys=MVS &,                                    /* !OPSYS! */
       translate(left(outputp_file,3))='DD:' then do
    parse upper var outputp_file 'DD:' ddff . '(' ddmem . ')'
    outputp_file = GetDSNbyDD(ddff,ddmem,'OUT',1)
    DDname.outputp_file = ddff
    ?DDprealloc.outputp_file = 1
    end
  otherwise outputp_file = FileCase(outputp_file,!physical)
  end
if ?pipe                             /* running as pipeline filter? */
  then parse value '$TEMP$',         /*   yes, set dummy values     */
             with  outputp_fn 1 temp 1 outputp_fn2,
                   outputp_path outputp_fn1 outputp_ft outputp_fm
  else do                            /*    no, init output file     */
    if currsys = MVS                                     /* !OPSYS! */
      then do                        /* if MVS, PS or PO output?    */
        SYSDSORG = ''
        qrc = FindFile(outputp_file)
        if qrc \= 0 then call FileParts outputp_file
        select
          when SYSDSORG \= '' then outputp_dsorg = SYSDSORG
          when fp.!mem  \= '' then outputp_dsorg = 'PO'
          otherwise                outputp_dsorg = 'PS'
          end
        if outputp_dsorg = 'PO'
          then MVSOutputDsorg = !outputpo
          else MVSOutputDsorg = !outputps
        if qrc\=0 | \?DDprealloc.outputp_file
          then call GetReadyForOutput outputp_file, MVSOutputDsorg
        if SYSDSORG = 'PO' then do
          parse var outputp_file outputp_file '(' outputp_mem ')'
          outputp_mem = word(outputp_mem input_mem,1)
          outputp_file = outputp_file'('outputp_mem')'
          call FileParts outputp_file, currsys
          end
        outputp_dsorg = SYSDSORG
        if outputp_dsorg = 'PO'
          then MVSOutputDsorg = !outputpo
          else MVSOutputDsorg = !outputps
        end
      else call GetReadyForOutput outputp_file, !outputps
    outputp_path = fp.!path            /* save phys output values   */
    temp         = fp.!file
    outputp_fn   = fp.!fn
    outputp_fn1  = fp.!fn1
    outputp_fn2  = fp.!fn2
    outputp_ft   = fp.!ft
    outputp_fm   = fp.!fm
    outputp_mem  = fp.!mem
    end
call DefSymbol 'b2hopall',outputp_file, 'b2hoppath',outputp_path,,
               'b2hopfile',temp
 
/*----- processing for the *logical* output file -----*/
outputl_dsorg = 'PS'
if outputl_file = ''
  then if outputp_dsorg = 'PO'
    then do
      outputl_dsorg = 'PO'
      parse var outputp_file temp '('
      outputl_file = temp'('word(outputp_mem input_mem,1)')'
      end
    else outputl_file = outputp_fn'.'htmlext
outputl_file = FileCase(outputl_file,!logical)
call FileParts outputl_file, destsys
if fp.!mem\='' & destsys=MVS then outputl_dsorg='PO'     /* !OPSYS! */
call DefSymbol 'b2holall',fp.!all, 'b2holpath',fp.!path,,
               'b2holfile',fp.!file
outputl_path = fp.!path               /* save logical output values */
outputl_fn   = fp.!fn
outputl_fn1  = fp.!fn1
outputl_fn2  = fp.!fn2
outputl_ft   = fp.!ft
outputl_fm   = fp.!fm
outputl_mem  = fp.!mem
 
/*----- do final setup -----*/
currpartl   = outputl_file
currpartnum = 1
partnamel.1 = outputl_file
partnamep.1 = outputp_file
call GetReadyForOutput temp_file, !temp
lfile = BHSplit(currpartnum+1,,outputl_file,outputl_dsorg,!logical)
call DefSymbol 'b2hhtmlid',htmldocid.htmlrel, '$LDEV','HTML'htmlrel,,
               '$FNAM',input_fn, '$fnam',input_fn, 'b2hrevchar','',,
               '$PDEV','HTML'htmlrel, '$ASCI',,
               ?pc | ( destsys\=MVS & destsys\=CMS )     /* !OPSYS! */
call DefSymbol b2hvars.1,'#'BOTname, b2hvars.5,'#'TOPname
symbol='TRUE'; sym.!dvcf.symbol = 1
 
/*----- show DEBUG info if requested -----*/
if ?debug then do
  parse source temp1; parse version temp2
  call MsgOut !info 162, 'Debug data:', ,
              'Parse Version:' temp1, 'Parse Source :' temp2
  call SaveRec !debug, 'currsys='currsys platform.currsys ||,
                     ', destsys='destsys platform.destsys
  call SaveRec !debug, 'form()='form()', fuzz()='fuzz()
  call SaveRec !debug, 'REXX type='rexximp
  if rexximp = !regina
    then call SaveRec !debug, 'uname()='uname()
  select
    when currsys = MVS then do                           /* !OPSYS! */
      end
    when currsys = CMS then do
      call Saverec !debug, 'Q CPLEVEL=' ||,
                   translate(diag(8,'QUERY CPLEVEL'),' ','15'x)
      'QUERY CMSLEVEL ( STACK'; parse pull rslt
      call Saverec !debug, 'Q CMSLEVEL='rslt
      'IDENTIFY ( STACK'; parse pull rslt
      call Saverec !debug, 'IDENTIFY='space(rslt)
      end
    when ?pc then do
      call SaveRec !debug, 'Curr Dir='directory()
      call SaveRec !debug, 'Environ Id='envid', envname='envname
      call SaveRec !debug, envname 'value='strip(value(envname,,envid))
      end
    otherwise nop
    end
  do i = 1 to saverec.!debug.0
    call MsgOut !info 162,'',saverec.!debug.i
    end
  end
 
/*----- show platform info -----*/
call MsgOut !info 100,,
    'CurrSys='platform.currsys', DestSys='platform.destsys', Input='input_file
if autosplit < 0
  then call MsgOut !info 101,,
           'PhysicalOut='outputp_file', LogicalOut='outputl_file
  else do
    pfile = BHSplit(2,,outputp_file,outputp_dsorg,!physical)
    lfile = BHSplit(2,,outputl_file,outputl_dsorg,!logical)
    call MsgOut !info 102, 'PhysicalOut='outputp_file',' pfile', ...'
    call MsgOut !info 103, 'LogicalOut='outputl_file','  lfile', ...'
    end
if ?dumpvars then call Dump_Vars 'Initialization completed'
 
 
 
 
/*------------------------------------------------------------------*/
/* Process the input file according to it's format                  */
/*------------------------------------------------------------------*/
select
 
  /*----- input is a 'flat' file -----*/
  when source = !flat then do
    totalpartnum=currpartnum; currpartnum=1
    call OpenFile outputp_file,!write,MVSalloc.MVSOutputDsorg
    call HeaderRecords
    call Copy2Output input_file,,,outputp_file,precol,blankrec,,!yes
    call FooterRecords
    if showlines \= noshowlines
      then call RecordsRead incount.input_file, input_file
    end
 
  /*----- input is a GML, Bookmaster or Script/VS document -----*/
  when source=!script | source=!scriptonly then do
 
    /*----- Pass 1 -----*/
    do i = 0 to toclimit               /* init internal symbols     */
      call DefSymbol 'b2hhead'i,''
      end
    call MsgOut !info 104,'Beginning pass 1 of 2 (processing markup) ...'
    call ReadingFile '',input_file
    call OpenFile input_file,!read,,, temp_file,!write,MVSalloc.!temp
    call WrtLine temp_file, ':BHOPT SPLITLINK='?splitlink'.'
    if ?imbedid then call WrtLine temp_file, ':BHCMT.Begin' input_file
    infilecnt = 1
    infile.1  = input_file
    buffer.   = ''
    call PassOne temp_file             /* read/process source file  */
    if pass1save \= '' then do         /* flush saved-rec buffer    */
      call Write2Temp2 pass1save
      pass1save = ''
      end
    call PrintFootNotes 1,temp_file
    if ?imbedid then call WrtLine temp_file,':BHCMT.End' input_file
    call CloseFile input_file, temp_file
    if showlines \= noshowlines then do
      call RecordsRead    incount.input_file, input_file
      call RecordsWritten outcount.temp_file, temp_file
      end
    if ?dumpvars then call Dump_Vars 'Pass 1 complete'
 
    /*----- Pass 2 -----*/
    do i = 0 to toclimit               /* init internal symbols     */
      call DefSymbol 'b2hhead'i,''
      end
    _PTOCcnt     = 0                   /* reset control values      */
    _PREcount    = 0
    totalpartnum = currpartnum
    currpartnum  = 1
    currpartl    = partnamel.1
    !!gml        = !!gml_def
    !!gml_len    = length(!!gml)
    !!egml       = !!egml_def
    !!egml_len   = length(!!egml)
    ?!!gml       = false
    i=HREFlink(toclfile,TOCname)
    call DefSymbol b2hvars.2,partnamel.2, b2hvars.3,'', b2hvars.4,i,,
                   b2hvars.6,HREFlink(indexlfile,IDXname),,
                   b2hvars.7,currpartl, b2hvars.8,i
    call DefSymbol '$GML',!!gml, '$EGML',!!egml, '$CW',!!cw
    call MsgOut !info 104,'Beginning pass 2 of 2' ,
                          '(resolving cross-references) ...'
    call OpenFile outputp_file,!write,MVSalloc.MVSOutputDsorg
    call HeaderRecords                 /* write header records      */
    call OpenFile temp_file,!read
    infilecnt = 1
    infile.1  = temp_file
    buffer.   = ''
    call PassTwo                       /* read/process work file    */
    if pass2save \= '' then do         /* flush saved-rec buffer    */
      call WrtLine outputp_file, pass2save
      pass2save = ''
      end
    call FooterRecords                 /* write footer records      */
    if showlines \= noshowlines
      then call RecordsRead incount.temp_file, temp_file
    if ?dumpvars then call Dump_Vars 'Pass 2 complete'
    end
  otherwise nop
  end
 
 
/*------------------------------------------------------------------*/
/* Input file converted, do post-processing activities              */
/*------------------------------------------------------------------*/
call CloseAnsFile
/*----- write SYSVAR W cross-reference file, if requested -----*/
if sysvarwfid\='' & xref.0>0 then do
  sysvarwfid = OutFileName(sysvarwfid,,,,dsmrefft,,currsys,!physical)
  call GetReadyForOutput sysvarwfid, !sysvarw
  call OpenFile sysvarwfid,!write,MVSalloc.!sysvarw
  do i = 1 to xref.0
    if xref.i.!local
      then call WrtLine sysvarwfid, ':BHXREF.' ||,
                 xref.i.!type    ||x01||xref.i.!counter||x01||,
                 xref.i.!file    ||x01||xref.i.!name   ||x01||,
                 xref.i.!ID      ||x01||xref.i.!IDtxt  ||x01||,
                 xref.i.!REFIDtxt||x01
    end
  call RecordsWritten outcount.sysvarwfid, "SYSVAR W file '"sysvarwfid"'"
  call CloseFile sysvarwfid
  end
 
/*----- show any remaining logical tag errors detected -----*/
if ?tagcheck then do
  if ( ?titleflag | ?libraryflag | ?topicflag )
    then call MsgOut ?prcnoendtag 412,'Missing :ETITLE. or :ETITLEP. tag!'
  do while tagnest \== ''                /* any "end" tags missing?   */
    parse var tagnest (x00) tntag (x00) tagnest
    do tni = 1 to tagnest.tntag.0
      call MsgOut !warning 411, ,
                  tntag '(in line' tagnest.tntag.tni') never ended!'
      end
    end
  if ?index & \?indexfnd               /* index rqstd, but not fnd? */
    then call MsgOut ?prcnoindex 115,,
                     'INDEX requested, but :INDEX. tag not found!'
  if GoToLabel.infilecnt \= ''
    then call MsgOut !error 460,'Label "'GoToLabel.infilecnt'" not found!', ,
                '(".GO' GoToLabel.infilecnt'" in line' GoToLine.infilecnt')'
  end
?normalcomplete = 1                    /* this a normal completion  */
 
/*------------------------------------------------------------------*/
/* Program ending, do physical cleanup                              */
/*------------------------------------------------------------------*/
Exit_Program:
signal off syntax
signal off novalue
signal off halt
if ?dumpvars then call Dump_Vars 'Exiting program'
if ?trace2disk then do;
  parse value false with ?trcany 1 ?trcio 1 ?trcparse 1 ?trcpgm 1 ?trace2disk
  if ?traceisopen then call CloseFile tracefile
  if outcount.tracefile > 0
    then call RecordsWritten outcount.tracefile,tracefile
  end
if ?normalcomplete
  then call MsgOut !info 106,,
            'Conversion completed in' format(time('E'),,2) 'seconds'
if logfile \= ''
  then call RecordsWritten outcount.logfile + logrecs.0 + 2,logfile
call MsgOut !info 107,'Highest RC='quit_rc
if logfile\='' & \?LogIsOpen & logrecs.0>0 then do
  if logstream = '' then do            /* log to a disk file?       */
    if \?logappend then call GetReadyForOutput logfile, !log
    call OpenFile logfile,!write,MVSalloc.!log,word('OLD MOD',?logappend+1)
    end
  ?LogIsOpen=true
  do i = 1 to logrecs.0                /* write any queued log recs */
    call WriteLog logrecs.i
    end
  end
call CloseFile input_file, temp_file, outputp_file, ansfilep
if logstream='' & logfile\='' then call CloseFile logfile
if \?noerase then call EraseFile temp_file
exit quit_rc
 
 
 
 
/********************************************************************/
/*                 S  U  B  R  O  U  T  I  N  E  S                  */
/********************************************************************/
 
/*== Pass One: ========================================*/
/* o  Read the input file                              */
/* o  Handle any .*B2H statements                      */
/* o  Do most '&' symbol substitution                  */
/* o  Handle all commands, macros & tags except cross- */
/*    references types (e.g. :TOC, :HDREF, :FIGREF...) */
/*=====================================================*/
PassOne: rtn='PASSONE'; trace value tracelist.rtn
parse arg pass1out
if ?trcparse | ?trcpgm then call Here1 rtn,pass1out,sigl,!parse
pass       = 1
indexcnt   = 0
pass1save  = ''
i          = infile.infilecnt
pass1incnt = incount.i
 
do pass1loop = 1 by 1                  /* read all the source recs  */
  parse value Get_Buffer(1) with 1 ?passeof 2 ?physread 3 currline
  if ?passeof then leave pass1loop     /* quit if EOF detected      */
  if ?trcparse then call Trc 'Pass 1 loop: currline="'currline'"'
  if currline == '' then do            /* if null, make it a blank  */
    currline = ' '
    if ?trcparse then call Trc '(reset, currline="'currline'")'
    end
 
  /*----------------------------------------------------------------*/
  /* Handle records that start with ".*".  If a B2H control record, */
  /* process it, otherwise ignore the record.                       */
  /*----------------------------------------------------------------*/
  if left(currline,2) = '.*' then do   /* a comment-type record?    */
    if substr(currline,3,1) == ' '     /* "pure" comment record?    */
      then iterate pass1loop           /*   yes, ignore it          */
    if ?OKtoUse then do                /* process further if OK     */
      if ?dm then do                   /* currently saving a macro? */
        call SaveMacroRec currline     /*   yes, save record only   */
        iterate pass1loop
        end
      /*----- handle if converter control record (.*B2H) -----*/
      ?b2hfound = ( translate(word(currline,1)) = '.*B2H' )
      if ?b2hreq & \?b2hfound then iterate pass1loop
      if \?b2hfound                    /* what format is record?    */
        then parse var currline 3 word1 remainder /* .*type ...     */
        else do                                   /* .*B2H type ... */
          remainder = subword(currline,2)
          if left(remainder,1) = '(' then do  /* system-specific?   */
            parse var remainder '(' b2env ')' remainder /* yes      */
            if \UseOnPlatform(b2env) then iterate pass1loop
            end
          parse var remainder word1 remainder
          end
      word1=translate(word1); remainder=strip(remainder)
      select
        when word1='SPLIT' | word1='BREAK' then do
          parse var remainder b2hpfile ',' b2hlfile
          call Put_Buffer ,
              ':BHSPLIT PF='b2hdelim||strip(b2hpfile)||b2hdelim,
                       'LF='b2hdelim||strip(b2hlfile)||b2hdelim'.',!lifo
          end
        when word1 = 'HTML' then do
          if _li > 0 then _li = _li + 1  /* override literal mode   */
          call Write2Temp2 remainder
          end
        when word1 = 'MSG' then do
          parse var remainder temp1 ',' temp2
          call MsgOut translate(temp1), strip(SymbSub(temp2))
          end
        when word1 = 'OPTION' then do
          call MsgOut !info 108,'Setting options using',space(currline),!recnum
          if infile.infilecnt \= input_file |,
             incount.input_file > prereadnum then do
            call SetOpts remainder,1,1,1
            call SetOpts_GlobalCheck
            end
          end
        when word1 = 'SYMBOL' then do
          call MsgOut !info 109,'Setting symbol table entry using', ,
                      space(currline),!recnum
          if SetSyms(remainder) > 0      /* process the statement     */
            then call MsgOut ?prcunksym 152, 'Unknown symbol table statement!'
          end
        when word1 = 'REXX' then interpret remainder
        otherwise nop
        end
      end
    iterate pass1loop
    end
 
  /*----------------------------------------------------------------*/
  /* Scan for "." and handle control words and macros.              */
  /* Split lines at each continuation (if appropriate)              */
  /*----------------------------------------------------------------*/
  select
    /*----- don't do anything if in Bookie literal mode -----*/
    when ?litdata then nop
    /*----- handle record using SOURCE=SCRIPTONLY rules if -----*/
    /*      record physically read and not in DCF literal mode  */
    when source=!scriptonly & ?physread & _li=0 then do
      saveline = ''
      if _PREcount = 0                 /* treat blank line as .bl   */
        then if currline = ''          /*   if not within <PRE>     */
          then currline = '.bl'
      do forever while currline \= ''  /* handle each logical stmt  */
        templine = ''
        if left(currline,2) \== ".'" then do  /* modifier found?    */
          semipos = pos(!!cw,currline)        /*  no, split record  */
          if semipos > 0 then do              /*      if char found */
            templine = substr(currline,semipos+!!cw_len)
            currline = left(currline,semipos-1)
            end
          end
        if left(currline,1) == '.'     /* a control word here?      */
          then do while left(currline,1) == '.' /* yes, handle it   */
            currline = CommandMacro(currline)
            end
          else if ?dm then do          /* no, macro being defined?  */
            if ?OKtoUse                /*     yes, OK to use rec?   */
              then call SaveMacroRec currline   /* yes, save rec    */
            currline = ''
            end
        saveline = saveline || currline
        currline = templine
        end
      currline = saveline
      if currline == '' then iterate pass1loop
      if left(currline,1) = ' '
        then currline = '<BR>'currline
      end
    /*----- handle control words using SOURCE=SCRIPT rules -----*/
    /*      (only split line if first item is a control word)   */
    otherwise do
      if _PREcount = 0                 /* treat blank line as .bl   */
        then if currline = ''          /*   if not within <PRE>     */
          then currline = '.bl'
      if left(currline,1) = '.' then do
        semipos = pos(!!cw,currline)
        if semipos>0 & _li=0 & substr(currline,2,1)\=="'" then do
          call Put_Buffer substr(currline,semipos+!!cw_len), !lifo
          currline = left(currline,semipos-1)
          end
        call Put_Buffer CommandMacro(currline), !lifo
        iterate pass1loop
        end
      end
    end
 
  /*----- do following if not in Bookie literal mode ----*/
  if \?litdata then do
    if ?dm & _li=0            /* in a macro def & not literal mode? */
      then if source\=!scriptonly then do  /* yes, save record      */
        if ?OKtoUse then call SaveMacroRec currline
        iterate pass1loop
        end
    currline = SymbSub(currline)       /* do &symbol substitution   */
 
    /*--------------------------------------------------------------*/
    /* Record done if in DCF literal mode                           */
    /*--------------------------------------------------------------*/
    if _li \= 0 then do
      if currline = ' ' then currline = '<P>'
      call Write2Temp2 currline
      iterate pass1loop
      end
    end
 
  /*----------------------------------------------------------------*/
  /* Scan the line looking for, and processing, the :tags.          */
  /* When all tags have been handled (if any), write out result.    */
  /*----------------------------------------------------------------*/
  scanstart=1
  do ss1 = 1 by 1
    gmlpos = NextTag(currline,scanstart)  /* look for the next tag  */
    select
      when gmlpos = 0 then do             /* was a tag found?       */
        if \?OKtoUse                      /*  no, remove text if    */
          then currline = left(currline,scanstart-1)  /* ignoring   */
        currline2 = currline
        if _PREcount>0 & currline2\=''
          then do while pos('<',currline2) > 0
            parse value currline2 with cur2l '<' . '>' cur2r
            currline2 = cur2l cur2r
            end
          else currline2 = '*'
        if currline2 = ''
          then pass1save = pass1save || currline
          else do; call Write2Temp2 pass1save||currline; pass1save=''; end
        iterate pass1loop
        end
      /* Ignore leading blanks in syntax diagram mode */
      when ?syntaxflag & left(currline,gmlpos-1) = ''
        then currline = substr(currline,gmlpos)
      when gmlpos > 1 then do          /* any text prior to tag?    */
        if ?OKtoUse                    /*   yes, can it be used?    */
          then call Push_Stack left(currline,gmlpos-1)     /* yes   */
          else call Push_Stack left(currline,scanstart-1)  /* no    */
        currline = substr(currline,gmlpos) /* remove prefix text    */
        end
      otherwise nop
      end
    /*----- process the tag and insert into the data string ----*/
    call GetTagParts currline          /* build "TAGxxx" variables  */
    proctag.0 = 0
    datastr   = ProcessTag1(pass1out)  /* process the :tag          */
    saveline  = ''
    stackline = Get_Stack()            /* save any stacked lines    */
    do while stackline \== ''
      saveline  = saveline || stackline
      stackline = Get_Stack()
      end
    if proctag.0 = 0                   /* anything in work array?   */
      then do                          /*   no, append returned     */
        currline = saveline || datastr /*       data and find where */
        scanstart = length(saveline)+2-?rescan /* to restart scan   */
        end
      else do                          /*   yes, handle it          */
        if saveline \== ''             /* anything queued?          */
          then if ?OKtoUse             /*   yes, allowing text now? */
            then proctag.1 = saveline || proctag.1 /* yes, use it   */
            else call Write2Temp2 saveline         /*  no, save it  */
        do k = 1 to proctag.0          /* get work records          */
          if ?OKtoUse
            then if proctagf.k         /* "FORCE" specified here?   */
              then call WrtLine pass1out,SymbSub(proctag.k)
              else call Write2Temp2 proctag.k
          end k
        currline  = datastr            /* restart scan with only    */
        scanstart = 1                  /*   the returned data       */
        end
    /*----- if rescan starts at col 1, check for everything -----*/
    if scanstart = 1 then do
      if currline \== '' then call Put_Buffer currline, !lifo
      iterate pass1loop
      end
    end ss1
  end pass1loop
 
if ?trcparse | ?trcpgm then call Here2
return
 
 
/*== Pass Two: ===================================*/
/* o  Copy any header file records to output file */
/* o  Build TOC/PTOC(s)/INDEX if requested        */
/* o  Resolve all cross-references                */
/* o  Copy footer file records to output file     */
/*================================================*/
PassTwo: rtn='PASSTWO'; trace value tracelist.rtn
if ?trcparse | ?trcpgm then call Here1 rtn,,sigl,!parse
pass      = 2
indexcnt  = 0
pass2save = ''
 
do pass2loop = 1 by 1
  parse value Get_Buffer(1) with 1 ?passeof 2 ?physread 3 currline
  if ?passeof then leave pass2loop
  if ?trcparse then call Trc 'Pass 2 loop: currline="'currline'"'
  currline = SymbSub(currline)
  /*----- process the record -----*/
  scanstart = 1
  do ss2 = 1 by 1
    gmlpos = NextTag(currline,scanstart) /* look for next :tag      */
    select
      when gmlpos = 0 then do            /* was a tag found?        */
        if currline \== omitrecord &,    /*   no, write record if   */
           currline \== '' then do       /*       not blank and     */
          currline2 = currline           /*       not ignored       */
          if _PREcount>0 & currline2\=''
            then do while pos('<',currline2) < pos('>',currline2)
              parse value currline2 with cur2l '<' . '>' cur2r
              currline2 = cur2l cur2r
              end
            else currline2 = '*'
          if currline2 = ''
            then pass2save = pass2save || currline
            else do;
              call WrtLine outputp_file, pass2save||currline
              pass2save = ''
              end
          end
        iterate pass2loop
        end
      when gmlpos > 1 then do          /* any text prior to tag?    */
        call Push_Stack left(currline,gmlpos-1) /* yes, save and    */
        currline = substr(currline,gmlpos)      /*     remove it    */
        end
      otherwise nop
      end
    /*----- process the :tag and insert into the data string ----*/
    call GetTagParts currline          /* build "TAGxxx" variables  */
    datastr   = ProcessTag2()          /* process the :tag          */
    saveline  = ''
    stackline = Get_Stack()            /* save any stacked lines    */
    do while stackline \== ''
      saveline  = saveline || stackline
      stackline = Get_Stack()
      end
    currline = saveline || datastr     /* save data and find where  */
    scanstart = length(saveline)+2-?rescan /* to restart scan       */
    end ss2
  end pass2loop
if ?trcparse | ?trcpgm then call Here2
return
 
 
/*------------------------------------------------------------------*/
/* Set_OKtoUse: Set "?OKtoUse"   1=Use record, 0=Ignore record      */
/* Usage:       call Set_OKtoUse                                    */
/*------------------------------------------------------------------*/
Set_OKtoUse:
  ?OKtoUse = \( _ignore\=0 | ?pscflag | \?config.configcnt | ,
                GoToLabel.infilecnt\=='' )
  return
 
/*------------------------------------------------------------------*/
/* Push_Stack:   call Push_Stack record-to-save                     */
/* Get_Stack:    record = Get_Stack()         EOF if record==''     */
/* Stack2Write2: call Stack2Write2            Write stack logically */
/* SaveMacroRec: call SaveMacroRec record     Save a macro record   */
/*------------------------------------------------------------------*/
Push_Stack:
  psrecord = arg(1)
  if psrecord \== ''
    then psstack = psstack || psrecord || nl
  return
 
Get_Stack:
  parse var psstack psrecord (nl) psstack
  return psrecord
 
Stack2Write2:
  do forever
    s2rec = Get_Stack()
    if s2rec == '' then leave
    call Write2Temp2 s2rec
    end
  return
 
SaveMacroRec:
 smi              = macro.dmname.0 + 1
 macro.dmname.0   = smi
 macro.dmname.smi = arg(1)
 return
 
/*------------------------------------------------------------------*/
/* PUT_BUFFER:  Place a record into the input buffer (dflt=FIFO)    */
/* Usage:       call Put_Buffer record-to-save <,{FIFO|LIFO}>       */
/*------------------------------------------------------------------*/
Put_Buffer: rtn='PUT_BUFFER'; trace value tracelist.rtn
  pbrecord = arg(1)
  if ?trcparse then do
    call Here1 rtn,pbrecord','arg(2),sigl,!parse
    call Trc 'At entry: buffer.'infilecnt'='buffer.infilecnt
    end
  if pbrecord \== ''
    then if arg(2) = !lifo
      then buffer.infilecnt = pbrecord || nl || buffer.infilecnt
      else buffer.infilecnt = buffer.infilecnt || pbrecord || nl
  if ?trcparse then do
    call Trc 'At exit: buffer.'infilecnt'='buffer.infilecnt
    call Here2
    end
  return
 
/*------------------------------------------------------------------*/
/* GET_BUFFER: Get a source input record, either from the in-store  */
/*             buffer or from the current input file                */
/* Usage:  parse value Get_Buffer(0|1) with 1 eof 2 phys 3 record   */
/*          0|1    - Update "source_id" with filename & record cnt? */
/*          eof    - End-of-file reached? 1/true=yes, 0/false=no    */
/*                   If true, no record is returned & "phys=1"      */
/*          phys   - Record retrieved how? 1=physical read, 0=buffer*/
/*------------------------------------------------------------------*/
Get_Buffer: rtn='GET_BUFFER'; trace value tracelist.rtn
if ?trcparse then do
  call Here1 rtn,arg(1),sigl,!parse
  call Trc 'At entry: buffer.'infilecnt'='buffer.infilecnt
  end
parse arg ?gbsave
pbsave = ''
do gbi = 1 by 1
  if buffer.infilecnt \== ''           /* anything in the buffer?   */
    /*----- record waiting in the buffer, use it -----*/
    then parse value false false buffer.infilecnt,
               with  ?pbeof ?pbphys pbrecord (nl) buffer.infilecnt
    /*----- buffer empty, physically read the current input file ---*/
    else do
      if infilecnt >= infile.0         /* forcing EOF?              */
        then do                        /*   no, read the file       */
          parse value RdLine(infile.infilecnt) with 1 ?pbeof 2 pbrecord
          if \?pbeof                   /* EOF reached?              */
            then if source=!scriptonly & pass=1  /* no, use record  */
              then pbrecord = Xlate(pbrecord,':','&colon.')
              else if ?!!gml then do   /* process if .DC GML changed*/
                if translate(left(pbrecord,4)) \== '.DC '
                  then pbrecord = Xlate(pbrecord,':','&colon.')
                if !!gml\=!!gml_def & !!gml\=xFE
                  then pbrecord = Xlate(pbrecord,!!gml,':',1)
                if !!egml \= !!egml_def & !!egml\=xFE
                  then pbrecord = Xlate(pbrecord,!!egml,':E',1)
                end
          if infilecnt > 1 then do     /* reading an imbed file?    */
            gbj        = infile.infilecnt  /* yes, reset counter    */
            bypass.gbj = 0
            end
          end
        else parse value true with ?pbeof pbrecord /* yes, show EOF */
      if gbi=1 & ?gbsave
        then source_id_orig.infilecnt = source_id.infilecnt
      ?pbphys  = true
      infile.0 = infilecnt
      if pass = 1
        then if ?ltgt
          then if left(pbrecord,1) \= '.' then do
            pbrecord = XLate(pbrecord,'<','&lt;')
            pbrecord = XLate(pbrecord,'>','&gt;')
            end
      if ?pbeof                        /* EOF reached?              */
        then if infilecnt > 1 then do  /*  yes, this an imbed file? */
          call Closefile infile.infilecnt  /*  yes, close it out    */
          if GoToLabel.infilecnt \= '' then call MsgOut !error 460, ,
               'Label "'GoToLabel.infilecnt'" not found!', ,
               '(".GO' GoToLabel.infilecnt'" in line' GoToLine.infilecnt')'
          call Stack2Write2
          infilecnt = infilecnt - 1    /* resume prev file          */
          infile.0  = infilecnt
          call Set_OKtoUse
          if ?imbedid then do
            ifx = infilecnt + 1
            call Put_Buffer ':BHCMT.End' infile.ifx,
                            '(resuming' infile.infilecnt')',!lifo
            end
          gbi = 0
          iterate gbi                  /* redo loop as if 1st time  */
          end
      end
  pbrecord = strip(pbrecord,'T')       /* dump any trailing blanks  */
  /*----- handle logical continuation            -----*/
  /*----- &cont/&cont./&$cont/&$cont. (any case) -----*/
  pbtemp = reverse(strip(pbrecord,'T'))
  if left(pbtemp,1) == "."
    then parse var pbtemp 2 pbcheck5 7 pbrest6 2 pbcheck6 8 pbrest7
    else parse var pbtemp 1 pbcheck5 6 pbrest6 1 pbcheck6 7 pbrest7
  pbcheck5 = translate(pbcheck5)
  pbcheck6 = translate(pbcheck6)
  select
    when ?pbeof then pbrecord = pbsave || pbrecord
    when pbcheck5 == 'TNOC&' then do                    /* &CONT?   */
      pbsave = pbsave || reverse(pbrest6)
      iterate gbi
      end
    when translate(pbcheck6) == 'TNOC$&' then do        /* &$CONT?  */
      pbsave = pbsave || reverse(pbrest7)
      iterate gbi
      end
    otherwise pbrecord = pbsave || pbrecord
    end
  leave gbi
  end gbi
if pbrecord == '' then pbrecord = ' '
if ?trcparse then do
  call Trc 'At exit: buffer.'infilecnt'='buffer.infilecnt
  call Here2 ?pbeof || ?pbphys || pbrecord
  end
return ?pbeof || ?pbphys || pbrecord
 
 
 
/*------------------------------------------------------------------*/
/* CommandMacro:  Handle a Script control word or GML/Bookie macro. */
/*                Any output records are written to the temp file   */
/*                by this routine itself.  Any string returned to   */
/*                the caller is 'requeued' for further processing.  */
/* Usage:  data-to-requeue = CommandMacro(string)                   */
/*------------------------------------------------------------------*/
CommandMacro: rtn='COMMANDMACRO'; trace value tracelist.rtn
parse arg commandmacro
if ?trcparse then call Here1 rtn,commandmacro,sigl,!parse
parse var commandmacro cmditself . 1 '.' parmstring
datastr = ''                           /* no data to write yet      */
do cmloop = 1 by 1
  if left(parmstring,1) = "'"          /* this in .'macro format?   */
    then parmstring = substr(parmstring,2)    /* yes, remove quote  */
  parse upper var parmstring word1 word2 word3 word4 word5 .
  parse       var parmstring . cmdremainder
  cmdremainder = strip(cmdremainder)
  cword = '.'word1                     /* actual control word       */
 
  /*----- see if literal mode itself should be turned on/off -----*/
  if word1 == 'LI' then do                  /*----- .LI        -----*/
    call Stack2Write2
    select
      when word2 = 'ON'  then _li = -1
      when word2 = 'OFF' then _li = 0
      when datatype(word2,'W') & word3='' then _li = word2
      when word2 = '' then _li = 1
      otherwise do; datastr=cmdremainder; _li=1; end
      end
    leave cmloop
    end
 
  /*----- if in literal mode, write record as-is -----*/
  if _li \= 0 then do
    call Write2Temp2 commandmacro
    leave cmloop
    end
 
  /*----- if symbol defined, then if IGNOREx, ignore it, -----*/
  /*----- else process definition and return to caller   -----*/
  temp = ''
  if ?tableflag
    then if htmlrel=2
      then temp = sym.!dottbl.word1
  if temp = '=NO' then do
    call MsgOut !warning 434,'"'cmditself'" not supported in a table',,
                commandmacro,!recnum
    leave cmloop
    end
  if temp == '' then temp = sym.!dot.word1
  if word1=='SK' | word1=='SP' then temp=''
  /*----- process a symbol table definition for this markup -----*/
  if temp \== '' then do
    parse var temp temp1 temp2 tempx
    select
      /*----- handle IGNORE-type definitions -----*/
      when temp=!ignore  | temp=!ignoreall  then leave cmloop
      /*----- handle IGNOREW-type definitions -----*/
      when temp=!ignorew | temp=!ignoreallw then do
        call MsgOut !warning 485, ,
             '"'cmditself'"' ignorewmsg,commandmacro,!recnum
        leave cmloop
        end
      /*----- invoke a user program/exit -----*/
      when translate(temp1) = !userpgm then do
        call Stack2Write2
        cmdremainder = SymbSub(cmdremainder)
        oldq = queued()
        interpret 'templine='temp2'("CMD",temp2,tempx,cmdremainder)'
        do while templine \= ''     /* retrieve line(s) from result */
          parse var templine line (nl) templine
          call Put_Buffer line
          end
        do queued() - oldq
          parse pull line           /* retrieve line(s) from stack  */
          call Put_Buffer line
          end
        leave cmloop
        end
      /*----- do &TEXT and &TEXTALL substitution -----*/
      when temp \== '' then do forever
        uctemp = translate(temp)
        i = pos('&TEXT',uctemp); k=5
        if i = 0 then do; i=pos('&TEXTALL',uctemp); k=8; end
        if i = 0
          then datastr = temp
          else do
            temp = left(temp,i-1) || cmdremainder || substr(temp,i+k)
            iterate
            end
        leave cmloop
        end
      otherwise nop
      end
    end
 
  /*----- control words that cause text to be handled/ignored  -----*/
  /*----- (only check if not within a macro definition)        -----*/
  if \?dm then do
    ?handled = false
    select
      when left(word1,2) == '..' then do    /*----- ...label   -----*/
        ?handled = true
        parse var parmstring '..' temp datastr
        temp = strip(temp)
        ?labelfnd.infilecnt.temp = true
        labels.infilecnt = labels.infilecnt temp
        if temp = GoToLabel.infilecnt then do /*seeking this label? */
          GoToLabel.infilecnt = ''     /*   yes, resume processing  */
          GoToLine.infilecnt  = ''
          end
        end
 
      when word1 == 'CONFIG' then do        /*----- .CONFIG    -----*/
        ?handled = true
        parse upper var cmdremainder conname cononoff .
        if cononoff \= 'ON' then cononoff = 'OFF'
        if cononoff = 'ON'
          then do
            ifi               = configcnt
            configcnt         = configcnt + 1
            ?config.configcnt = ?config.ifi
            confignames = conname confignames
            end
          else if conname \= word(confignames,1)
            then call MsgOut !error 418, ,
                      'Out-of-sequence .CONFIG', commandmacro
            else do
              configcnt = max(0,configcnt-1)
              confignames = subword(confignames,2)
              end
        end
 
      when word1 == 'CS' then do            /*----- .CS        -----*/
        ?handled = true
        if \datatype(word2,'W') then word2 = 0
        select
          when word3='INCLUDE' then ?cs.word2 = true
          when word3='IGNORE'  then ?cs.word2 = false
          when word3='ON'  then if \?cs.word2 then _ignore=_ignore+1
          when word3='OFF' then if \?cs.word2 then _ignore=max(0,_ignore-1)
          otherwise call SyntaxErr commandmacro
          end
        end
 
      when word1=='RF' | word1=='RH' then do /*----- .RF/.RH   -----*/
        ?handled = true
        if word2='ODD' | word2='EVEN' then word2 = word3
        if word2 = '' then word2 = 'ON'
        select
          when word2 = 'ON' then do; _ignore = _ignore + 1
            if ?tagcheck then call TagNestS cword,commandmacro,!nonest
            end
          when word2 = 'OFF' then do; _ignore = max(0, _ignore - 1 )
            if ?tagcheck then call TagNestE cword,commandmacro
            end
          otherwise nop
          end
        end
 
      when word1 = 'WHEN' then do           /*----- .WHEN      -----*/
        ?handled = true
        parse upper var cmdremainder "'" constring "'" coninsdel .
        if constring = '' then do      /* condition within quotes?  */
          ifi = words(cmdremainder)    /*   no, last word is action */
          constring=subword(cmdremainder,1,ifi-1)
          coninsdel=word(cmdremainder,ifi)
          end
        if coninsdel \= 'INSERT' then coninsdel = 'DELETE'
        ifi = max(0,configcnt-1)
        ifj = condExpr(constring); if coninsdel='DELETE' then ifj = \ifj
        if ?config.ifi then ?config.configcnt = ifj
        end
 
      otherwise nop
      end
 
    if ?handled then do; call Set_OKtoUse; leave cmloop; end
    if \?OKtoUse then leave cmloop
    end
 
  /*----- if defining a macro, just save the data -----*/
  if word1 == 'DM' then do                  /*----- .DM        -----*/
    call Stack2Write2
    select
      when word3='ON' then do
        dmname=word2; macro.dmname.0=0; ?dm=true
        if ?tagcheck then call TagNestS cword,commandmacro,!nonest
        end
      when word2='OFF' | word3='OFF' then do
        ?dm=false; if ?tagcheck then call TagNestE cword,commandmacro
        end
      otherwise if left(word3,1) = '/' then do
        dmname=word2; macro.dmname.0=0; string=substr(subword(currline,3),2)
        do while string \= ''
          parse var string atom '/' string; call SaveMacroRec atom
          end
        end
      end
    leave cmloop
    end
  /*----- if macro definition in progress, just save the record ----*/
  if ?dm then do
    call SaveMacroRec currline
    leave cmloop
    end
 
  /*----- If I got here, there's a control word to handle -----*/
  select
    when word1=='AN' | word1='AND' then do  /*----- .AN/.AND   -----*/
      parse var cmdremainder comp1 compif comp2 cmdremainder
      ?IFcondx = ?IFcondx & Eval_Expression(comp1,compif,comp2,cword)
      if ?IFcondx & cmdremainder\=''
        then call Put_Buffer strip(cmdremainder), !lifo
      end
 
    when word1 == 'BF' then do              /*----- .BF        -----*/
      parse upper var cmdremainder fname .; datastr=font.fname
      fontnest=fontnest+1; fontname.fontnest=fname
      ?fontprop.fontnest = fontprop.fname
      end
 
    when word1 == 'PF' then do              /*----- .PF        -----*/
      fname=fontname.fontnest; datastr=efont.fname
      fontnest=max(0,fontnest-1)
      end
 
    when word1 == 'CE' then do              /*----- .CE        -----*/
      call Stack2Write2
      select
        when word2 = 'ON'  then _ce = -1
        when word2 = 'OFF' then _ce = 0
        when datatype(word2,'W') & word3='' then _ce = word2
        when word2 = '' then _ce = 1
        otherwise do; datastr=cmdremainder; _ce=1; end
        end
      end
 
    when word1 == 'DC' then select          /*----- .DC        -----*/
      when word2 == 'CW' then do
        if word3 = 'OFF'
          then !!cw=''; else !!cw=HexChar(word3,commandmacro);
        !!cw_len=length(!!cw); call DefSymbol '$CW',!!cw
        end
      when word2 == 'GML' then do
        select
          when word3 = 'OFF' then do; !!gml=xFE; !!egml=xFE; end
          when word3='' | word4='' then do
            call SyntaxErr commandmacro
            !!gml=!!gml_def; !!egml=!!egml_def
            end
          otherwise do
            word3=HexChar(word3,commandmacro); word4=HexChar(word4,commandmacro)
            if word5\='' then word5=HexChar(word5,commandmacro)
            !!gml=word3; !!egml=word4||word5
            end
          end
        !!gml_len=length(!!gml); !!egml_len=length(!!egml)
        ?!!gml = (!!gml\=!!gml_def) | (!!egml\=!!egml_def)
        call DefSymbol '$GML',!!gml, '$EGML',!!egml
        end
      otherwise nop
      end
 
    when word1 == 'DD' then do              /*----- .DD        -----*/
      parse var cmdremainder nfname ddrem
      ddrem=translate(ddrem); ddw1=word(ddrem,1)
      select
        when ddw1='LIB' then ddrem=subword(ddrem,2)
        when ddw1='TERM'then leave cmloop
        otherwise nop
        end
      ddrem1=left(ddrem,1); if1=''; parse var ddrem ddw1 ddw2 ddw3 .
      select
        when currsys = CMS then do                       /* !OPSYS! */
          select
            when ddrem1='(' then parse var ddrem '(' if1 if2 ')'
            when ddrem1="'" then parse var ddrem "'" if1 if2 "'"
            when ddrem1='"' then parse var ddrem '"' if1 if2 '"'
            otherwise parse var ddrem if1 if2 .
            end
          if1 = if1 if2
          end
        when currsys = MVS then select                   /* !OPSYS! */
          when ddw1 = 'DD'
            then if Do_ListDSI(ddw2 'FILE') = 0
              then do;if1=SYSDSNAME;DDname.if1=ddw2;?DDprealloc.if1=1;end
              else call MsgOut !error 461,'DD "'ddw2'" not pre-allocated',,
                        commandmacro,!recnum
          when ddw1 = 'DSN' then do
            dddsn=subword(ddrem,2); dddsn1=left(dddsn,1)
            select
              when dddsn1="'" then parse var dddsn "'" dddsn "'"
              when dddsn1="(" then do
                parse var dddsn "(" dddsn ")"; dddsn=tsoprefix||dddsn
                end
              otherwise dddsn = tsoprefix || word(dddsn,1)
              end
            if1 = space(dddsn,0)
            end
          otherwise if1=ImbedMemberDsn(ddw1)          /* LIB option */
          end
        otherwise if1 = ''                               /* !OPSYS! */
        end
      sym.!namefile.nfname = if1
      end
 
    when word1 == 'DV' then do              /*----- .DV        -----*/
      parse var cmdremainder esname estext
      do forever
        esword = translate(word(estext,1))
        if esword='BASELINE' then do;estext=subword(estext,3);iterate;end
        if esword='FONT'     then do;estext=subword(estext,3);iterate;end
        if esword='TEXT'     then do;estext=subword(estext,2);iterate;end
        leave
        end
      parse value strip(estext) with 1 esdelim 2 estext (esdelim)
      call DefSymbol SymbSub(esname), SymbSub(estext)
      end
 
    when word1 == 'EF' then do              /*----- .EF        -----*/
      if1 = infile.infilecnt
      if word2 = 'CLOSE' then bypass.if1=0; else bypass.if1=incount.if1
      infile.0 = infile.0 + 1
      end
 
    when word1=='EL' | word1='ELSE'         /*----- .EL/.ELSE  -----*/
      then if \?IFcondx then call Put_Buffer strip(cmdremainder), !lifo
 
    when word1 == 'FN' then select          /*----- .FN        -----*/
      when word2='ON'     then datastr=':FN.'
      when word2='OFF'    then datastr=':EFN.'
      when word2='LEADER' then datastr='<P>----------------<P>'
      otherwise nop
      end
 
    when word1 == 'FO' then do              /*----- .FO        -----*/
      call Stack2Write2
      select                           /* close prev .FO (if any)   */
        when fosave = 'CENTER' then datastr = '</CENTER>'
        when fosave = 'OFF'    then datastr = EPre()
        otherwise nop
        end
      if datastr\='' then do; call Write2Temp2 datastr; datastr=''; end
      select                           /* handle new .FO            */
        when word2 = 'OFF'    then datastr = Pre()
        when word2 = 'CENTER' then datastr='<CENTER>'
        otherwise if _PREcount > 0 then datastr = EPre()
        end
      fosave = word2
      end
 
    when word1 == 'GETW' then do            /*----- .GETW      -----*/
      call EvalTag cmdremainder; symbol=GetAttr('SYMBOL')
      call DefSymbol symbol, length(GetAttr('TEXT')) + 1
      end
 
    when word1=='GO' | word1='GOTO' then do /*----- .GO/.GOTO  -----*/
      if word1='GO' & word2='TO'
        then cmdremainder = subword(cmdremainder,2)
      label = SymbSub(word(cmdremainder,1))
      if ?labelfnd.infilecnt.label
        then do                        /* error if backward branch  */
          call MsgOut !warning 459,'"Backward GoTo" not supported',,
                      commandmacro,!recnum
          leave cmloop
          end
        else do
          x = source_id.infilecnt
          GoToLine.infilecnt = word(x,1) 'of' subword(x,2)
          call Stack2Write2; GoToLabel.infilecnt=label; call Set_OKtoUse
          end
      end
 
    when word1 == 'IF' then do              /*----- .IF        -----*/
      parse var cmdremainder comp1 compif comp2 cmdremainder
      ?IFcondx = Eval_Expression(comp1,compif,comp2,cword)
      if ( ?IFcondx & cmdremainder\='' ) |,
         ( \?IFcondx & translate(word(cmdremainder,1))='.OR' )
        then call Put_Buffer strip(cmdremainder), !lifo
      end
 
    when word1 == 'IM' then do              /*----- .IM        -----*/
      parse var cmdremainder cmdremainder (!!cw)
      if left(word(cmdremainder,1),1) = '('
        then parse var cmdremainder '(' ifi ')'
        else ifi = word(cmdremainder,1)
      ifi = subword(SymbSub(ifi),1,2)
      if words(ifi)=1 & ifi=cmdremainder
        then if sym.!namefile.ifi \= ''
          then ifi = sym.!namefile.ifi
      if translate(left(ifi,6))='XEDITG' & ?xeditgchk
        then do
          datastr = word('<PRE> </PRE>', ?xeditg+1)
          ?xeditg = \?xeditg
          end
        else do
          call ImbedFile ifi,commandmacro,!recnum
          if ?autoimbed then call Put_Buffer '.*B2H SPLIT'
          end
      end
 
    when word1 == 'INWIDTH' then do         /*----- .INWIDTH   -----*/
      parse upper var cmdremainder onoff cmdremainder
      if wordpos(word(cmdremainder,1),gmltypes) > 0
        then parse var cmdremainder . cmdremainder
      parse value GetValue(cmdremainder) with text (nl)
      if onoff = 'ON'
        then inwidth = inwidth + length(text)
        else inwidth = max(inwidth - length(text),0)
      end
 
    when word1 == 'LB'                      /*----- .LB        -----*/
      then datastr = '<BR>'cmdremainder
 
    when word1 == 'MG' then do              /*----- .MG        -----*/
      parse value strip(cmdremainder) with 1 _ 2 code (_) message (_)
      call MsgOut !info 481,'+++'code message
      end
 
    when word1 == 'NAMECTR' then select     /*----- .NAMECTR   -----*/
      when abbrev('DEFINE',word2,1) | abbrev('RESET',word2,1) then do
        call EvalTag cmdremainder
        symbol=GetAttr('SYMBOL'); initval=GetAttr('INITVAL')
        if \datatype(initval,'W') then initval = 1
        call DefSymbol symbol, initval
        end
      when abbrev('INCREMENT',word2,1) then do
        call EvalTag cmdremainder; symbol=GetAttr('SYMBOL')
        if \datatype(sym.!amp.symbol,'W') then sym.!amp.symbol = 0
        call DefSymbol symbol, sym.!amp.symbol + 1
        end
      when abbrev('PRINT',word2,1) then do
        call EvalTag cmdremainder; symbol=GetAttr('SYMBOL')
        if \datatype(sym.!amp.symbol,'W') then sym.!amp.symbol = 0
        datastr = sym.!amp.symbol
        call DefSymbol symbol, sym.!amp.symbol + 1
        end
      when abbrev('CAPTURE',word2,1) then do
        call EvalTag cmdremainder; symbol=GetAttr('SYMBOL')
        capsym=GetAttr('CAPSYM')
        if \datatype(sym.!amp.symbol,'W') then sym.!amp.symbol = 0
        call DefSymbol capsym, sym.!amp.symbol
        end
      otherwise nop
      end
 
    when word1 == 'NAMEFILE' then do        /*----- .NAMEFILE  -----*/
      call EvalTag cmdremainder; nfname=GetAttr('NAME')
      select
        when currsys=CMS | ?pc then do
          parse value GetAttr('CMS') with if1 if2 .; if2uc=translate(if2)
          select
            when if2uc=''        then if1=if1 defimbft
            when if2uc='DSMREFS' then if1=if1 dsmrefft
            otherwise if1 = if1 if2
            end
          end
        when currsys = MVS then do
          if2 = GetAttr('TSOPART',!uc)
          if if2 \= ''
            then if1 = tsoprefix || if2
            else if1 = GetAttr('TSOFULL',!uc)
          end
        otherwise if1 = ''
        end
      sym.!namefile.nfname = if1
      end
 
    when word1 == 'NAMEIT'                  /*----- .NAMEIT    -----*/
      then call Eval_NAMEIT cmdremainder
 
    when word1 == 'NF' then do              /*----- .NF        -----*/
      call Stack2Write2
      select                           /* close prev .NF (if any)   */
        when nfsave = 'CENTER' then datastr = '</CENTER>'
        when nfsave = 'ON'     then datastr = EPre()
        otherwise nop
        end
      if datastr\='' then do; call Write2Temp2 datastr; datastr=''; end
      select                           /* handle new .NF            */
        when word2='ON' | word2='' then datastr = Pre()
        when word2 = 'CENTER' then datastr='<CENTER>'
        otherwise if _PREcount > 0 then datastr = EPre()
        end
      nfsave = word2
      end
 
    when word1 == 'OR' then do              /*----- .OR        -----*/
      parse var cmdremainder comp1 compif comp2 cmdremainder
      ?IFcondx = ?IFcondx | Eval_Expression(comp1,compif,comp2,cword)
      if ?IFcondx & cmdremainder\=''
        then call Put_Buffer strip(cmdremainder), !lifo
      end
 
    when word1 == 'PI' then do              /*----- .PI        -----*/
      do forever
        word1 = translate(word(cmdremainder,1))
        select
          when wordpos(word1,'REF ORDER START END') > 0
            then cmdremainder = subword(cmdremainder,2)
          when word1 = 'KEY' then do
            cmdremainder = subword(cmdremainder,2)
            parse value cmdremainder,
                  with  1 pidc 2 . (pidc) . (pidc) . (pidc) cmdremainder
            cmdremainder = strip(cmdremainder)
            end
          otherwise leave
          end
        end
      parse value cmdremainder,
            with  1 pidc 2 pit.1 (pidc) pit.2 (pidc) pit.3 (pidc) pixid (pidc)
      pimax=0; pistr=''; piopts=''
      if pixid\='' then piopts = ' PG='b2hdelim||pixid||b2hdelim
      do pii=1 to 3; if pit.pii\='' then pimax=pii; end
      do pii = 1 to pimax
        if pii<pimax then pitemp=':IH'pii; else pitemp=':I'pii||piopts
        pistr = pistr || pitemp'.'pit.pii
        end
      if pistr\='' then call Put_Buffer pistr, !lifo
      end
 
    when word1=='QQ' | word1=='QU'          /*----- .QQ / .QU  -----*/
      then signal Exit_Program
 
    when word1 == 'RC' then do              /*----- .RC        -----*/
      call Stack2Write2; _rc=0; rcoffstr=''
      select
        when word3='ON' | word3='ON/OFF' then if ?revision.word2 then do
          revnest=revnest+1
          revchar.revnest=revisionchar.word2; revid.revnest=word2
          ?revprop.revnest = revprop.word2
          spi='b2hrevchar'; sym.!amp.spi=revchar.revnest
          datastr=SymbSub(rev.word2)
          if word3='ON/OFF'
            then do; rcoffstr=SymbSub(erev.word2); _rc=2; end
            else do; rcoffstr=''; _rc=0; end
          end
        when word3='OFF' then if ?revision.word2 then do
          datastr=SymbSub(erev.word2); revnest=max(0,revnest-1)
          spi='b2hrevchar'; sym.!amp.spi=revchar.revnest
          end
        when word3\=''
          then do; ?revision.word2=true; revisionchar.word2=word3; end
        otherwise nop
        end
      end
 
    when word1 == 'RE'                      /*----- .RE        -----*/
      then call SaveRestore !restore word2
 
    when word1 == 'RV' then do              /*----- .RV        -----*/
      parse pull rvdata
      call DefSymbol word(cmdremainder,1), rvdata
      call MsgOut !userinp 482, rvdata
      end
 
    when word1 == 'SA'                      /*----- .SA        -----*/
      then call SaveRestore !save word2
 
    when word1 == 'SE'                      /*----- .SE        -----*/
      then call Eval_SE cmdremainder
 
    when word1 == 'SETDVCF'                 /*----- .SETDVCF   -----*/
      then call Eval_SETDVCF cmdremainder
 
    when word1 == 'SETUP'                   /*----- .SETUP     -----*/
      then if \?setup then do               /* do only once         */
        ?setup = true
        ifi = strip(SymbSub(translate(cmdremainder,' ','()')))
        if words(ifi)=1 & ifi=cmdremainder
          then if sym.!namefile.ifi\='' then ifi=sym.!namefile.ifi
        call ImbedFile ifi,commandmacro,!recnum
        if ?autosetup then call Put_Buffer '.*B2H SPLIT'
        end
 
    when word1 == 'SI'                      /*----- .SI        -----*/
      then datastr = ':ARTWORK NAME='word2'.'
 
    when word1=='SP' | word1=='SK' then do  /*----- .SP or .SK -----*/
      word2 = SymbSub(word2); if \datatype(word2,'W') then word2 = 1
      datastr = copies(sym.!dot.word1,min(word2,10))
      end
 
    when word1 == 'SU'                      /*----- .SU        -----*/
      then ?su = ( word2 \= 'OFF' )
 
    when word1 == 'SX' then do              /*----- .SX        -----*/
      word1 = translate(word(cmdremainder,1))
      if word1='F' | word1='C'
        then do
          parse var cmdremainder . cmdremainder
          cmdremainder = strip(cmdremainder)
          end
        else word1 = 'F'
      parse var cmdremainder 1 dlc 2 lpart (dlc) fill (dlc) rpart (dlc)
      lpart = SymbSub(lpart); lpartlen = InternalWidth(lpart,0)
      fill  = SymbSub(fill); if fill == '' then fill = ' '
      rpart = SymbSub(rpart); rpartlen = InternalWidth(rpart,0)
      midlen = linewidth.llcnt - lpartlen - rpartlen
      if midlen < 1
        then datastr = ''
        else if word1 = 'F'
          then datastr = left(copies(fill,midlen%length(fill)),midlen)
          else datastr = center(fill,midlen)
      datastr=Pre()||lpart||datastr||rpart||EPre()
      end
 
    when word1 == 'TABRACK' then do         /*----- .TABRACK   -----*/
      if wordpos(translate(word(cmdremainder,1)),gmltypes) > 0
        then parse var cmdremainder . cmdremainder
      colalignh.='L'; colfill.=' '; colHP.=''; colEHP.=''; temp1=''
      parse value 0 with colwidthphys. 1 tabi 1 prevtotlen
      do while cmdremainder \= ''
        parse value GetValue(cmdremainder) with text (nl) cmdremainder
        tabi=tabi+1; colwidthphys.tabi=length(text)
        colwidthphys.!totlen = colwidthphys.!totlen + colwidthphys.tabi
        temp1 = temp1 colwidthphys.tabi
        end
      parse value tabi with numcols_physical 1 numcols_logical
      call Put_Buffer ':BHTAB PC='tabi 'LC='tabi 'CWP="'space(temp1)'".'
      end
 
    when word1=='TH' | word1='THEN'         /*----- .TH        -----*/
      then if ?IFcondx then call Put_Buffer strip(cmdremainder),!lifo
 
    when word1 = 'TI' then do               /*----- .TI        -----*/
      if cmdremainder = ''
        then parse value '' with dottis dottit
        else do while cmdremainder \= ''
          parse var cmdremainder i j cmdremainder
          i=HexChar(i,commandmacro); j=HexChar(j,commandmacro)
          k=pos(i,dottis); if k>0 then do
            dottis=delstr(dottis,k,1); dottit=delstr(dottit,k,1);
            end
          dottis=dottis||i; dottit=dottit||j
          end
      call Set_XlateI
      end
 
    when word1 == 'TR' then do              /*----- .TR        -----*/
      if cmdremainder = ''
        then parse value '' with dottrs dottrt
        else do while cmdremainder \= ''
          parse var cmdremainder i j cmdremainder
          i=HexChar(i,commandmacro); j=HexChar(j,commandmacro)
          k=pos(i,dottrs); if k>0 then do
            dottrs=delstr(dottrs,k,1); dottrt=delstr(dottrt,k,1);
            end
          dottrs=dottrs||i; dottrt=dottrt||j
          end
      call Set_XlateO
      end
 
    when word1 = 'TY'                       /*----- .TY        -----*/
      then call MsgOut !usermsg 483, SymbSub(cmdremainder)' '
 
    when word1 = 'UC' then do               /*----- .UC        -----*/
      call Stack2Write2
      select
        when word2 = 'ON'  then parse value -1 with _uc 1 _us
        when word2 = 'OFF' then parse value  0 with _uc 1 _us
        when datatype(word2,'W') & word3=''
          then parse value word2 with _uc 1 _us
        when word2 = '' then parse value 1 with _uc 1 _us
        otherwise datastr = '<U>'translate(cmdremainder)'</U>'
        end
      end
 
    when word1 = 'UP' then do               /*----- .UP        -----*/
      call Stack2Write2
      select
        when word2 = 'ON'  then _uc = -1
        when word2 = 'OFF' then _uc = 0
        when datatype(word2,'W') & word3='' then _uc = word2
        when word2 = '' then _uc = 1
        otherwise datastr = translate(cmdremainder)
        end
      end
 
    when word1 = 'US' then do               /*----- .US        -----*/
      call Stack2Write2
      select
        when word2 = 'ON'  then _us = -1
        when word2 = 'OFF' then _us = 0
        when datatype(word2,'W') & word3='' then _us = word2
        when word2 = '' then _us = 1
        otherwise datastr = '<U>'cmdremainder'</U>'
        end
      end
 
    when macro.word1.0 > 0 then do          /* defined user macro?  */
      call Put_Buffer ':BHMAC CNT=-1.'macroparms,!lifo  /*  yes, so */
      do cmi = macro.word1.0 to 1 by -1     /*   insert saved stmts */
        cmj = macro.word1.cmi               /*   in reverse order   */
        call Put_Buffer cmj, !lifo
        if left(cmj,3) = '...' then do      /* a label within macro?*/
          cmlabel = word(substr(cmj,4),1)   /*   yes, show not fnd  */
          ?labelfnd.infilecnt.cmlabel = false
          end
        end
      call Put_Buffer ':BHMAC CNT=1.'cmdremainder, !lifo
      end
 
    /*----- unknown macro or Script/VS control word -----*/
    otherwise if cmloop = 1           /* see if "weird" markup used */
      then do; parmstring=left(word1,2) substr(word1,3); iterate cmloop; end
      else call MsgOut ?prcunktag 401, ,
                'Not a valid SCRIPT/VS control word', arg(1), !recnum
    end
  leave cmloop
  end cmloop
 
if \?OKtoUse then datastr = ''
if ?trcparse then call Here2 datastr
return datastr
 
 
/*------------------------------------------------------------------*/
/* Write2Temp2: Write record to work file for processing by pass 2  */
/* Usage:  call Write2Temp2 record                                  */
/*------------------------------------------------------------------*/
Write2Temp2: rtn='WRITE2TEMP2'; trace value tracelist.rtn
parse arg w2rec
if ?trcio then call Here1 rtn,w2rec,sigl,!io
w2rec = SymbSub(w2rec)
if w2rec == '' then signal End_Write2Temp2
if _ce \= 0 then do                    /* centering in effect?      */
  _ce = _ce - 1
  if ?centertag
    then w2rec = '<CENTER>'w2rec'</CENTER>'
    else do
      j = ( linewidth.llcnt - length(w2rec) ) % 2
      if j>0 then w2rec=Pre()||copies(' ',j)||EPre()||w2rec'<BR>'
      end
  end
if _li \= 0 then _li = _li - 1         /* within .LI ?              */
if _rc > 0 then do                     /* within a counted .RC?     */
  _rc = _rc - 1
  if _rc = 0 then do
    w2rec    = w2rec || rcoffstr
    revnest  = max(0,revnest-1)
    rcoffstr = ''
    end
  end
if _uc \= 0 then do; _uc=_uc-1; w2rec=translate(w2rec); end /* .UC  */
if _us \= 0 then do; _us=_us-1; w2rec='<U>'w2rec'</U>'; end /* .US  */
if ?linesflag                          /* within :LINES?            */
  then if pos(tab,w2rec) > 0           /* handle tabbing if there   */
    then w2rec = TabDataRec(w2rec,tab)
if ?screenflag                         /* within :SCREEN/:ESCREEN   */
  then w2rec = vbar||left(w2rec,InternalWidth(w2rec,linewidth.llcnt))||vbar
if _BRcount \= 0                       /* adding <BR> to line end?  */
  then if _PREcount = 0 | ( ?tableflag & htmlrel=2 )
    then if translate(right(w2rec,breaklen)) \== break
      then if translate(right(w2rec,6)) \== '</PRE>'
        then w2rec = w2rec || break
if _PREcount \= 0 then select          /* within <PRE></PRE>?       */
  when w2rec == '' then w2rec = ' '
  when inwidth > 0 then w2rec = copies(' ',inwidth) || w2rec
  otherwise nop
  end
 
select
  when w2rec == ''   then nop
  when ?addressprologflag then call SaveRec !address,w2rec
  when ?artaltlabel  then artaltlabel = artaltlabel || w2rec' '
  when ?coprext      then coprext = coprext || w2rec' '
  when ?figdescflag  then do
    j = figdesc._fignum.0 + 1
    figdesc._fignum.j = w2rec
    figdesc._fignum.0 = j
    end
  when ?fnflag       then call SaveRec !fn,w2rec
  when ?lenflag      then call SaveRec !len,w2rec
  when ?libraryflag  then call SaveRec !library,w2rec
  when ?tabdataflag  then call WrtLine pass1out,TabDataRec(w2rec,tabdata_tab)
  when ?titleflag    then call SaveRec !title,w2rec
  when ?topicflag    then call SaveRec !topic,w2rec
  when ?synntflag then do
    j = synnt.synnt_id.0 + 1
    synnt.synnt_id.j = w2rec
    synnt.synnt_id.0 = j
    end
  when ?tableflag & htmlrel=2 then rowcol.row.col=rowcol.row.col||w2rec' '
  when ?tdescflag & htmlrel=2 then call SaveRec !tdesc,w2rec
  otherwise call WrtLine pass1out, w2rec
  end
 
/*----- if within a table, reset cell's default data -----*/
if ?tableflag
  then if defcelldata\='' & endcelltag\='' & htmlrel>=3 then do
    parse upper var w2rec '<TD' . '>' i1
    parse upper var w2rec '<TH' . '>' i2
    i1 = i1 || i2
    i2 = ''
    do while i1 \= ''                /* see if real data in cell    */
      parse value i1 with i2 '<' . '>' i1
      if i2 \= '' then leave         /* quit if data found          */
      end
    if i2 \= '' then defcelldata=''  /* if data, don't use default  */
    end
End_Write2Temp2:
if ?trcio then call Here2
return
 
 
/*------------------------------------------------------------------*/
/* ProcessTag1: Handle GML/Bookmaster tags during Pass 1            */
/*              Data returned to caller is included in Pass 1 output*/
/*              If multiple records are to be included, they are    */
/*              placed in the "PROCTAG." array. These records are to*/
/*              be written *before* any data returned to the caller.*/
/* Usage:  result = ProcessTag1(outfile)                            */
/*     outfile- file for physical output                            */
/*     result - what should be written to the output                */
/*------------------------------------------------------------------*/
ProcessTag1: rtn='PROCESSTAG1'; trace value tracelist.rtn
if ?trcparse then call Here1 rtn,arg(1),sigl,!parse
parse arg pt1out
parse value '' with datastr pt1result
?rescan = 1    /* Check returned string for more tags? 1=Y/0=N      */
 
/*----- if in literal mode and tag *not* :elitdata, quit now -----*/
if ?litdata
  then if TAGnameuc \= 'ELITDATA' then do
    pt1result = Xlate(TAGstringall,':','&#58;') || TAGresidual
    ?rescan   = 0
    signal End_ProcessTag1
    end
 
/*----- if symbol defined, then if IGNOREx, ignore it, -----*/
/*----- else process definition and return to caller   -----*/
temp = ''
if ?tableflag
  then if htmlrel = 2
    then temp = sym.!tagtbl.TAGnameuc
if temp = '=NO' then do
  call MsgOut !warning 434,'"'TAGitself'" not supported in a table',,
              TAGstringall,!recnumo
  pt1result = TAGtext || TAGresidual
  signal End_ProcessTag1
  end
if temp == '' then temp = sym.!tag.TAGnameuc
/*----- process a symbol table definition for this markup -----*/
if temp \== '' then do
  if ?tagcheck & ?OKtoUse
    then if ?TAGse.TAGnameuc
      then if left(TAGnameuc,1) = 'E'
        then call TagNestE; else call TagNestS
  temprslt = ''
  parse var temp temp1 temp2 tempx
  select
    /*----- handle IGNORE definition -----*/
    when temp=!ignore     then temprslt=TAGtext || TAGresidual
    /*----- handle IGNOREALL definition -----*/
    when temp=!ignoreall  then temprslt=TAGresidual
    /*----- handle IGNOREALLW definition -----*/
    when temp=!ignoreallw then do
      call MsgOut !warning 485, ,
           '"'TAGitself'"' ignorewmsg,TAGstringall,!recnumo
      temprslt = TAGresidual
      end
    /*----- handle IGNOREW definition -----*/
    when temp=!ignorew then do
      call MsgOut !warning 485, ,
           '"'TAGitself'"' ignorewmsg,TAGstringall,!recnumo
      temprslt = TAGtext || TAGresidual
      end
    /*----- invoke a user program/exit -----*/
    when translate(temp1) = !userpgm then do
      call Stack2Write2
      oldq = queued()
      interpret 'templine='temp2'("TAG",TAGstring,tempx,TAGtext)'
      do while templine \= ''     /* retrieve line(s) from result */
        parse var templine line (nl) templine
        call Put_Buffer line
        end
      do queued() - oldq
        parse pull line           /* retrieve line(s) from stack  */
        call Put_Buffer line
        end
      call Put_Buffer TAGresidual; TAGresidual=''
      end
    /*----- do &TEXT and &TEXTALL substitution -----*/
    otherwise do forever
      uctemp = translate(temp)
      i = pos('&TEXTALL',uctemp)
      j = pos('&TEXT',   uctemp)
      select
        when i > 0 then temprslt = left(temp,i-1) || TAGtext ||,
                                   TAGresidual || substr(temp,i+8)
        when j > 0 then temprslt = left(temp,j-1) || TAGtext ||,
                                   substr(temp,j+5) || TAGresidual
        otherwise do
          if ?TAGimmed.TAGnameuc       /* tag got "immed" text?     */
            then temprslt = temp || TAGresidual     /* yes, drop it */
            else temprslt = temp || TAGtext || TAGresidual
          leave
          end
        end
      temp = temprslt
      end
    end
  if temprslt=='' & TAGtext='' & TAGresidual='' & \?tableflag
    then pt1result = ''
    else pt1result = temprslt
  signal End_ProcessTag1
  end
 
/*----- tags that cause text to be handled/ignored -----*/
?handled = false
select
 
  when TAGnameuc=='ANNOT' then do           /*----- :ANNOT     -----*/
    ?handled=true; if ?tagcheck then call TagNestS ,,!nonest
    if \?annot
      then _ignore = _ignore + 1
      else TAGtext = SetUpTag() || TAGtext
    end
  when TAGnameuc=='EANNOT' then do          /*----- :EANNOT    -----*/
    ?handled=true; if ?tagcheck then call TagNestE
    if \?annot then _ignore = max(0,_ignore-1)
    datastr = SetUpTag(,2)
    end
 
  when TAGnameuc=='IGNORE'                  /*----- :IGNORE    -----*/
    then do; _ignore=_ignore+1; ?handled=true; end
  when TAGnameuc=='IGNOREW' then do         /*----- :IGNOREW   -----*/
    call MsgOut !warning 484,'Text for' TAGstring 'being bypassed!',,
                TAGstringall,!recnumo
    _ignore=_ignore+1; ?handled=true
    end
  when TAGnameuc=='EIGNORE'                 /*----- :EIGNORE   -----*/
    then do; _ignore=max(0,_ignore-1); ?handled=true; end
 
  when TAGnameuc=='PSC' then do             /*----- :PSC       -----*/
    ?handled=true; if ?tagcheck then call TagNestS ,,!nonest
    call EvalTag TAGoptions; omit=GetAttr('OMIT',!uc)
    proctype=GetAttr('PROC',!uc); xproctype=GetAttr('XPROC',!uc)
    if \?pscfound then do
      select
        when  proctype \= '' then  proctype =  proctype '1ST'
        when xproctype \= '' then xproctype = xproctype '1ST'
        otherwise nop
        end
      ?pscfound=true
      end
    parse value false with ?proc 1 ?xproc 1 ?omit
    do i = 1 to words(psc); atom=word(psc,i)
      if wordpos(atom,proctype)  > 0 then ?proc  = true
      if wordpos(atom,xproctype) > 0 then ?xproc = true
      if wordpos(atom,omit)      > 0 then ?omit  = true
      end
    select
      when  proctype \= '' then ?pscflag = \?proc
      when xproctype \= '' then ?pscflag = ?xproc
      otherwise                 ?pscflag = false
      end
    if ?omit then ?pscflag = \?pscflag
    end
  when TAGnameuc=='EPSC' then do            /*----- :EPSC      -----*/
    ?handled=true; if ?tagcheck then call TagNestE
    ?pscflag=false
    end
 
  otherwise nop
  end
 
/*----- if tag handled above, set switches and quit -----*/
if ?handled then do
  call Set_OKtoUse
  if ?OKtoUse
    then pt1result = TAGtext || TAGresidual
    else pt1result = TAGresidual
  signal End_ProcessTag1
  end
/*----- if ignoring text, quit now -----*/
if \?OKtoUse
  then do; pt1result=TAGresidual; signal End_ProcessTag1; end
 
 
/*----- If I got to here, there's a :tag to handle -----*/
select
                  /*----- :ABBREV/:ABSTRACT/:BIBLIOG/:GLOSSARY -----*/
                  /*----- :LEGEND/:PREFACE/:SAFETY/:SOA        -----*/
  when wordpos(TAGnameuc,'ABBREV ABSTRACT BIBLIOG GLOSSARY',
                         'LEGEND PREFACE SAFETY SOA')>0 then do
    call Stack2Write2
    if TAGtext = '' then TAGtext = deftext.TAGnameuc
    datastr=':H1' TAGoptions'.'TAGtext||TAGresidual; TAGresidual=''
    end
 
  when TAGnameuc=='ADDRESS' then do         /*----- :ADDRESS   -----*/
    if ?tagcheck then call TagNestS ,,!nonest
    ?addressflag = true
    if ?prolog                         /* within :PROLOG/:EPROLOG?  */
      then do                          /*   yes, accumulate text    */
        ?addressprologflag = true
        if TAGtext \= '' then call SaveRec !address,SymbSub(TAGtext)
        end
      else do                          /*    no, show the text now  */
        call Stack2Write2; call ProcTag '<P><ADDRESS>',!force
        _BRcount=_BRcount+1; datastr=TAGtext
        end
    end
  when TAGnameuc=='EADDRESS' then do        /*----- :EADDRESS  -----*/
    if ?tagcheck then call TagNestE
    if ?prolog
      then do; call Stack2Write2; ?addressprologflag=false; end
      else do
        call Stack2Write2; call ProcTag '</ADDRESS>',!force
        _BRcount = max(0,_BRcount-1);
        end
    ?addressflag=false; datastr=TAGtext
    end
 
  when TAGnameuc=='ANSREF'                  /*----- :ANSREF    -----*/
    then if ?tableflag & htmlrel=2          /* if in a HTML 2 table */
      then datastr=RefInTable(!ansref)      /* handle now, otherwise*/
      else call Handle_In_Pass2             /* handle in pass 2     */
 
  when TAGnameuc=='ANSWER'                  /*----- :ANSWER    -----*/
    then call Handle_In_Pass2               /* handle in pass 2     */
 
  when TAGnameuc=='APPENDIX' then do        /*----- :APPENDIX  -----*/
    if TAGtext \= '' then deftext.!appendix=TAGtext
    call Stack2Write2; ?appendix=true; bookpart=2; datastr=SetUpTag()
 
    end
  when TAGnameuc=='EAPPENDIX' then do       /*----- :EAPPENDIX -----*/
    call Stack2Write2; ?appendix=false; datastr=SetUpTag(,2)||TAGtext
    end
 
  when TAGnameuc=='ARTALT' then do          /*----- :ARTALT    -----*/
    call Stack2Write2; if ?tagcheck then call TagNestS ,,!nonest
    artaltopts=TAGoptions; artaltlabel=''; ?artaltlabel=true
    end
  when TAGnameuc=='EARTALT' then do         /*----- :EARTALT   -----*/
    if ?tagcheck then call TagNestE
    call stack2Write2; ?artaltlabel=false
    do forever   /* remove HTML tags */
      parse var artaltlabel artaltlabel '<' temp1 '>' artaltright
      if artaltright = ''
        then leave; else artaltlabel = artaltlabel || artaltright
      end
    datastr = ':ARTWORK' artaltopts,
              'LABEL='b2hdelim||strip(artaltlabel)||b2hdelim'.'TAGtext
    end
 
  when TAGnameuc=='ARTDEF' then call DefTag /*----- :ARTDEF    -----*/
 
  when TAGnameuc=='ARTWORK' then do         /*----- :ARTWORK   -----*/
    call EvalTag TAGoptions, 'ARTDEF'
    artname=GetAttr('NAME'); artrule=GetAttr('RULE')
    if artname = ''                         /* image name given?    */
     then if artrule = ''                   /*   no, rule wanted?   */
       then datastr='<P>'; else datastr=hrtag.1
     else do                                /* handle image         */
      artlabel=GetAttr('LABEL'); artalign=GetAttr('ALIGN',!uc)
      artrunin=GetAttr('RUNIN')
      if artrunin = ''
        then parse value '<BR>' with srunin 1 erunin
        else parse value ''     with srunin   erunin
      if artlabel = '' then artlabel = deftext.!artlabel
      if artlabel = '' then artlabel = 'Figure' artname 'not displayed.'
      if wordpos(artalign,'CENTER CENTRE RIGHT')>0 & ?centertag
        then parse value '<CENTER> </CENTER>' with a1 a2
        else parse value '' with a1 a2
      picticon = '<IMG SRC="'imgpath||artlinkimg'" ALIGN="MIDDLE">'
      select
       when ?tableflag & htmlrel=2
         then if artlabel \= ''
           then datastr = '&lt;<I>'strip(artlabel)'</I>&gt;'
       when artshow == !link
         then datastr=srunin'<B>' ||,
                 HtmlX(!a,'HREF="'imgpath||FileCase(artname'.'arttype)'"') ||,
                 picticon || deftext.!artlink'</A></B>'erunin
       when artshow == !view
         then datastr='<B>'srunin || a1 ||,
                      HtmlX(!img,'SRC="'imgpath||FileCase(artname'.'arttype)||,
                      '" ALT="'artlabel'"')||a2||erunin'</B>'
       otherwise nop
       end
      end
    datastr = datastr || TAGtext
    end
 
  when TAGnameuc=='BACKM' then do           /*----- :BACKM     -----*/
    if ?appendix then datastr = SetUpTag('APPENDIX',2)
    call Stack2Write2; bookpart=2; ?appendix=false; ?backm=true; ?frontm=false
    end
 
  when TAGnameuc=='BHCMT'                   /*----- :BHCMT     -----*/
    then call ProcTag TAGstring||TAGtext||, /* (handled in pass 2)  */
                      TAGresidual, !force
 
  when TAGnameuc=='BHL' then do             /*----- :BHL       -----*/
    datastr=TAGstring||TAGtext; ?rescan=0   /* (handled in pass 2)  */
    end
 
  when TAGnameuc=='BHMAC' then do             /*--- :BHMAC     -----*/
    call EvalTag TAGoptions; _macronest=_macronest+GetAttr('CNT')
    macroparms = TAGtext
    end
 
  when TAGnameuc=='BHSPLIT'                 /*----- :BHSPLIT   -----*/
   then if autosplit >= 0 then do
     call EvalTag TAGoptions
     call Split_File_Here GetAttr('PF'),GetAttr('LF')
     end
 
  when TAGnameuc=='BHTAB'                   /*----- :BHTAB     -----*/
    then call ProcTag TAGstring||TAGtext||, /* (handled in pass 2)  */
                      TAGresidual, !force
 
  when TAGnameuc=='BHXREF' then do          /*----- :BHXREF    -----*/
    parse value TAGtext || TAGresidual,
          with  b1 (x01) b2 (x01) b3 (x01) b4 (x01),
                b5 (x01) b6 (x01) b7 (x01)
    call SaveXrefEntry b1,b2,b3,b4,b5,b6,b7,0
    end
 
  when TAGnameuc=='BLANK' then do           /*----- :BLANK     -----*/
    call EvalTag TAGoptions; blankwidth=GetAttr('WIDTH',!uc)
    blankans=GetAttr('ANS'); blankline=''
    select
      when blankwidth='' then if blankans=''
        then blankwidth=10; else blankwidth=length(blankans) * 2
      when blankwidth = 'TEXTLINE'
        then parse value '<BR>' linewidth.llcnt with blankline blankwidth
      otherwise blankwidth = trunc(HorizWidth(blankwidth))
      end
    if ?questionflag                   /* within :QUESTION?         */
      then do                          /*   yes, handle as such     */
        if quest.qid.!form = 'FILLIN'
          then quest.qid.!ans = quest.qid.!ans blankans
        if quest.qid.!form='FILLIN' & ?questform
          then call ProcTag blankline,
                    HtmlX(!input,'TYPE="text"',
                                 'NAME="inp" SIZE="'blankwidth'"') ||,
                    anchortext blankline TAGtext
          else call ProcTag blankline copies('_',blankwidth) blankline TAGtext
        end
      else datastr = blankline||copies('_',blankwidth)||blankline||TAGtext
    end
 
  when TAGnameuc=='BODY' then do            /*----- :BODY      -----*/
    call Stack2Write2; parse value '0 0 1' with ?frontm ?prolog bookpart
    end
 
  when TAGnameuc=='C' then do               /*----- :C         -----*/
    call Stack2Write2
    if ?tagcheck then if \?tableflag then call OutOfSeq !table
    if htmlrel=2 & col>0 then do
      if colEHP.col \= '' then call Write2Temp2 colEHP.col
      _BRcount = max(0,_BRcount-colconcat.col)
      end
    col=col+1; parse value word(TAGoptions,1) col with thiscol .
    if \datatype(thiscol,'W') then thiscol = col
    select
      when thiscol = col then nop
      when thiscol < col then call MsgOut !warning 432,,
         'Out-of-sequence table cell detected',TAGstringall,!recnumo
      otherwise do
        pt1result=copies(':c.',thiscol-col)||TAGstringall||TAGresidual
        col=col-1; signal End_ProcessTag1
        end
      end
    if col > numcols_logical then do
      pt1result = ':ROW.:C.'TAGtext||TAGresidual
      col=thiscol-1; signal End_ProcessTag1
      end
    select
      when htmlrel = 2 then do
        _BRcount=_BRcount+colconcat.col; datastr=colHP.col||TAGtext
        end
      when htmlrel >= 3 then do
        col=col-1;if col>0 then datastr=GenCellEnd() /*end prev cell*/
        col=col+1
        if tblrowstrt.col > tblphysrow then do /* need new phys row?*/
          datastr=datastr||copies('</TR><TR>',tblrowstrt.col-tblphysrow)
          tblphysrow = tblrowstrt.col
          end
        datastr=datastr||GenCellStart(TAGtext); defcelldata=break
        end
      otherwise nop
      end
    end
 
  when TAGnameuc=='CGDEF' then call DefTag  /*----- :CGDEF     -----*/
 
  when TAGnameuc=='CHOICE' then do          /*----- :CHOICE    -----*/
    if ?tagcheck then if \?questionflag then call OutOfSeq !question
    call EvalTag TAGoptions; choiceid=GetAttr('ID')
    if choiceid = '' then choiceid = 'WRONGANS'
    if choiceqid = qid                 /* same question as before?  */
      then _choicenum = _choicenum + 1
      else do
        _choicenum=1; choiceqid=qid; ?choicedl=true
        call ProcTag '<P>'list.!dl.questdl.1
        end
    /* if MC form show checkbox otherwise (MATCH or not form) list item */
    if ?questform & quest.qid.!form='MC'
      then i = HtmlX(!input,'TYPE="checkbox"',
               'NAME="inp" VALUE="'_choicenum'"') ||,
               blank
      else i = ''
    call ProcTag list.!dl.questdl.3 || RevTag(!s) || i || _choicenum'.' ||,
                 ERevTag(!s) || list.!dl.questdl.4
    call ProcTag list.!dl.questdl.5 || RevTag(!s) || TAGtext
    chans.choiceid = _choicenum        /*save for use in :EQUESTION.*/
    end
 
  when TAGnameuc=='CIT' then do             /*----- :CIT       -----*/
    call EvalTag TAGoptions; docid=GetAttr('DOCID',!uc)
    if docid\='' & docdesc.docid\=''
      then do
        datastr = HtmlX(!a,'HREF="'docdesc.docid'"')
        ecittag = '</A>'
        end
      else ecittag=''
    datastr = SetUpTag()'<CITE>'datastr||TAGtext
    ecittag = ecittag'</CITE>'SetUpTag(,2)
    if ?tagcheck then call TagNestS ,,!nonest
    end
  when TAGnameuc=='ECIT' then do            /*----- :ECIT      -----*/
    datastr=ecittag||TAGtext; ecittag=''; if ?tagcheck then call TagNestE
    end
 
  when TAGnameuc=='CODE' then do            /*----- :CODE      -----*/
    if ?tagcheck then if \?mcflag then call OutOfSeq !mc
    temp1=SetUpTag(mctagname,1) || mc.0 || RevTag(!s)
    temp2=ErevTag(!s) || mc.1 || SetUpTag(mctagname,2)
    select
      when mc.!style='BOX' | mc.!style='LBLBOX'
        then datastr=mc.!e'<P>' ||,
                     HtmlX(!table, Border(1 + (mc.!style='LBLBOX')),
                           'WIDTH="100%"') || '<TR><TD>' ||,
                     temp1'<STRONG> 'TAGtext'</STRONG>' ||,
                     temp2'</TD></TR></TABLE>'
      when mc.!style='RULE'
        then datastr=mc.!e'<P>'hrtag.4'<BR><STRONG>'TAGtext'</STRONG>'
      otherwise datastr=mc.!e'<P><BR><STRONG>'TAGtext'</STRONG>'
      end
    end
 
  when TAGnameuc=='COPREXT'                 /*----- :COPREXT   -----*/
    then if ?vnotice
      then do; call Stack2Write2; datastr=TAGtext; ?coprext=true; end
 
  when TAGnameuc=='COPRNOTE'                /*----- :COPRNOTE  -----*/
    then if ?vnotice then do
      if ?coprext then call Stack2Write2
      coprnote=TAGtext; ?coprext=false
      end
 
  when wordpos(TAGnameuc,'DD DDHD GD')>0 then do /*--:DD/:DDHD/:GD--*/
    if ?tagcheck then if listnest=0
      then call OutOfSeq !list
      else if TAGnameuc='DDHD'
        then call CheckSeq 2; else call CheckSeq 5
    if TAGnameuc='DDHD' then TAGtext='<B>'TAGtext'</B>'
    if TAGnameuc = 'GD'
      then do
        if ?gdnum
          then do; _gdnum=_gdnum+1; TAGtext='('_gdnum')' TAGtext; end
        if _gdnum < 2
          then datastr = GenListItemEnd() || listitem.listnest.5
          else datastr = listitem.listnest.6
        call SetListItemEnd listitem.listnest.7
        end
      else do
        datastr = GenListItemEnd() || listitem.listnest.5
        call SetListItemEnd listitem.listnest.6
        end
    datastr = datastr || GenListItemStart() || TAGtext
    end
 
  when TAGnameuc=='DELIM' then do           /*----- :DELIM     -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    call EvalTag TAGoptions; i=syndat.0 + 1; syndat.0=i
    syndat.i._text = SynData(TAGtext,SynFont())
    syndat.i._placement = SynPlace('OPT REQ')
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    syndat.i._inside = syntax_container
    end
 
  when TAGnameuc=='DENTRY' then do          /*----- :DENTRY    -----*/
    if ?tagcheck then if \?directflag then call OutOfSeq !direct
    dirchunk = dirchunk - 1
    if dirchunk = 0
      then do; dirchunk=5; call ProcTag ' ',!force; end
      else if ?direxpand then call ProcTag ' ',!force
    call ProcTag DentryRec(SymbSub(TAGtext)), !force
    end
 
  when TAGnameuc=='DIALDEF' then call DefTag /*---- :DIALDEF   -----*/
 
  when TAGnameuc=='DIALOG' then do          /*----- :DIALOG    -----*/
    /*  dialog.0  - text for :SYS               */
    /*  dialog.1  - start-tags for :SYS         */
    /*  dialog.2  - end-tags   for :SYS         */
    /*  dialog.3  - text for :USER              */
    /*  dialog.4  - start-tags for :USER        */
    /*  dialog.5  - end-tags   for :USER        */
    /*  dialog.8  - 0=DL format; 1=TABLE format */
    /*  dialog.9  - 1=at least one :SYS/:USER   */
    /*  dialog.99 - end-tags for prev item      */
    call Stack2Write2; if ?tagcheck then call TagNestS ,,!nonest
    call EvalTag TAGoptions, 'DIALDEF'
    dialog.=''; ?dialogflag=true; _BRcount=_BRcount+1
    if wordpos('LABEL',dialog) > 0 then do
      dialog.0=GetAttr('SYS');  if dialog.0='' then dialog.0=deftext.!dialsys
      dialog.3=GetAttr('USER'); if dialog.3='' then dialog.3=deftext.!dialuser
      end
    dialog.1=list.!sys.0.1;  dialog.2=list.!sys.0.2
    dialog.4=list.!user.0.1; dialog.5=list.!user.0.2
    if wordpos('FONT',dialog) > 0 then do
      dialog.1=dialog.1||list.!sys.1.1 ; dialog.2=list.!sys.1.2 ||dialog.2
      dialog.4=dialog.4||list.!user.1.1; dialog.5=list.!user.1.2||dialog.5
      end
    if wordpos('COLOR',dialog) > 0 then do
      dialog.1=dialog.1||list.!sys.2.1 ; dialog.2=list.!sys.2.2 ||dialog.2
      dialog.4=dialog.4||list.!user.2.1; dialog.5=list.!user.2.2||dialog.5
      end
    parse value Scale() with temp3 (nl) temp4
    temp1=SetUpTag()||temp3; temp2=temp4||SetUpTag(,2)
    dialog.0=temp1||dialog.0||temp2; dialog.3=temp1||dialog.3||temp2
    dialog.1=temp1||dialog.1; dialog.2=dialog.2||temp2
    dialog.4=temp1||dialog.4; dialog.5=dialog.5||temp2
    dialog.8=( htmlrel>=3 ); dialog.9=0
    if dialog.8 = 0
      then call ProcTag SetUpTag()||HtmlX(!dl,'COMPACT'), !force
      else call ProcTag SetUpTag()'<P>'HtmlX(!table), !force
    end
  when TAGnameuc=='EDIALOG' then do         /*----- :EDIALOG   -----*/
    call Stack2Write2; if ?tagcheck then call TagNestE
    if dialog.8=1 & dialog.9=1
      then datastr = ERevTag(!s)'</TD></TR>'
    j='DIALOG'; if dialog.8 = 0
      then datastr = dialog.99 || datastr'</DL>'SetUpTag(,2)    || TAGtext
      else datastr = dialog.99 || datastr'</TABLE>'SetUpTag(,2) || TAGtext
    dialog.=''; ?dialogflag=false; _BRcount=max(0,_BRcount-1)
    end
 
  when TAGnameuc=='SYS'|TAGnameuc=='USER' then do /*-- :SYS/:USER --*/
    call Stack2Write2
    if ?tagcheck then if \?dialogflag then call OutOfSeq !dialog
    if dialog.9=1 then if dialog.8=0 & dialog.99\=''
      then datastr = dialog.99
      else datastr = dialog.99 || ERevTag(!s)'</TD></TR>'
    j1=(TAGnameuc='USER')*3; j2=j1+1; j3=j1+2
    if dialog.8 = 0
      then call ProcTag datastr || HtmlX(!dt) || dialog.j1 ||,
                                   HtmlX(!dd) || dialog.j2, !force
      else call ProcTag datastr || HtmlX(!tr) ||,
            HtmlX(!td,'VALIGN="TOP"') ||,
            RevTag(!s) || dialog.j1 || ERevTag(!s)'</TD>' ||,
            HtmlX(!td) || RevTag(!s) || dialog.j2, !force
    dialog.9=1; dialog.99=dialog.j3; datastr=TAGtext
    end
 
  when TAGnameuc=='DIRDEF' then call DefTag /*----- :DIRDEF    -----*/
 
  when TAGnameuc=='DIRECT' then do          /*----- :DIRECT    -----*/
    call Stack2Write2
    parse value '0 0 -1' with ?direxpand prevtotlen dirchunk w.
    call EvalTag TAGoptions, 'DIRDEF'
    temp1=GetAttr('SCALE'); if \datatype(temp1,'N') then temp1=1
    call SetColumns !force,100*(1/temp1); call SetAlignH; call SetHP
    select
      when GetAttr('COMPACT') \= '' then nop
      when GetAttr('EXPAND')  \= '' then ?direxpand = true
      otherwise dirchunk = 6
      end
    parse value Scale() with temp1 (nl) edirectstr
    datastr='<P>'SetUpTag()||Pre()||temp1'<TT>'; ?directflag=true
    if ?tagcheck then call TagNestS ,,!nonest
    end
  when TAGnameuc=='EDIRECT' then do         /*----- :EDIRECT   -----*/
    call Stack2Write2; ?directflag=false;
    datastr='</TT>'edirectstr||EPre()||SetUpTag(,2)'<P>'TAGtext
    if ?tagcheck then call TagNestE
    end
 
  when TAGnameuc=='DIRHDR' then do          /*----- :DIRHDR.   -----*/
    if ?tagcheck then if \?directflag then call OutOfSeq !direct
    call ProcTag '<B>'DentryRec(SymbSub(TAGtext))'</B>', !force
    end
 
  when TAGnameuc=='DIRSUB' then do          /*----- :DIRSUB.   -----*/
    if ?tagcheck then if \?directflag then call OutOfSeq !direct
    call ProcTag ' ', !force
    call ProcTag '<B>'SymbSub(TAGtext)'</B>', !force
    if \?direxpand then call ProcTag ' ', !force
    if dirchunk >= 0 then dirchunk = 6
    end
 
  when wordpos(TAGnameuc,'DL GL OL SL UL')>0 /*-:DL/:GL/:OL/:SL/:UL-*/
    then do
      select
        when TAGnameuc='DL' then parse value '6 DLDEF' with k2 k
        when TAGnameuc='GL' then parse value '9'       with k2 k
        otherwise                parse value '4'       with k2 k
        end
      call EvalTag TAGoptions, k; compact=(GetAttr('COMPACT')\='')
      termhi=''; etermhi=''; if ?tagcheck then call TagNestS
      if TAGnameuc = 'DL' then do
        j=word(GetAttr('TERMHI') '2',1)
        if datatype(j,'W') then if j \= '0'
          then do; termhi=':hp'j'.'; etermhi=':ehp'j'.'; end
        end
      call StartNewList; call CheckSeq 0
      listitem.listnest.!termhi=termhi;  listitem.listnest.!etermhi=etermhi
      listitem.listnest.!type=TAGnameuc; listitem.listnest.!revnest=revnest
      if htmlrel >= 3
        then if (TAGnameuc='DL' & ?dlfmt) | (TAGnameuc='GL' & ?glfmt)
          then do; compact=compact+2; listitem.listnest.!table=1; end
      do k = 1 to k2; listitem.listnest.k = list.TAGnameuc.compact.k; end
      select
        when TAGnameuc = 'OL' then do
          olnest = olnest + 1
          parse value listitem.listnest.1 with tleft '>' tright
          listitem.listnest.!oltype=substr(olseq,(olnest-1)//length(olseq)+1,1)
          datastr = tleft 'TYPE='listitem.listnest.!oltype'>'tright
          end
        otherwise datastr = listitem.listnest.1
        end
      end
  when wordpos(TAGnameuc,'EDL EGL EOL ESL EUL')>0
    then do
      if ?tagcheck then do; call TagNestE; call CheckSeq 6; end
      datastr = GenListItemEnd() || listitem.listnest.2
      if listitem.listnest.!table
        then datastr=datastr||EndTableFont(listitem.listnest.!revnest)
      call EndExistingList
      if TAGnameuc = 'EOL' then olnest = max(0,olnest-1)
      datastr = datastr || TAGtext
      end
 
  when TAGnameuc=='DLDEF' then call DefTag  /*----- :DLDEF     -----*/
 
  when TAGnameuc=='DOCPROF' then do         /*----- :DOCPROF   -----*/
    TAGstring = SymbSub(space(TAGstring))
    call MsgOut !info 108,'Setting options using',TAGstring,!recnumo
    call SetOpts TAGoptions,0,1,1
    end
 
  when wordpos(TAGnameuc,'DT GT')>0 then do /*----- :DT/:GT    -----*/
    if ?tagcheck then if listnest=0
      then call OutOfSeq !list; else call CheckSeq 3
    datastr = GenListItemEnd() || listitem.listnest.3 ||,
              listitem.listnest.!termhi || GenListItemStart() || TAGtext
    call SetListItemEnd listitem.listnest.!etermhi || listitem.listnest.4
    listitem.listnest.!cnt = listitem.listnest.!cnt + 1
    if TAGnameuc = 'GT' then parse value '0' with ?gdnum 1 _gdnum
    end
 
  when TAGnameuc=='DTHD' then do            /*----- :DTHD      -----*/
    if ?tagcheck then if listnest=0
      then call OutOfSeq !list; else call CheckSeq 1
    datastr = GenListItemEnd() || listitem.listnest.3 ||,
              GenListItemStart() || '<B>'TAGtext'</B>'
    call SetListItemEnd listitem.listnest.4
    end
 
  when TAGnameuc=='FIG' then do             /*----- :FIG       -----*/
    call Stack2Write2; call EvalTag TAGoptions, 'FIGDEF'
    if ?tagcheck then call TagNestS ,,!nonest
    parse value Scale() with temp3 (nl) temp4
    temp1=SetUpTag()||temp3; temp2=temp4||SetUpTag(,2)
    figid=GetAttr('ID'); temp3=GetAttr('FRAME',!uc); revnest.!fig=0
    figsh=GetAttr('SHADE',!uc); ?figbr=\(GetAttr('CONCAT',!uc)='YES')
    select
      when temp3 = 'NONE'              /* frame around figure?      */
        then if ?figbr & ?figcaptop    /*   no, concatenating text? */
          then parse value ''    with datastr 1 efigstr    /* no    */
          else parse value '<P>' with datastr 1 efigstr    /* yes   */
      when htmlrel = 2     then parse value hrtag.2 with datastr 1 efigstr
      when temp3 = 'RULES' then parse value hrtag.3 with datastr 1 efigstr
      otherwise do
        if GetAttr('WIDTH',!uc)='PAGE' then datastr=datastr 'WIDTH="100%"'
        if figsh \= '' then datastr=datastr shade.figsh
        datastr = HtmlX(!table,Border(3) datastr) ||,
                  HtmlX(!tr) || HtmlX(!td) || temp1 || RevTag(!s)
        efigstr = ERevTag(!s)||temp2'</TD></TR></TABLE>'
        revnest.!fig = revnest
        end
      end
    datastr=temp1||datastr; efigstr=efigstr||temp2; _BRcount=_BRcount+?figbr
    _fignum=_fignum+1; ?figdescflag=false; ?figflag=true
    if ?figcaptop
      then call ProcTag ':BHFIG NUM='_fignum 'LOC=1.', !force
    end
  when TAGnameuc=='EFIG' then do            /*----- :EFIG      -----*/
    call Stack2Write2; _BRcount=max(0,_BRcount-?figbr)
    ?figdescflag=false; ?figflag=false
    if ?tagcheck then call TagNestE
    if ?figcaptop
      then datastr = efigstr || EndTableFont(revnest.!fig)
      else do
        call ProcTag efigstr || EndTableFont(revnest.!fig), !force
        call ProcTag ':BHFIG NUM='_fignum 'LOC=0.', !force
        end
    datastr = datastr || SetUpTag(,2) || TAGtext
    end
 
  when TAGnameuc=='FIGCAP' then do          /*----- :FIGCAP    -----*/
    if ?tagcheck then if \?figflag then call OutOfSeq !fig
    _figcapnum=_figcapnum+1; TAGtext=strip(Symbsub(TAGtext))
    if ?fbc then figtail=ChaptNum()'-'_figcapnum; else figtail=_figcapnum
    figcap._fignum='<B>' ||,
       MakeXref(!figref, figid, deftext.!figure figtail'.' TAGtext,,
                deftext.!figure figtail, figtail,,,TAGtext) ||,
       '</B>'
    end
 
  when TAGnameuc=='FIGDEF' then call DefTag /*----- :FIGDEF    -----*/
 
  when TAGnameuc=='FIGDESC' then do         /*----- :FIGDESC   -----*/
    if ?tagcheck then if \?figflag then call OutOfSeq !fig
    call Stack2Write2; _BRcount=max(0,_BRcount-?figbr)
    ?figbr=0; datastr=TAGtext; ?figdescflag=true
    end
 
  when TAGnameuc=='FIGLIST'                 /*----- :FIGLIST   -----*/
   then if ?figlistwanted then if ?figlistfnd
    then do
      call ProcTag TAGstringall,!force; figlistfile=currpartl
      if \?ftsep then tlistfile = currpartl
      end
    else do
      if TAGtext = '' then TAGtext = deftext.!figlist
      call EvalTag TAGoptions; tempid=GetAttr('ID')
      if tempid = ''
        then do
          TAGoptions = 'ID='FIGLISTname TAGoptions
          FIGLISTname = !hdref || FIGLISTname
          end
        else FIGLISTname = !hdref || tempid
      call Put_Buffer ':FIGLIST.', !lifo
      call Put_Buffer ':H1 B2HNUM=NO' TAGoptions'.'TAGtext||TAGresidual, !lifo
      TAGresidual=''; ?figlistfnd=true
      end
 
  when TAGnameuc=='FIGREF'                  /*----- :FIGREF    -----*/
    then if ?tableflag & htmlrel=2          /* if in a HTML 2 table */
      then datastr=RefInTable(!figref)      /* handle now, otherwise*/
      else call Handle_In_Pass2             /* handle in pass 2     */
 
  when TAGnameuc=='FN' then do              /*----- :FN        -----*/
    if ?tagcheck then call TagNestS ,,!nonest
    call Stack2Write2; call EvalTag TAGoptions
    fncallout=GetAttr('CALLOUT'); fnid=GetAttr('ID'); _fnnum=_fnnum+1
    if fncallout=='' then do;footcount=footcount+1;fncallout=footcount;end
    fncalloutsave=fncallout; fncallout=list.!fn.1||fncallout||list.!fn.2
    if fnid \= '' then call MakeXref !fnref,fnid,fncallout,fncallout,_fnnum
    parse value '' with refname reflink defname deflink
    if ?fnlinkto then do
      if fnid = ''
        then tempname = reftype.!fnref||_fnnum
        else tempname = !fnref || fnid
      defname  = 'NAME="'tempname'" '
      if fnid='' then reflink = 'HREF="#'tempname'" '
      end
    if ?fnlinkfrom & fnid='' then do
      tempname = reftype.!fnref'Used_'_fnnum
      refname = 'NAME="'tempname'" '
      deflink = 'HREF="#'tempname'" '
      end
    if refname='' & reflink=''
      then if fnid = ''
        then call ProcTag fncallout, !force
        else nop
      else call ProcTag HtmlX(!a,refname||reflink)||fncallout'</A>', !force
    i = RevTag(!s); if i \= '' then call SaveRec !fn,i
    if defname='' & deflink=''
      then temp1 = fncalloutsave
      else temp1 = HtmlX(!a,defname||deflink)||fncalloutsave'</A>'
    call SaveRec !fn,list.!fn.5 || temp1 || list.!fn.6
    call SaveRec !fn,list.!fn.7 || strip(TAGtext)
    ?fnflag=true; revnest.!fn=revnest
    end
  when TAGnameuc=='EFN' then do             /*----- :EFN       -----*/
    if ?tagcheck then call TagNestE
    call Stack2Write2
    temp1=list.!fn.8||ERevTag(!s); if temp1\='' then call SaveRec !fn,temp1
    datastr=TAGtext; ?fnflag=false
    end
 
  when TAGnameuc=='FNREF'                   /*----- :FNREF     -----*/
    then if ?tableflag & htmlrel=2          /* if in a HTML 2 table */
      then datastr=RefInTable(!fnref)       /* handle now, otherwise*/
      else call Handle_In_Pass2             /* handle in pass 2     */
 
  when TAGnameuc=='FRAGMENT' then do        /*----- :FRAGMENT  -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    call EvalTag TAGoptions; syntax_container=1
    i=syndat.0 + 1; syndat.0=i; syndat.i._id=strip(TAGtext)
    syndat.i._inside = syntax_container
    syndat.i._placement='ON'; syndat.i._order='SEQ'
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    syntax_container = i
    i=syndat.0 + 1; syndat.0=i; syndat.i._text=deftext._fragment_start
    syndat.i._inside = syntax_container
    syndat.i._placement='ON'
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    end
  when TAGnameuc=='EFRAGMENT' then do       /*----- :EFRAGMENT -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    i=syndat.0 + 1; syndat.0=i
    syndat.i._text=deftext._fragment_end; syndat.i._inside=syntax_container
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    syntax_container=syndat.syntax_container._inside; datastr=TAGtext
    end
 
  when TAGnameuc=='FRAGREF' then do         /*----- :FRAGREF   -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    call EvalTag TAGoptions; i=syndat.0 + 1; syndat.0 = i
    syndat.i._text = deftext._fragref_start SymbSub(TAGtext),
           deftext._fragref_end
    syndat.i._placement=SynPlace('OPT REQ')
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    syndat.i._inside = syntax_container
    end
 
  when TAGnameuc=='FRONTM'                  /*----- :FRONTM    -----*/
    then parse value '1 0 0' with ?frontm ?prolog bookpart
 
  when TAGnameuc=='GDG'                     /*----- :GDG       -----*/
    then do; ?gdnum=1; _gdnum=0; call CheckSeq 4; end
 
                                /*----- :GDOC/:IBMLPS/:USERDOC -----*/
  when wordpos(TAGnameuc,'GDOC IBMLPS USERDOC') > 0 then do
    call EvalTag TAGoptions; ugdoc=TAGnameuc
    tempsec=GetAttr('SEC'); copyr=GetAttr('COPYR')
    if TAGnameuc == 'IBMLPS'  then defstyle = 'IBMZALP'
    if TAGnameuc == 'USERDOC' then ibmcopyr=GetAttr('IBMCOPYR')
    if tempsec  \= '' then call ProcTag '<P><B>'tempsec'</B><P>'
    if security == '' then security = tempsec
    end
 
  when TAGnameuc=='GROUP' then do           /*----- :GROUP     -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    call EvalTag TAGoptions; i=syndat.0 + 1; syndat.0=i
    syndat.i._id=strip(translate(TAGtext)); syndat.i._inside=syntax_container
    x = strip(GetAttr('CHOICE',!uc) GetAttr('SEQ',!uc) GetAttr('COMPOSITE',!uc))
    if words(x) > 1 then do; call Conflict; x=''; end
    if x='' then syndat.i._order='SEQ'; else syndat.i._order=strip(x)
    x = strip(GetAttr('OPT',!uc) GetAttr('REQ',!uc))
    if words(x) > 1 then do; call Conflict; x=''; end
    select
      when GetAttr('DEF') \= '' then syndat.i._placement = 'ABOVE'
      when x = 'OPT' then syndat.i._placement = 'BELOW'
      otherwise syndat.i._placement = 'ON'
      end
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    syntax_container = i
    end
  when TAGnameuc=='EGROUP' then do          /*----- :EGROUP    -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    syntax_container=syndat.syntax_container._inside; datastr=TAGtext
    end
 
  when TAGnameuc=='GRPSEP' then do          /*----- :GRPSEP    -----*/
    if ?tagcheck then if listnest=0 then call OutOfSeq !list
    datastr = GenListItemEnd() || listitem.listnest.8 ||,
              GenListItemStart() || TAGtext
    call SetListItemEnd listitem.listnest.9
    end
 
  when left(TAGnameuc,1) == 'H' &,          /*----- :Hx        -----*/
       length(TAGnameuc) > 1 &,
       verify(substr(TAGnameuc,2),numchars) = 0 then do
    call EvalTag TAGoptions; headid=GetAttr('ID')
    hnum=GetAttr('NUM',!uc); resid=GetAttr('RES',!uc)
    ?showhdrnum = \( GetAttr('B2HNUM')='NO' | hnum='NONE' )
    hdlv=substr(TAGnameuc,2); _hnum=_hnum+1; lasthdlv=hdlv
    if hdlv <= ptocmost then ptoclfile = ''
    if hdlv <  minhdlv  then minhdlv   = hdlv
    if hdlv <= qreset   then _questnum = 0
    /*----- process header title -----*/
    parse value GetValue(SymbSub(TAGtext),'ALL') with headtext (nl) .
    call DefSymbol 'b2hhead'hdlv, headtext
    call ProcTag ':BHSYM NAME="b2hhead'hdlv'"',
                 'VALUE='b2hdelim||headtext||b2hdelim'.',!force
    j=''; do i = hdlv+1 to toclimit; j=j 'b2hhead'i; end
    call ProcTag ':BHSYM NAME="'strip(j)'" VALUE="".',!force
    /*----- set header counts -----*/
    hdrcnt.hdlv=hdrcnt.hdlv + 1
    do i=hdlv+1 to toclimit; hdrcnt.i=0; end i
    /*----- if TOC wanted, force :TOC if one not found yet -----*/
    if hdlv <= toclimit
      then if ?wanttoc & _toccnt=0 then do
        call ProcTag ':TOC.',!force; _toccnt=1; toclfile=currpartl
        end
    /*----- do split if requested -----*/
    if ?autosplit.hdlv                 /* splitting at this hdr?    */
      then if autobypass > 0           /*   yes, bypassing any?     */
        then if hdrcnt.hdlv>autobypass /*     yes, bypassed enough? */
          then call Split_File_Here    /*        yes, OK to split   */
          else nop                     /*        no, ignore split   */
        else call Split_File_Here      /*     no, so do the split   */
    if firsthead == '' then firsthead = SymbSub(headtext)
    /*----- header level-unique processing -----*/
    if hdlv = 0
      then do                          /* :H0 unique processing     */
        if datatype(hnum,'W') then _h0num=hnum; else _h0num=_h0num+1
        bodyprefix=BodyHd(bodyhd0,_h0num,bodyhd0x,(bodyhd0\=''|bodyhd0x\=''))
        end
      else do                          /* :H1, :H2, :H3, ... :Hx    */
        bodyprefix=''; headingnumber=''
        if hdlv=1 & ?appendix & ?showhdrnum then do
          if hnum\='' & hnum\='NONE'
            then apdxcnt = max(0,pos(hnum,alphauc)-1)
          apdxcnt = apdxcnt + 1
          end
        /*----- compute heading number (2.1.3..), if needed -----*/
        if \?frontm & \?backm then if hdlv <= numberh then do
          if datatype(hnum,'W')
            then headnum.hdlv=hnum; else headnum.hdlv=headnum.hdlv+1
          do i=hdlv+1 to toclimit; headnum.i=0; end i
          do i=toclimit to 1 by -1; if headnum.i\=0 then leave; end i
          temp1=''; do j=1 to i
            if j=1 & ?appendix
              then temp1=temp1||ChaptNum()'.'
              else temp1=temp1||headnum.j'.'
            end j
          if i=1 then temp1 = temp1'0.'
          headingnumber = left(temp1,max(length(temp1)-1,0))' '
          end
        /*----- :H1-specific stuff -----*/
        if hdlv > 1
          then bodyprefix = headingnumber /* this is :H2 or higher  */
          else do                         /* this is an :H1         */
            if ?fbc then parse value '0' with _figcapnum 1 _tcapnum
            select
              when ?appendix then do
                if apphd1 == nl then if apphd1x = ''
                  then apphd1 = deftext.!appendix
                  else apphd1 = ''
                if ?showhdrnum then temp2=ChaptNum(); else temp2=''
                bodyprefix=BodyHd(apphd1,temp2,apphd1x,?showhdrnum)
                end
              when ?backm | ?frontm then nop
              otherwise do
                if datatype(hnum,'W') then _h1num=hnum; else _h1num=_h1num+1
                select
                  when bodyhd1\='' | bodyhd1x\='' then temp2 = _h1num
                  when headingnumber \= '' then temp2 = headingnumber
                  otherwise temp2 = ''
                  end
                bodyprefix=BodyHd(bodyhd1,temp2,bodyhd1x,?showhdrnum)
                end
              end
            end
        end
    /*---- all :Hx headers -----*/
    if resid\=''
      then call ProcTag HtmlX(!a,'NAME="'resid'"')||anchortext'</A>',!force
    idtext = bodyprefix || headtext
    if bodyprefix = ''
      then refidtext = '"'headtext'"'
      else do
        bodyprefix = strip(bodyprefix)
        if right(bodyprefix,1) = '.'
          then bodyprefix = left(bodyprefix,length(bodyprefix)-1)
        refidtext = bodyprefix', "'headtext'"'
        end
    /*----- construct the HTML for the header -----*/
    parse value HTag(hdlv) with temp1 (x00) temp2 (x00)
    call ProcTag SetUpTag()temp1 ||,
         MakeXref(!hdref,headid,idtext,refidtext,_hnum,,hdlv) ||,
         temp2||SetUpTag(,2)
    end
 
  when TAGnameuc=='HDREF'                   /*----- :HDREF     -----*/
    then if ?tableflag & htmlrel=2          /* if in a HTML 2 table */
      then datastr=RefInTable(!hdref)       /* handle now, otherwise*/
      else call Handle_In_Pass2             /* handle in pass 2     */
 
  when wordpos(TAGnameuc,'IH1 IH2 IH3 I1 I2 I3')>0 /*- :IHx, :Ix ---*/
    then if ?index then do
      call SaveIndex TAGnameuc,TAGoptions,TAGtext,pass
      call ProcTag TAGstringall, !force
      end
 
  when TAGnameuc=='INDEX' then if ?indexfnd /*----- :INDEX     -----*/
    then do; indexlfile=currpartl; call ProcTag TAGstringall,!force; end
    else do
      if TAGtext = '' then TAGtext = deftext.!index
      call EvalTag TAGoptions; tempid=GetAttr('ID')
      if tempid = ''
        then do
          TAGoptions = 'ID='IDXname TAGoptions
          IDXname = !hdref || IDXname
          end
        else IDXname = !hdref || tempid
      if ?index then call Put_Buffer ':INDEX.', !lifo
      call Put_Buffer ':H1 B2HNUM=NO' TAGoptions'.'TAGtext||TAGresidual, !lifo
      TAGresidual=''; ?indexfnd=true
      end
 
  when TAGnameuc=='IREF' then if ?index then do /*--- :IREF    -----*/
    call SaveIndex TAGnameuc,TAGoptions,TAGtext,pass
    call ProcTag TAGstringall, !force
    end
 
  when TAGnameuc=='KWD' then do             /*----- :KWD       -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    call EvalTag TAGoptions; i=syndat.0 + 1; syndat.0=i
    syndat.i._text = SynData(TAGtext,'B')
    syndat.i._placement = SynPlace('DEF OPT REQ')
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    syndat.i._inside = syntax_container
    end
 
  when TAGnameuc=='L' then do               /*----- :L         -----*/
    call EvalTag TAGoptions; lid=word(GetAttr('LID',!uc),1)
    if ldesc.lid \= '' then do
      if _ldescnest = 0
        then _ldescnest = _ldescnest + 1
        else datastr = '</A>'
      datastr = datastr || ldesc.lid
      end
    datastr=datastr||TAGtext; if ?tagcheck then call TagNestS
    end
  when TAGnameuc=='EL' then do              /*----- :EL        -----*/
    if _ldescnest > 0 then datastr = '</A>'
    _ldescnest = max(0,_ldescnest-1)
    datastr=datastr||TAGtext; if ?tagcheck then call TagNestE
    end
 
  when TAGnameuc=='LBLBOX' then do          /*----- :LBLBOX    -----*/
    if ?tagcheck then call TagNestS ,,!nonest
    temp1=SetUpTag(); temp2=SetUpTag(,2)
    if htmlrel >= 3
      then do
        if listnest=0 then datastr=' WIDTH="100%"'; else datastr=''
        datastr = HtmlX(!table,Border(4) datastr) ||,
                  HtmlX(!tr) || HtmlX(!th,'ALIGN="LEFT"') ||,
                  temp1 || RevTag(!s) || SymbSub(TAGtext) ||,
                  ERevTag(!s) || temp2 || '</TH></TR>' ||,
                  HtmlX(!tr) || HtmlX(!td) || temp1 || RevTag(!s)
        end
      else datastr = '<P>'Pre()'<B>+' ||,
           left('---'SymbSub(TAGtext),linewidth.llcnt - 2,dash) ||,
           '+</B>'EPre()
    revnest.!lblbox=revnest; datastr=SetUpTag()||datastr
    end
  when TAGnameuc=='ELBLBOX' then do         /*----- :ELBLBOX   -----*/
    if ?tagcheck then call TagNestE
    if htmlrel >= 3
      then datastr=ERevTag(!s)||SetUpTag(,2)'</TD></TR></TABLE>' ||,
                   EndTableFont(revnest.!lblbox)
      else datastr='<BR>'Pre()'<B>+'copies(dash,linewidth.llcnt - 2) ||,
                   '+</B>'EPre()'<P>'
    datastr = datastr || SetUpTag(,2) || TAGtext
    end
 
  when TAGnameuc=='LDESC' then do           /*----- :LDESC     -----*/
    call EvalTag TAGoptions; id=GetAttr('ID')
    docid=GetAttr('DOCID',!uc); object=GetAttr('OBJECT',!uc)
    objtype=GetAttr('OBJTYPE',!uc); if objtype='' then objtype='HEAD'
    select
      when objtype='BOOK'  then object=''
      when objtype='FIG'   then objtype=!figref
      when objtype='HEAD'  then objtype=!hdref
      when objtype='SPOT'  then objtype=!spotref
      when objtype='TABLE' then objtype=!tref
      otherwise objtype = ''
      end
    if objtype \= ''                   /* can I handle this type?   */
      then if docid = ''               /*   yes, what kind of link? */
        then ldesc.id=':bhl type='objtype 'id='object'.' /* intradoc*/
        else if docdesc.docid = ''     /* interdoc, DOCDESC defined?*/
          then nop                     /*   no, ignore              */
          else if object = ''
            then ldesc.id = HtmlX(!a,'HREF="'docdesc.docid'"')
            else ldesc.id = HtmlX(!a,'HREF="'docdesc.docid'#'objtype||object'"')
    end
 
  when TAGnameuc=='LEDI' then do            /*----- :LEDI      -----*/
    call EvalTag TAGoptions; leditype=''
    leditext=GetAttr('TEXT'); headid=GetAttr('ID')
    do i=1 to words(ledicat) while leditype=''
      leditype = GetAttr(word(ledicat,i),!uc)
      end
    if leditype = '' then do
      call MsgOut !error 452, ,
          'Invalid or missing category!',TAGstringall,!recnumo
      leditext = '????'
      end
    if leditext='' then datastr=lerstemp.leditype; else datastr=leditext
    temp1 = datastr
    if datastr \= '' then datastr = '<STRONG>'datastr'</STRONG>'
    if headid \= '' then do            /* ID= specified?            */
      _hnum = _hnum + 1                /*   yes, generate anchor    */
      datastr = MakeXref(!hdref,headid,datastr,temp1,_hnum)
      end
    datastr = '<P>'datastr
    end
 
  when TAGnameuc=='LEN' then do             /*----- :LEN       -----*/
    saverec.!len.0=0; ?lenflag=true; lenopts=TAGoptions
    if TAGtext \= '' then call SaveRec !len,TAGtext
    if ?tagcheck then call TagNestS
    end
  when TAGnameuc=='ELEN' then do            /*----- :ELEN      -----*/
    ?lenflag=false; _hnum=_hnum+1; if ?tagcheck then call TagNestE
    call EvalTag lenopts; lenid=GetAttr('ID')
    headlev = lerstemp.!lehd
    lencnt.headlev=lencnt.headlev + 1
    do i = headlev+1 to toclimit; lencnt.i=0; end i
    select
      when ?autolensep & wordpos(lerssep,'NORMAL RULE')=0
        then call Split_File_Here
      when ?autolen.headlev            /* split this LEN stmt       */
        then if autobypass > 0         /*   yes, bypassing any?     */
          then if lencnt.headlev>autobypass /* yes, bypassed enough?*/
            then call Split_File_Here  /*        yes, split         */
            else nop                   /*         no, ignore split  */
          else call Split_File_Here    /*      no, split            */
      otherwise if lerstemp.999 \= ''
        then call ProcTag lerstemp.999
      end
    if saverec.!len.0 = 0
      then temp='Missing value'; else temp=saverec.!len.1
    call ProcTag HtmlX('H'headlev) ||,
         MakeXref(!hdref,lenid,temp,temp,_hnum,,headlev)'</H'headlev'>'
    if saverec.!len.0 > 1 then do
      call ProcTag '<STRONG>'
      do i = 2 to saverec.!len.0; call ProcTag saverec.!len.i; end
      call ProcTag '</STRONG>'
      end
    datastr=TAGtext; saverec.!len.0=0
    end
 
  when TAGnameuc=='LERSDEF' then call DefTag  /*--- :LERSDEF   -----*/
 
  when TAGnameuc=='LERS' then do            /*----- :LERS      -----*/
    if ?tagcheck then call TagNestS
    string=''; lerstemp. = ''; string2=ledicat
    do i = 1 by 1 while string2 \= ''
      parse var string2 lersvar string2; temp1='LERS'lersvar
      string = string lersvar"='"deftext.temp1"'"
      end
    call EvalTag string TAGoptions, 'LERSDEF', 'FORCE'
    string2 = ledicat
    do while string2 \= ''
      parse var string2 lersvar string2
      lerstemp.lersvar = GetAttr(lersvar)
      end
    lerssep=GetAttr('SEP',!uc); if lerssep='' then lerssep='NORMAL'
    if lerssep = 'RULE'
      then lerstemp.999=hrtag.10; else lerstemp.999='<P>'
    data=GetAttr('LEDIHD'); if \datatype(data,'W') then data=4
    lerstemp.!ledihd = data
    data=GetAttr('LEHD');   if \datatype(data,'W') then data=2
    lerstemp.!lehd   = data
    datastr=SetUpTag()
    end
  when TAGnameuc=='ELERS' then do           /*----- :ELERS     -----*/
    if ?tagcheck then call TagNestE
    datastr = SetUpTag(,2) || TAGtext
    end
 
  when TAGnameuc=='LI' then do              /*----- :LI        -----*/
    if ?tagcheck then if listnest=0 then call OutOfSeq !list
    listitem.listnest.!cnt = listitem.listnest.!cnt + 1
    if ?liref > 0 then do                   /* checking references? */
      call EvalTag TAGoptions; liid=GetAttr('ID') /* yes, got one?  */
      if liid \= '' then do; _linum=_linum+1      /*   yes, use it  */
        if listitem.listnest.!type='OL' & ?liref=2 /*ordered list?  */
          then do                                 /*   yes, create  */
            idtext=anchortext; reftext=''; jprev=''
            do i = listnest to 1 by -1 while listitem.i.!type='OL'
              j=listitem.i.!oltype; juc=translate(j)
              if reftext\='' & (j=jprev | j\='1') then reftext='.'reftext
              k=max(listitem.i.!cnt,1); jprev=j
              select
                when juc='1' then reftext = k || reftext
                when juc='A' then reftext = AlphaSeq(k,j='A') || reftext
                when juc='I' then reftext = RomanSeq(k,j='I') || reftext
                otherwise reftext = '?' || reftext
                end
              end
            end
          else do; idtext='<I>('liid')</I> '; reftext=idtext; end
        liid = MakeXref(!liref,liid,idtext,reftext,_linum)
        end
      end
    datastr = GenListItemEnd() || listitem.listnest.3 || liid ||,
              GenListItemStart() || TAGtext
    call SetListItemEnd listitem.listnest.4
    end
 
  when TAGnameuc=='LIBRARY' then do         /*----- :LIBRARY   -----*/
    ?titleflag=false; ?libraryflag=true; ?topicflag=false
    if TAGtext \= '' then call SaveRec !library,SymbSub(TAGtext)
    end
 
  when TAGnameuc=='LINES' then do           /*----- :LINES     -----*/
    call Stack2Write2; if ?tagcheck then call TagNestS ,,!nonest
    if ?lines
      then do; j='<BR>'; _BRcount=_BRcount+1; end
      else do; j=Pre() ; inwidth=0; ?linesflag=true; end
    call ProcTag SetUpTag()||j,!force; datastr=TAGtext
    end
  when TAGnameuc=='ELINES' then do          /*----- :ELINES    -----*/
    call Stack2Write2; if ?tagcheck then call TagNestE
    temp1=''; if ?lines    /* LINES = BR or PRE ? */
      then _BRcount = max(0,_BRcount-1)
      else do; temp1=EPre(); inwidth=0; ?linesflag=false; end
    datastr = TAGtext
    temp1=temp1||SetUpTag(,2); if temp1\='' then call ProcTag temp1,!force
    end
 
  when TAGnameuc=='LIREF'                   /*----- :LIREF     -----*/
    then if ?liref > 0                      /* process this?        */
      then if ?tableflag & htmlrel=2        /*   yes, if in a table,*/
        then datastr=RefInTable(!liref)     /* handle now, otherwise*/
        else call Handle_In_Pass2           /* handle in pass 2     */
      else nop
 
  when TAGnameuc=='LITDATA' then do         /*----- :LITDATA   -----*/
    call Stack2Write2; call EvalTag TAGoptions
    litname = GetAttr('NAME')
    if litname \= '' then do                /* imbedding a file?    */
      if sym.!namefile.litname \= ''        /*   yes, via NAMEFILE? */
        then litname = sym.!namefile.litname /*       yes, get name */
      call ImbedFile litname,TAGstringall,!recnumo
      call Put_Buffer ':ELITDATA.'
      end
    if ?tagcheck then call TagNestS ,,!nonest
    ?litdata=1; datastr=TAGtext; _BRcount=_BRcount+1
    if _PREcount=0 then datastr='<BR>'
    datastr = SetUpTag() || datastr
    end
  when TAGnameuc=='ELITDATA' then do        /*----- :ELITDATA  -----*/
    call Stack2Write2; if ?tagcheck then call TagNestE
    ?litdata=0; _BRcount = max(0,_BRcount-1)
    datastr = SetUpTag(,2) || TAGtext
    end
 
  when TAGnameuc=='LP'                      /*----- :LP        -----*/
    then if listnest>0 & listitem.listnest.!table
      then datastr=HtmlX(!tr) ||,
                   HtmlX(!td,'COLSPAN=2 ALIGN="LEFT" VALIGN="TOP"') || TAGtext
      else datastr='<P>'TAGtext
 
  when TAGnameuc=='MATCH' then do           /*----- :MATCH     -----*/
    if ?tagcheck then if \?questionflag then call OutOfSeq !question
    call EvalTag TAGoptions; questans=questans' 'GetAttr('ANSID',!uc)
    if ?choicedl
      then do; call ProcTag list.!dl.questdl.2; ?choicedl=false; end
    if ?questform & quest.qid.!form='MATCH'
      then call ProcTag '<BR>' ||,
                        HtmlX(!input,'TYPE="text" NAME="inp" SIZE="3"') ||,
                        blank || TAGtext
      else call ProcTag '<BR>____'blanks||TAGtext
    end
 
  when TAGnameuc=='MCDEF' then call DefTag  /*----- :MCDEF       ---*/
 
  when TAGnameuc=='MSG' then do             /*----- :MSG       -----*/
    if ?tagcheck then if \?mcflag then call OutOfSeq !mc
    temp1=SetUpTag(mctagname,1) || mc.0 || RevTag(!s)
    temp2=ErevTag(!s) || mc.1 || SetUpTag(mctagname,2)
    select
      when mc.!style = 'BOX' then do
        datastr = mc.!e'<P>'HtmlX(!table,Border(5)) ||,
                  HtmlX(!tr) || HtmlX(!td) || HtmlX(!table) || HtmlX(!tr)
        if mc.!msgno \= ''
          then datastr=datastr || HtmlX(!td,'VALIGN="TOP"') || temp1 ||,
                       '<STRONG>'mc.!msgno'</STRONG>'temp2'</TD>'
        datastr = datastr'<TD>'temp1'<STRONG>'TAGtext
        mc.!e = '</STRONG>'temp2'</TD></TR></TABLE></TR></TD></TABLE>'
        end
      when mc.!style = 'LBLBOX' then do
        datastr = mc.!e'<P>'HtmlX(!table,Border(6))
        if mc.!msgno \= ''
          then datastr=datastr || HtmlX(!tr) || HtmlX(!td,'VALIGN="TOP"') ||,
                       temp1'<STRONG>'mc.!msgno'</STRONG>'temp2'</TD></TR>'
        datastr = datastr || HtmlX(!tr) || HtmlX(!td) || temp1'<STRONG>'TAGtext
        mc.!e = '</STRONG>'temp2'</TD></TR></TABLE>'
        end
      when mc.!style = 'RULE' then do
        datastr = mc.!e'<P>'hrtag.4'<BR>' || HtmlX(!table) || HtmlX(!tr)
        if mc.!msgno \= ''
          then datastr=datastr || HtmlX(!td,'VALIGN="TOP"') || temp1 ||,
                       '<STRONG>'mc.!msgno'</STRONG>'temp2'</TD>'
        datastr = datastr || HtmlX(!td) || temp1'<STRONG>'TAGtext
        mc.!e = '</STRONG>'temp2'</TD></TR></TABLE>'
        end
      otherwise do
        datastr = mc.!e'<P>'HtmlX(!table) || HtmlX(!tr)
        if mc.!msgno \= ''
          then datastr=datastr || HtmlX(!td,'VALIGN="TOP"') || temp1 ||,
                       '<STRONG>'mc.!msgno'</STRONG>'temp2'</TD>'
        datastr = datastr || HtmlX(!td) || temp1'<STRONG>'TAGtext
        mc.!e = '</STRONG>'temp2'</TD></TR></TABLE>'
        end
      end
    mc.!msgno = ''
    end
 
  when wordpos(TAGnameuc,mctags)>0 then do  /*----- msg & codes ----*/
    if ?tagcheck then if \?mcflag then call OutOfSeq !mc
    datastr = mc.!e||mc.!compact'<STRONG>'mc.TAGnameuc ||,
              '&colon. </STRONG>'TAGtext
    mc.!e = ''
    end
 
  when TAGnameuc=='MSGL' | TAGnameuc='CODEL' then do /*:MSGL/:CODEL */
    /*  mc.!compact - tags for element spacing  */
    /*  mc.!e       - End of previous element   */
    /*  mc.!msgno   - :MSGNO. value (if any)    */
    /*  mc.!style   - STYLE= value              */
    /*  mc.!indent  - INDENT= value             */
    /*  mc.!tsize   - TSIZE= value              */
    /*  mc.0/mc.1   - SCALE= start/end values   */
    if ?tagcheck then call TagNestS ,,!nonest
    call EvalTag TAGoptions, 'MCDEF'
    mc.=''; ?mcflag=true; mctagname=TAGnameuc
    do i = 1 to words(mctags)
      j=word(mctags,i); mc.j=GetAttr(j)
      if mc.j='' then do; temp1='MC'j; mc.j=deftext.temp1; end
      end
    if GetAttr('COMPACT') \= ''
      then mc.!compact='<BR>'; else mc.!compact='<P>'
    mc.!style=GetAttr('STYLE',!uc)
    if wordpos(mc.!style,'SPACE BOX LBLBOX RULE')=0 | htmlrel=2
      then mc.!style = 'SPACE'
    mc.!tsize=GetAttr('TSIZE'); mc.!indent=GetAttr('INDENT')
    parse value Scale() with mc.0 (nl) mc.1
    datastr = SetUpTag()||mc.0
    end
  when TAGnameuc=='EMSGL' |,                /*----- :EMSGL/:ECODEL -*/
       TAGnameuc='ECODEL' then do
    if ?tagcheck then call TagNestE
    datastr=mc.!e||SetUpTag(,2)||mc.1
    mc.=''; ?mcflag=false; mctagname=''
    end
 
  when TAGnameuc=='MSGNO' then do           /*----- :MSGNO     -----*/
    if ?tagcheck then if \?mcflag then call OutOfSeq !mc
    mc.!msgno = TAGtext
    end
 
  when TAGnameuc=='NOTE' then do            /*----- :NOTE      -----*/
    call EvalTag TAGoptions
    parse value GetAttr('TEXT',,1) with ?def notetext
    if \?def then notetext = deftext.!note
    if notetext\='' then notetext='<B>'notetext': </B>'
    datastr = '<P>'notetext || TAGtext
    end
 
  when TAGnameuc=='NOTEL' then do           /*----- :NOTEL     -----*/
    call EvalTag TAGoptions; compact=(GetAttr('COMPACT')\='')
    call StartNewList
    do k = 1 to 4; listitem.listnest.k = list.TAGnameuc.compact.k; end
    parse value GetAttr('TEXT',,1) with ?def notetext
    if \?def then notetext = deftext.!notel
    if notetext\='' then notetext='<B>'notetext': </B>'
    datastr = SetUpTag()'<P>'notetext || listitem.listnest.1
    if ?tagcheck then call TagNestS
    end
  when TAGnameuc=='ENOTEL' then do          /*----- :ENOTEL    -----*/
    datastr=GenListItemEnd()||listitem.listnest.2||SetUpTag(,2)||TAGtext
    call EndExistingList
    if ?tagcheck then call TagNestE
    end
 
  when TAGnameuc=='NT' then do              /*----- :NT        -----*/
    call EvalTag TAGoptions; revnest.!nt=revnest
    parse value GetAttr('TEXT',,1) with ?def notetext
    if \?def then notetext = deftext.!nt
    if notetext\='' then notetext='<B>'notetext':</B>'
    temp1=SetUpTag(); temp2=SetUpTag(,2)
    if htmlrel = 2
      then datastr='<P>'notetext'<BLOCKQUOTE>'TAGtext
      else datastr=HtmlX(!table) || HtmlX(!tr) ||,
                   HtmlX(!td,'ALIGN="LEFT" VALIGN="TOP"') || temp1 ||,
                   RevTag(!s) || notetext || ERevTag(!s)  || temp2 ||,
                   '</TD>'HtmlX(!td,'ALIGN="LEFT" VALIGN="TOP"') ||,
                   temp1 || RevTag(!s) || TAGtext
    if ?tagcheck then call TagNestS
    datastr = SetUpTag() || datastr
    end
  when TAGnameuc=='ENT' then do             /*----- :ENT       -----*/
    temp2=SetUpTag(,2)
    if htmlrel = 2
      then datastr = '</BLOCKQUOTE>'TAGtext
      else datastr = ERevTag(!s)||temp2'</TD></TR></TABLE>' ||,
                     TAGtext||EndTableFont(revnest.!nt)
    datastr = datastr || temp2
    if ?tagcheck then call TagNestE
    end
 
  when TAGnameuc=='OPER' then do            /*----- :OPER      -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    call EvalTag TAGoptions; i=syndat.0 + 1; syndat.0=i
    syndat.i._text = SymbSub(TAGtext)
    syndat.i._placement=SynPlace('DEF OPT REQ')
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    syndat.i._inside = syntax_container
    end
 
  when TAGnameuc=='PK' then do              /*----- :PK        -----*/
    call EvalTag TAGoptions; _pknum=_pknum+1
    if ?tagcheck then call TagNestS
    if GetAttr('DEF') = ''
      then do;datastr='<STRONG>'TAGtext;   epkstr._pknum='</STRONG>';    end
      else do;datastr='<STRONG><U>'TAGtext;epkstr._pknum='</U></STRONG>';end
    datastr = SetUpTag() || datastr
    end
  when TAGnameuc=='EPK' then do             /*----- :EPK       -----*/
    datastr=epkstr._pknum||SetUpTag(,2)||TAGtext; _pknum=max(_pknum-1,0)
    if ?tagcheck then call TagNestE
    end
 
  when TAGnameuc=='PROLOG'  then ?prolog=1  /*----- :PROLOG    -----*/
  when TAGnameuc=='EPROLOG' then ?prolog=0  /*----- :EPROLOG   -----*/
 
  when TAGnameuc=='PTOC'                    /*----- :PTOC      -----*/
    then if ptoclevel >= 0 then do
      call EvalTag TAGoptions
      if GetAttr('MANUAL')='' & lasthdlv\='' then do
        parse value GetAttr('LEVELS') with '*' i .
        parse value i ptoclevel with ptocleast .
        ptoclfile=currpartl; ptocmost=lasthdlv; _PTOCcnt=_PTOCcnt+1
        call ProcTag ':PTOC MOST='ptocmost 'LEAST='ptocleast 'PART='bookpart,
                           'INDEX='saverec.!toc.0+1'.', !force
        datastr = TAGtext
        end
      end
 
  when TAGnameuc=='QITEM' then do           /*----- :QITEM     -----*/
    if ?tagcheck then if \?questionflag then call OutOfSeq !question
    call EvalTag TAGoptions; quest.qid.!ans=quest.qid.!ans' 'GetAttr('ANS')
    if ?questform & quest.qid.!form='ORDER'
      then call ProcTag '<BR>' ||,
                        HtmlX(!input,'TYPE="text" NAME="inp" SIZE="3"') ||,
                        blank || TAGtext
      else call ProcTag '<BR>____'blanks||TAGtext
    end
 
  when TAGnameuc=='QREF'                    /*----- :QREF      -----*/
    then if ?tableflag & htmlrel=2          /* if in a HTML 2 table */
      then datastr=RefInTable(!qref)        /* handle now, otherwise*/
      else call Handle_In_Pass2             /* handle in pass 2     */
 
  when TAGnameuc=='QUALIF' then do          /*----- :QUALIF    -----*/
    qualiflab = SymbSub(TAGtext)
    if ?tagcheck then call TagNestS ,,!nonest
    datastr = SetUpTag()'<P>'Pre()'<B>+' ||,
              center(qualiflab,linewidth.llcnt - 2,dash) ||,
              '+</B>'EPre()||Br()
    end
  when TAGnameuc=='EQUALIF' then do         /*----- :EQUALIF   -----*/
    if ?tagcheck then call TagNestE
    datastr = '<P>'Pre()'<B>+' ||,
              center('End of' qualiflab,linewidth.llcnt - 2,dash) ||,
              '+</B>'EPre()'<P>'SetUpTag(,2)||TAGtext
    end
 
  when TAGnameuc=='QUESTION' then do        /*----- :QUESTION  -----*/
    call EvalTag TAGoptions; qid=GetAttr('ID')
    if ?tagcheck then call TagNestS; ?questionflag=true
    quest.qid.!dingbat=GetAttr('DINGBAT')
    quest.qid.!form=GetAttr('FORM',!uc)
    questans          = ''       /* temp answer string for MC/MATCH */
    quest.qid.!ans    = ''       /* answer string sent to CGI       */
    quest.qid.!anstxt = ''       /* answer string sent to :answer   */
    if quest.qid.!dingbat = ''   /* set dingbat or question number  */
      then do; _questnum=_questnum+1; quest.qid.!dingbat=_questnum'.'; end
    /* build info for :ANSREF. tag - used by :ANSWER. in Pass 2 */
    quest.qid.!ansref = MakeXref(!ansref,qid,anchortext, ,
                         deftext.qansref quest.qid.!dingbat)
    /*----- start building output -----*/
    temp1=SetUpTag(); if temp1 \= '' then call ProcTag temp1
    if ?questform then do
      call ProcTag HtmlX(!form,'METHOD="'questmethod'" ACTION="'questurl'"'),
          HtmlX(!input,'TYPE="hidden" NAME="form" VALUE="'quest.qid.!form'"')
      call ProcTag HtmlX(!input,'TYPE="hidden" NAME="id" VALUE="'qid'"'),
          HtmlX(!input,'TYPE="hidden" NAME="dingbat"',
               'VALUE="'quest.qid.!dingbat'"')
      if ansfilel \= '' then call ProcTag ,
          HtmlX(!input,'TYPE="hidden" NAME="optdata" VALUE="'ansfilel'"')
      end
    if ?dlfmt & htmlrel>=3 then questdl=3; else questdl=1
    call ProcTag list.!dl.questdl.1 || list.!dl.questdl.3 || RevTag(!s)
    /* Build Xrefs for :qref. and :answer. tags */
    call ProcTag MakeXref(!qref,qid,quest.qid.!dingbat,,
                          deftext.qqref quest.qid.!dingbat),
                 MakeXref(!answer,qid,anchortext,quest.qid.!dingbat)
    call ProcTag ERevTag(!s) || list.!dl.questdl.4 ||,
                 list.!dl.questdl.5 || RevTag(!s)
    /*----- Start-of-question processing for each FORM= type -----*/
    select
      when quest.qid.!form = 'FILLIN' then nop   /*-- FORM=FILLIN --*/
      when quest.qid.!form = 'MATCH'  then nop   /*-- FORM=MATCH  --*/
      when quest.qid.!form = 'MC'                /*-- FORM=MC     --*/
        then questans = GetAttr('ANSID',!uc)
      when quest.qid.!form = 'ORDER'  then nop   /*-- FORM=ORDER  --*/
      when quest.qid.!form = 'TF'     then do    /*-- FORM=TF     --*/
        parse value left(GetAttr('ANS',!uc),1),
              with  quest.qid.!ans 1 quest.qid.!anstxt
        if ?questform
          then call ProcTag ,
                HtmlX(!input,'TYPE="radio" NAME="inp" VALUE="T"') ||,
                'True' || blanks,
                HtmlX(!input,'TYPE="radio" NAME="inp" VALUE="F"')'False<P>'
          else call ProcTag 'T'blanks'F'blanks
        end
      otherwise nop
      end
    end
  when TAGnameuc=='EQUESTION' then do       /*----- :EQUESTION -----*/
    if ?tagcheck then call TagNestE; ?questionflag=false
    if ?choicedl
      then do; call ProcTag list.!dl.questdl.2; ?choicedl=false; end
    quest.qid.!ans = space(quest.qid.!ans)
    select
      when quest.qid.!form='FILLIN' then do      /*-- FORM=FILLIN --*/
        quest.qid.!anstxt = word(quest.qid.!ans,1)
        do eqi=2 to words(quest.qid.!ans)
          quest.qid.!anstxt = quest.qid.!anstxt'<BR>' ||,
                              word(quest.qid.!ans,eqi)
          end
        end
      when quest.qid.!form='MATCH' |,            /*-- FORM=MC     --*/
           quest.qid.!form='MC' then do          /*-- FORM=MATCH  --*/
        /* map each item in questans, to an item in chans.choiceid */
        eqw = word(questans,1)
        quest.qid.!anstxt=chans.eqw; quest.qid.!ans=chans.eqw
        do eqi=2 to words(questans)
          eqw = word(questans,eqi)
          quest.qid.!anstxt = quest.qid.!anstxt',' chans.eqw
          quest.qid.!ans    = quest.qid.!ans       chans.eqw
          end
        end
      when quest.qid.!form='ORDER' then do       /*-- FORM=ORDER  --*/
        quest.qid.!anstxt = word(quest.qid.!ans,1)
        do eqi=2 to words(quest.qid.!ans)
          quest.qid.!anstxt = quest.qid.!anstxt',',
                              word(quest.qid.!ans,eqi)
          end
        end
      when quest.qid.!form='TF' then nop         /*-- FORM=TF     --*/
      otherwise nop
      end
    if ?questform then do
      call ProcTag '<BR>' ||,
                   HtmlX(!input,'TYPE="SUBMIT" VALUE="Send Answer"') ||,
                   HtmlX(!input,'TYPE="RESET"') ||,
                   HtmlX(!input,'TYPE="SUBMIT" NAME="help" VALUE="Help"')
      select
        when ?questans = 0 then nop
        when ?questans = 1 then call ProcTag,
             HtmlX(!input,'TYPE="HIDDEN" NAME="ans" VALUE="'quest.qid.!ans'"')
        otherwise call WrtLine ansfilep,,
             quest.qid.!form':'qid':'quest.qid.!dingbat':'quest.qid.!ans
        end
      end
    call ProcTag list.!dl.questdl.2
    if ?questform then call ProcTag '</FORM>'
    datastr = datastr || SetUpTag(,2) || TAGtext
    end
 
  when TAGnameuc=='RDEF'                    /*----- :RDEF      -----*/
    then do; TAGnameuc='TDEF'; call DefTag; end
 
  when TAGnameuc=='REPSEP' then do          /*----- :REPSEP    -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    call EvalTag TAGoptions; i=syndat.0 + 1; syndat.0=i
    syndat.i._text = SynData(TAGtext,SynFont())
    syndat.i._placement = SynPlace('OPT REQ')
    syndat.syntax_container._repsep = i
    syndat.i._inside = syntax_container
    end
 
  when TAGnameuc=='REVISION' then do        /*----- :REVISION  -----*/
    call EvalTag TAGoptions
    if GetAttr('RUN',!uc)='YES' then do
      id = GetAttr('ID',!uc)
      ?revision.id=true; revisionchar.id=GetAttr('CHAR')
      end
    end
 
  when TAGnameuc=='REV'|TAGnameuc=='EREV' then do /*-- :REV/:EREV --*/
    call EvalTag TAGoptions; refid=GetAttr('REFID',!uc)
    if ?revision.refid
      then if TAGnameuc = 'REV'
        then do
          if ?tagcheck then call TagNestS TAGitself 'REFID='refid,,!nonest
          revnest=revnest+1
          revchar.revnest=revisionchar.refid; revid.revnest=refid
          ?revprop.revnest = revprop.refid
          spi='b2hrevchar'; sym.!amp.spi=revchar.revnest
          if ( ?tableflag & row=0 ) |,
             ( listnest>0 & listitem.listnest.!table & listitem.listnest.!cnt=0)
            then datastr=TAGtext
            else datastr=SymbSub(rev.refid)||TAGtext
          end
        else do
          if ?tagcheck then call TagNestE TAGitself 'REFID='refid
          datastr=SymbSub(erev.refid)||TAGtext; revnest=max(0,revnest-1)
          spi='b2hrevchar'; sym.!amp.spi=revchar.revnest
          end
      else datastr = TAGtext
    end
 
  when wordpos(TAGnameuc,'ROW THD BHTFT')>0 /*-- :ROW/:BHTFT/:THD --*/
   then do
    if ?tagcheck then do
      if TAGnameuc = 'THD' then call TagNestS ,,!nonest
      if \?tableflag
        then if TAGnameuc\='BHTFT' then call OutOfSeq !table
      end
    call Stack2Write2
    call EvalTag TAGoptions, 'TDEF'; rowrefid=GetAttr('REFID')
    ?tablethisrowtemp = ( GetAttr('TEMP')\='' )
    if htmlrel=2 & row>0 & col>0 then do
      if colEHP.col\='' then call Write2Temp2 colEHP.col
      _BRcount = max(0,_BRcount-colconcat.col)
      end
    /*----- not first row and different than before ----*/
    if row>0 & (?tableprevrowtemp|?tablethisrowtemp|rowrefid\='') then do
      select
        when htmlrel = 2 then do; call TablePrefix; call TableFormat
          parse value 0 with row 1 col rowcol. frameline hdrline
          end
        when htmlrel >= 3 then datastr = GenRowEnd()
        otherwise nop
        end
      do i = 1 to numcols_physical; colwidthphys_prev.i=colwidthphys.i; end
      numcols_physical_prev = numcols_physical
      end
    /*----- proceed with evaluating *this* row -----*/
    select
      when TAGnameuc='BHTFT' then ?tft=true
      when TAGnameuc='THD'   then ?thd=true
      otherwise if htmlrel>=3 then parse value false with ?thd 1 ?tft
      end
    select
      when htmlrel = 2 then select
        when TAGnameuc='ROW'   then nop
        when TAGnameuc='BHTFT' then do; i=row+1; rowcol.i.1=''; end
        when TAGnameuc='THD'   then row=0
        otherwise nop
        end
      when htmlrel >= 3 then datastr=datastr||GenRowEnd()||GenRowStart()
      otherwise nop
      end
    /*----- restore settings if previous row was a "temp" row -----*/
    if ?tableprevrowtemp then do
      numcols_physical = numcols_physical_temp
      numcols_logical  = numcols_logical_temp
      do i = 1 to numcols_physical_temp
        colwidthphys.i    = colwidthphys_temp.i
        colwidthphyspct.i = colwidthphyspct_temp.i
        end
      do i = 1 to numcols_logical_temp
        colalignh.i=colalignh_temp.i; colshade.i  =colshade_temp.i
        colalignv.i=colalignv_temp.i; tblcolspan.i=tblcolspan_temp.i
        colHP.i    =colHP_temp.i    ; tblrowspan.i=tblrowspan_temp.i
        colEHP.i   =colEHP_temp.i   ; tblcolstrt.i=tblcolstrt_temp.i
        colconcat.i=colconcat_temp.i; tblrowstrt.i=tblrowstrt_temp.i
        colwidthlogpct.i = colwidthlogpct_temp.i
        end
      end
    /*----- save settings if this row is a "temp" row -----*/
    if ?tablethisrowtemp then do
      numcols_physical_temp = numcols_physical
      numcols_logical_temp  = numcols_logical
      do i = 1 to numcols_physical
        colwidthphys_temp.i    = colwidthphys.i
        colwidthphyspct_temp.i = colwidthphyspct.i
        end
      do i = 1 to numcols_logical
        colalignh_temp.i=colalignh.i; colshade_temp.i  =colshade.i
        colalignv_temp.i=colalignv.i; tblcolspan_temp.i=tblcolspan.i
        colHP_temp.i    =colHP.i    ; tblrowspan_temp.i=tblrowspan.i
        colEHP_temp.i   =colEHP.i   ; tblcolstrt_temp.i=tblcolstrt.i
        colconcat_temp.i=colconcat.i; tblrowstrt_temp.i=tblrowstrt.i
        colwidthlogpct_temp.i = colwidthlogpct.i
        end
      end
    ?tableprevrowtemp = ?tablethisrowtemp
    /*----- evaluate new parameters if REFID= specified -----*/
    if rowrefid \= '' then do
      call SetColumns; call SetAlignH; call SetAlignV
      call SetHP; call SetShade; call SetConcat
      end
    /*----- prepare for following cells (if any) -----*/
    col=0; row=row+1; defcelldata=''; tblphysrow=1
    end
  when TAGnameuc=='ETHD'                    /*----- :ETHD      -----*/
    then do; datastr=TAGtext; if ?tagcheck then call TagNestE; end
 
  when TAGnameuc=='SCHDATE' then do         /*----- :SCHDATE   -----*/
    call EvalTag TAGoptions
    listref=GetAttr('LISTREF',!uc); if listref='' then listref='@'
    parse value Scale() with temp1 (nl) temp2
    temp1=SetUpTag()  || temp1 || RevTag(!s)
    temp2=ErevTag(!s) || temp2 || SetUpTag(,2)
    sid = word(listref,1)
    if sched.sid.99999 = ''
      then call MsgOut !warning 417,':SCHEDULE LISTID='sid,
                       'not defined prior to :SCHDATE', !recnumo
      else do
        parse var sched.sid.99999 sacthdr (nl) scmthdr (nl) scmtsize (nl)
        acthd=GetAttr('ACTHD'); if acthd='' then acthd=sacthdr
        cmthd=GetAttr('CMTHD'); if cmthd='' then cmthd=scmthdr
        if cmthd='' then cmthd = '<BR>'
        cmtsize = HorizWidth(GetAttr('CMTSIZE'))
        if cmtsize = 0 then cmtsize = ''
        if cmtsize = '' then cmtsize = scmtsize
        ?cmt = ( sched.sid.99998 = 1 )
        select
          /*----- generate HTML 3 table for schedule -----*/
          when htmlrel >= 3 then do
            if temp1\='' then call ProcTag temp1,!force
            call ProcTag HtmlX(!table,Border(7)) || HtmlX(!tr) ||,
                         HtmlX(!th,'ROWSPAN="2" VALIGN="TOP"') ||,
                         temp1 || acthd || temp2'</TH>',!force
            if ?cmt
              then call ProcTag HtmlX(!th,'ROWSPAN="2" VALIGN="TOP"') ||,
                                temp1 || cmthd || temp2'</TH>',!force
            call ProcTag HtmlX(!th,'COLSPAN="2"') ||,
                         temp1'Projected'temp2'</TH>' ||,
                         HtmlX(!th,'COLSPAN="2"') ||,
                         temp1'Actual'temp2'</TH></TR>',!force
            call ProcTag HtmlX(!tr)||,
                         HtmlX(!th)||temp1'Start'temp2'</TH>' ||,
                         HtmlX(!th)||temp1'End'temp2'</TH>'   ||,
                         HtmlX(!th)||temp1'Start'temp2'</TH>' ||,
                         HtmlX(!th)||temp1'End'temp2'</TH>'   ||,
                         '</TR>',!force
            do i = 1 to words(listref)
             sid = word(listref,i)
             do j = 1 to sched.sid.0
              parse value sched.sid.j,
                    with atxt (nl) ctxt (nl) ps (nl) pe (nl) as (nl) ae (nl)
              if ?cmt
                then k = HtmlX(!td,'VALIGN=TOP') ||,
                         temp1 || ctxt || temp2'</TD>'
                else k = ''
              call ProcTag HtmlX(!tr,'VALIGN="TOP"') ||,
                           HtmlX(!td)||temp1||atxt||temp2'</TD>'k, !force
              call ProcTag HtmlX(!td,'NOWRAP')||temp1||ps||temp2'</TD>' ||,
                           HtmlX(!td,'NOWRAP')||temp1||pe||temp2'</TD>', !force
              call ProcTag HtmlX(!td,'NOWRAP')||temp1||as||temp2'</TD>'||,
                           HtmlX(!td,'NOWRAP')||temp1||ae||temp2'</TD>'||,
                           '</TR>', !force
              end
             end
            call ProcTag '</TABLE>', !force
            if temp2\='' then call ProcTag temp2,!force
            end
          /*----- generate HTML 2 table for schedule -----*/
          otherwise do
            if temp1\='' then call Put_Buffer '.*B2H HTML' temp1
            if ?cmt
              then if datatype(scmtsize,'N')
                     then k = '*' scmtsize
                     else k = '3* 2*'
              else k = '*'
            call Put_Buffer ":table cols='"k,
                            max(sched.sid.!ps,9) max(sched.sid.!pe,9),
                            max(sched.sid.!as,6) max(sched.sid.!ae,6)"'."
            if ?cmt then k = ':c.'cmthd; else k = ''
            call Put_Buffer ':thd.:c.'acthd || k,
                            ':c.Projected Start:c.Projected End',
                            ':c.Actual Start:c.Actual End:ethd.'
            do i = 1 to words(listref)
             sid = word(listref,i)
             do j = 1 to sched.sid.0
              parse value sched.sid.j,
                    with atxt (nl) ctxt (nl) ps (nl) pe (nl) as (nl) ae (nl)
              call Put_Buffer ':row.:c.'atxt
              if ?cmt then call Put_Buffer ':c.'ctxt
              call Put_Buffer ':c.'ps':c.'pe':c.'as':c.'ae
              end
             end
            call Put_Buffer ':etable.'
            if temp2\='' then call Put_Buffer '.*B2H HTML' temp2
            end
          end
        end
    end
 
  when TAGnameuc=='SCHDEF' then call DefTag /*----- :SCHDEF    -----*/
 
  when TAGnameuc=='SCHEDULE' then do        /*----- :SCHEDULE  -----*/
    call EvalTag TAGoptions, 'SCHDEF'; cmthd=GetAttr('CMTHD')
    acthd   = GetAttr('ACTHD'); if acthd='' then acthd=deftext.!schedacthd
    schedid = GetAttr('LISTID',!uc); if schedid='' then schedid='@'
    cmtsize = HorizWidth(GetAttr('CMTSIZE'))
    if cmtsize = 0 then cmtsize = ''
    sched.schedid.99999 = acthd || nl || cmthd || nl || cmtsize || nl
    sched.schedid.99998 = ( cmthd \= '' )
    parse value 0,
          with  sched.schedid.0 1 sched.schedid.!ps 1 sched.schedid.!pe,
                1 sched.schedid.!as 1 sched.schedid.!ae
 
    sched.schedid.0=0; if ?tagcheck then call TagNestS
    end
  when TAGnameuc=='ESCHEDULE'               /*----- :ESCHEDULE -----*/
    then do; datastr=TAGtext; if ?tagcheck then call TagNestE; end
 
  when TAGnameuc=='SCHI' then do            /*----- :SCHI      -----*/
    call EvalTag TAGoptions; cmt=GetAttr('CMT')
    if cmt \= '' then sched.schedid.99998 = 1
    if cmt = ''  then cmt = '<BR>'
    if TAGtext = '' then TAGtext = '<BR>'
    parse value 0 with j ps pe as ae
    do i = 0 by 1
      if i = 0
        then do
          s = GetAttr('PSTART'); if s = '' then iterate
          e = GetAttr('PEND')
          end
        else do
          s = GetAttr('PSTART'i); if s = '' then leave
          e = GetAttr('PEND'i)
          end
      j = j + 1
      sched.schedid.!ps = max(sched.schedid.!ps,length(s))
      sched.schedid.!pe = max(sched.schedid.!pe,length(e))
      if htmlrel=2
        then do; ps=ps||s'<BR>'; pe=pe||e'<BR>'; end
        else do; ps=ps||s'<BR>'; pe=pe||e'<BR>'; end
      end
    if j = 0 then parse value '<BR>' with ps 1 pe
    j = 0
    do i = 0 by 1
      if i = 0
        then do
          s = GetAttr('ASTART'); if s = '' then iterate
          e = GetAttr('AEND')
          end
        else do
          s = GetAttr('ASTART'i); if s = '' then leave
          e = GetAttr('AEND'i)
          end
      e = subword(e,1,2)
      j = j + 1
      sched.schedid.!as = max(sched.schedid.!as,length(s))
      sched.schedid.!ae = max(sched.schedid.!ae,length(e))
      as = as || s'<BR>'; ae = ae || e'<BR>'
      end
    if j = 0 then parse value '<BR>' with as 1 ae
    k = sched.schedid.0 + 1
    sched.schedid.0 = k
    sched.schedid.k = TAGtext || nl || cmt || nl ||,
                      ps || nl || pe || nl || as || nl || ae || nl
    end
 
  when TAGnameuc=='SCRDEF' then call DefTag /*----- :SCRDEF    -----*/
 
  when TAGnameuc=='SCREEN' then do          /*----- :SCREEN    -----*/
    call EvalTag TAGoptions, 'SCRDEF';
    parse value Scale() with temp1 (nl) temp2
    temp1=SetUpTag()||temp1; escreenstr=temp2||SetUpTag(,2)
    llcnt=llcnt+1; linewidth.llcnt=max(80,HorizWidth(GetAttr('WIDTH')))
    if htmlrel=2 | \?screenshade
      then call ProcTag temp1||Pre(), !force
      else call ProcTag temp1||HtmlX(!table,shade.!screen) ||,
                        HtmlX(!tr) || HtmlX(!td) ||,
                        temp1|| RevTag(!s) || Pre(), !force
    call ProcTag '+'copies(dash,linewidth.llcnt)'+', !force
    ?screenflag=true; revnest.!screen=revnest
    datastr=TAGtext; if ?tagcheck then call TagNestS ,,!nonest
    end
  when TAGnameuc=='ESCREEN' then do         /*----- :ESCREEN   -----*/
    if htmlrel=2 | \?screenshade
      then datastr = EPre()||escreenstr
      else datastr = EPre()||ERevTag(!s)||escreenstr'</TD></TR></TABLE>'||,
                     EndTableFont(revnest.!screen)||escreenstr
    call ProcTag '+'copies(dash,linewidth.llcnt)'+'datastr, !force
    ?screenflag=false; llcnt=max(llcnt-1,1)
    datastr=TAGtext; if ?tagcheck then call TagNestE
    end
 
  when TAGnameuc=='SEP' then do             /*----- :SEP       -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    call EvalTag TAGoptions; i=syndat.0 + 1; syndat.0=i
    syndat.i._text = SynData(TAGtext,SynFont())
    syndat.i._placement = SynPlace('OPT REQ')
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    syndat.i._inside = syntax_container
    end
 
  when TAGnameuc=='SPOT' then do            /*----- :SPOT      -----*/
    call EvalTag TAGoptions;xreftext=GetAttr('XREFTEXT');_spotnum=_spotnum+1
    if xreftext = ''
      then datastr = MakeXref(!spotref, GetAttr('ID'), ,
           '<I>('deftext.spot1||_spotnum'.)</I>', ,
           deftext.spot2||_spotnum, _spotnum)
      else datastr = MakeXref(!spotref, GetAttr('ID'), ,
           anchortext, xreftext, _spotnum)
    datastr = datastr || TAGtext
    end
 
  when TAGnameuc=='SPOTREF'                 /*----- :SPOTREF   -----*/
    then if ?tableflag & htmlrel=2          /* if in a HTML 2 table */
      then datastr=RefInTable(!spotref)     /* handle now, otherwise*/
      else call Handle_In_Pass2             /* handle in pass 2     */
 
  when TAGnameuc=='SYNDEF' then call DefTag /*----- :SYNDEF    -----*/
 
  when TAGnameuc=='SYNNT' then do           /*----- :SYNNT     -----*/
    if ?tagcheck then do
      call TagNestS ,,!nonest
      if \?syntaxflag then call OutOfSeq !syntax
      end
    call EvalTag TAGoptions; synnt_id=GetAttr('ID'); _synnt=_synnt+1
    sycallout=GetAttr('CALLOUT'); if sycallout=='' then sycallout=_synnt
    if synnt_id = ''
      then do
        synnt_id=_synnt; call Stack2Write2
        call Put_Buffer ":SYNNTREF REFID='"synnt_id"'."TAGresidual
        TAGresidual = ''
        end
    synnt.synnt_id.0=0; synnt.synnt_id=sycallout
    synnt_ids = synnt_ids synnt_id; ?synntflag=true; datastr=TAGtext
    end
  when TAGnameuc=='ESYNNT' then do          /*----- :ESYNNT    -----*/
    if ?tagcheck then call TagNestE
    ?synntflag=false; datastr=TAGtext
    end
 
  when TAGnameuc=='SYNNTREF' then do        /*----- :SYNNTREF  -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    call EvalTag TAGoptions; synnt_refid=GetAttr('REFID')
    if datatype(synnt.synnt_refid.0,'N')
      then do
        i = syndat.0
        syndat.i._text = syndat.i._text||SynData('('synnt.synnt_refid')','I')
        end
      else call Msgout !error 463, 'Syntax note reference not found!', ,
                       TAGstringall, !recnumo
    datastr = TAGtext
    end
 
  when TAGnameuc=='SYNTAX' then do          /*----- :SYNTAX    -----*/
    if ?tagcheck then call TagNestS ,,!nonest
    syndat.=''; syndat.0=0; ?syntaxflag=true; _synnt=0
    synnt.=''; synnt_id=''; synnt_ids=''
    call EvalTag TAGoptions, 'SYNDEF'
    parse value Scale() with syntext_s (nl) syntext_e
    syntext_s=SetUpTag()||syntext_s; syntext_e=syntext_e||SetUpTag(,2)
    syntax_style=GetAttr('STYLE',!uc); syntax_view=GetAttr('VIEW',!uc)
    if syntax_view='START' | syntax_view=''
      then x=deftext._start; else x=deftext._middle
    /* Item 1 is the entire diagram container.  It contains the      */
    /* individual syntax diagrams, fragments and syntax notes.       */
    syndat.1._id=SymbSub(TAGtext); syndat.1._placement='ON'
    syndat.1._order='DIAGRAM'; syndat.1._contents='2'
    syntax_container = 1
    /* Item 2 is the first (or only) diagram.  It contains all the   */
    /* elements of that diagram (but not of any fragments or notes)  */
    syndat.2._id=''; syndat.2._placement='ON'; syndat.2._order='SEQ'
    syndat.2._contents='3'; syndat.2._inside = 1
    /* Item 3 is the starting point of the syntax diagram.           */
    syndat.3._text=x; syndat.3._placement='ON'; syndat.3._order=''
    syndat.3._contents=''; syndat.3._inside=2; syntax_container=2
    syndat.0 = 3
    /* Item WRAP1 is the terminator for a line-wrapped group.        */
    syndat.WRAP1._text=deftext._middle; syndat.WRAP1._placement='ON'
    syndat.WRAP1._order=''; syndat.WRAP1._contents=''; syndat.WRAP1._inside=1
    /* Item WRAP2 is the initiator for a line-wrapped group.          */
    syndat.WRAP2._text=deftext._middle; syndat.WRAP2._placement='ON'
    syndat.WRAP2._order=''; syndat.WRAP2._contents=''; syndat.WRAP2._inside=1
    end
  when TAGnameuc=='ESYNTAX' then do         /*----- :ESYNTAX   -----*/
    if ?tagcheck then do
      call TagNestE; if \?syntaxflag then call OutOfSeq !syntax
      end
    if syntax_view='START' | syntax_view='MIDDLE'
      then x=deftext._middle; else x=deftext._end
    i=syndat.0 + 1; syntax_container=2
    syndat.i._text=x; syndat.i._placement='ON'; syndat.i._order=''
    syndat.i._inside = syntax_container
    syndat.0 = i
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    syntext_s=syntext_s||RevTag(!s); syntext_e=ERevTag(!s)||syntext_e
    /*----- start the diagram -----*/
    if listnest=0 then boxwide=' WIDTH="100%"'; else boxwide=''
    select
      when syntax_style = 'BOX' then if htmlrel >= 3
        then x = HtmlX(!table,Border(8)||boxwide) ||,
                 HtmlX(!tr) || HtmlX(!td)
        else x = syntext_s'<P>'Pre()'<B>+'copies(dash,linewidth.llcnt - 2) ||,
                 '+</B>'EPre()'<BR>'syntext_e
      when syntax_style = 'LBLBOX' then if htmlrel >= 3
        then do
          x = HtmlX(!table,Border(9)||boxwide)
          if syndat.1._id \= ''
            then x = x || HtmlX(!tr) || HtmlX(!th,'ALIGN="LEFT"') ||,
                     syntext_s||SymbSub(syndat.1._id)||syntext_e'</TH></TR>'
          x = x || HtmlX(!tr) || HtmlX(!td)
          end
        else x = syntext_s'<P>'Pre()'<B>+' ||,
                 left('---'SymbSub(syndat.1._id), ,
                      linewidth.llcnt - 2,dash)||,
                 '+</B>'EPre()'<BR>'syntext_e
      when syntax_style = 'RULES' then x = hrtag.5
      when syntax_style = 'SPACE' then x = '<P>'
      otherwise x = '<P>'
      end
    call ProcTag x, !force
    /*----- generate and show each diagram part -----*/
    emptysyntax = deftext._start||deftext._dash||deftext._dash||deftext._end
    do w = 1 by 1 while w <= words(syndat.1._contents)
      item = word(syndat.1._contents, w)
      parse value SYNTAX_FORMAT(item, synctl._maxwidth, 1),
            with  width . . syntax_diagram
      if strip(translate(syntax_diagram,' ',xFF)) = emptysyntax then do
        if syntax_style='BOX' | syntax_style='LBLBOX'
          then call ProcTag blank, !force
        iterate w
        end
      if syndat.item._id \= ''
        then call ProcTag syntext_s'<P><B>'syndat.item._id ||,
                          ':</B><P>'syntext_e, !force
      call ProcTag syntext_s||Pre(), !force
      do while length(syntax_diagram) > 0
        parse var syntax_diagram line (xFF) syntax_diagram
        call ProcTag line, !force
        end
      call ProcTag EPre()||syntext_e, !force
      end
    /*----- show any syntax notes -----*/
    if synnt_ids \= '' then do
      call ProcTag syntext_s'<P><B>'deftext.!synnt'</B>'syntext_e, !force
      if htmlrel >= 3 then call ProcTag HtmlX(!table), !force
      do while synnt_ids\=''
        parse var synnt_ids synnt_id synnt_ids
        if htmlrel >= 3
          then x = HtmlX(!tr) || HtmlX(!td,'ALIGN="LEFT" VALIGN="TOP"') ||,
                   syntext_s'('synnt.synnt_id')'syntext_e'</TD>' ||,
                   HtmlX(!td,'ALIGN="LEFT" VALIGN="TOP"') || syntext_s
          else x = syntext_s'<P><B>('synnt.synnt_id')</B>'
        call ProcTag x, !force
        do x = 1 to synnt.synnt_id.0
          call ProcTag synnt.synnt_id.x, !force
          end
        if htmlrel >= 3
          then call ProcTag syntext_e'</TD></TR>', !force
          else if syntext_e\='' then call ProcTag syntext_e, !force
        end
      if htmlrel >= 3 then call ProcTag '</TABLE>', !force
      end
    /*----- end the diagram -----*/
    select
      when syntax_style = 'BOX' then if htmlrel >= 3
        then x = '</TD></TR></TABLE>'
        else x = syntext_s'<BR>'Pre()'<B>+'copies(dash,linewidth.llcnt - 2) ||,
                 '+</B>'EPre()'<P>'syntext_e
      when syntax_style = 'LBLBOX' then if htmlrel >= 3
        then x = '</TD></TR></TABLE>'
        else x = syntext_s'<BR>'Pre()'<B>+'copies(dash,linewidth.llcnt - 2) ||,
                 '+</B>'EPre()'<P>'syntext_e
      when syntax_style = 'RULES' then x = hrtag.5
      when syntax_style = 'SPACE' then x = '<P>'
      otherwise x = '<P>'
      end
    call ProcTag x, !force; datastr=TAGtext; drop syndat.
    syndat.=''; syndat.0=0; ?syntaxflag=false; _synnt=0
    synnt.=''; synnt_id=''; synnt_ids=''; syntext_s='' syntext_e=''
    end
 
  when TAGnameuc=='TABDATA' then do         /*----- :TABDATA   -----*/
    call Stack2Write2; w.=''; prevtotlen=0
    call EvalTag TAGoptions, 'TABDDEF'; tabdata_tab=GetAttr('CHAR')
    if tabdata_tab = '' then tabdata_tab = SymbSub('&tab')
    do i=1 by 1; w.i=GetAttr('W'i); if w.i='' then leave i; end
    temp1=GetAttr('SCALE'); if \datatype(temp1,'N') then temp1=1
    call SetColumns !force,100*(1/temp1); call SetAlignH; call SetHP
    ?tabdataflag=true; parse value Scale() with tabdata_s (nl) tabdata_e
    call ProcTag SetUpTag()'<P>'Pre()||tabdata_s'<TT>', !force
    if ?tagcheck then call TagNestS
    end
  when TAGnameuc=='ETABDATA' then do        /*----- :ETABDATA  -----*/
    call Stack2Write2; ?tabdataflag=false
    datastr='</TT>'tabdata_e||EPre()'<P>'SetUpTag(,2)||TAGtext
    if ?tagcheck then call TagNestE
    end
 
  when TAGnameuc=='TABDDEF' then call DefTag /*---- :TABDDEF   -----*/
 
  when TAGnameuc=='TABLE' then do           /*----- :TABLE     -----*/
    call Stack2Write2; if ?tagcheck then call TagNestS ,,!nonest
    parse value 0,
          with  row 1 col 1 colwidthlog_temp. 1 colwidthphys_temp.,
                1 prevtotlen 1 numcols_logical_temp,
                1 numcols_physical_temp 1 colwidthphyspct_orig.,
                1 bhtft.0 1 tblphysrow
    parse value '',
          with rowcol. w. frameline hdrline,
               endcelltag endrowtag defcelldata
    call EvalTag TAGoptions, 'TDEF'; tableid=GetAttr('ID')
    call ProcTag SetUpTag()||Br(), !force; _tablenum=_tablenum+1
    call ProcTag ':BHTABLE NUM='_tablenum'.', !force
    if GetAttr('WIDTH',!uc)='PAGE' & listnest=0
      then temp1=' WIDTH="100%"'; else temp1=' '
    parse value Scale() with cellscale_s (nl) cellscale_e
    select
      when htmlrel = 2 then if GetAttr('FRAME',!uc) = 'NONE'
        then do; ctable2.=' '; ctable2len.=1; end
        else do i=1 to 8; ctable2.i=table2.i; ctable2len.i=table2len.i; end
      when htmlrel >= 3 then if GetAttr('FRAME',!uc) = 'NONE'
        then call ProcTag HtmlX(!table,temp1), !force
        else call ProcTag HtmlX(!table,temp1 Border(10)), !force
      otherwise nop
      end
    call SetColumns !force; call SetAlignH; call SetAlignV
    call SetHP; call SetShade; call SetConcat
    ?tableflag=true; revnest.!table=revnest
    parse value 0 with ?tablewarn 1 ?tableprevrowtemp 1 ?tableprefix
    end
  when TAGnameuc=='ETABLE' then do          /*----- :ETABLE    -----*/
    call Stack2Write2
    if ?tdescflag then do
      call Put_Buffer ':etable.'TAGtext||TAGresidual, !lifo
      call Put_Buffer ':etdesc.', !lifo
      signal End_ProcessTag1
      end
    if htmlrel=2 & col>0 then do
      if colEHP.col\='' then call Write2Temp2 colEHP.col
      _BRcount = max(0,_BRcount-colconcat.col)
      end
    if bhtft.0 > 0 then do                  /* footer saved?        */
      pt1result=bhtft.1                     /*    yes, do now       */
      do i=2 to bhtft.0; call Put_Buffer bhtft.i; end
      call Put_Buffer ':etable.'; bhtft.0=0
      signal End_ProcessTag1
      end
    if ?tagcheck then call TagNestE
    temp2 = SetUpTag('TABLE',2)
    select
      when htmlrel = 2 then do
        call TablePrefix; call TableFormat
        if ?tft
          then call ProcTag translate(BuildFrame(1),'=','-'), !force
          else call ProcTag BuildFrame(1), !force
        call TableSuffix
        if temp2 \= '' then call ProcTag temp2, !force
        end
      when htmlrel >= 3
        then datastr=GenRowEnd()||'</TABLE>'||temp2 ||,
                     EndTableFont(revnest.!table)
      otherwise nop
      end
    parse value false,
          with  ?tableflag 1 ?thd 1 ?tft,
                rowcol. endcelltag endrowtag defcelldata,
                cellscale_s cellscale_e
    datastr = datastr || TAGtext
    end
 
  when TAGnameuc=='TCAP' then do            /*----- :TCAP      -----*/
    if ?tagcheck then if \?tableflag then call OutOfSeq !table
    TAGtext = strip(TAGtext)
    if ?ftsep
      then do; _tcapnum=_tcapnum+1; i=!table; end
      else do; _figcapnum=_figcapnum+1; _tcapnum=_figcapnum; i=!figure; end
    if ?fbc then tabletail=ChaptNum()'-'_tcapnum; else tabletail=_tcapnum
    tcap._tablenum='<B>' ||,
          MakeXref(!tref, tableid, deftext.i tabletail'.' TAGtext,,
                   deftext.i tabletail, tabletail,,,TAGtext) ||,
          '</B>'Br()
    end
 
  when TAGnameuc=='TDEF' then call DefTag   /*----- :TDEF      -----*/
 
  when TAGnameuc=='TDESC' then do           /*----- :TDESC     -----*/
    if ?tagcheck then do
      call TagNestS ,,!nonest; if \?tableflag then call OutOfSeq !table
      end
    ?tdescflag = true
    select
      when htmlrel = 2 then do
        saverec.!tdesc.0 = 0
        if TAGtext \= '' then call SaveRec !tdesc,TAGtext
        end
      when htmlrel >= 3 then do
        call Put_Buffer ':row refid=99999 temp.'
        call Put_Buffer ':c.'TAGtext || TAGresidual; TAGresidual=''
        end
      otherwise nop
      end
    end
  when TAGnameuc=='ETDESC' then do          /*----- :ETDESC    -----*/
    if ?tagcheck then call TagNestE
    ?tdescflag=false; datastr=TAGtext
    end
 
  when TAGnameuc=='TFT' then do             /*----- :TFT       -----*/
    if ?tagcheck then do
      call TagNestS ,,!nonest; if \?tableflag then call OutOfSeq !table
      end
    i=0; templine=insert('BH',TAGstringall||TAGresidual,1); TAGresidual=''
    do forever
      i=i+1; j=pos(':ETFT.',translate(templine))
      if j = 0
        then do
          bhtft.i = templine
          parse value Get_Buffer(1) with 1 ?tempeof 2 ?physread 3 templine
          if ?tempeof then leave
          end
        else do
          bhtft.i = left(templine,j+5)
          templine = substr(templine,j+6)
          leave
          end
      end
      bhtft.0=i; pt1result=templine; signal End_ProcessTag1
      end
  when TAGnameuc=='ETFT'                    /*----- :ETFT      -----*/
    then do; datastr=TAGtext; if ?tagcheck then call TagNestE; end
 
  when TAGnameuc=='TIPAGE' | TAGnameuc='COVER' /*-- :TIPAGE/:COVER -*/
   then if \?tipagedone then do
    call Stack2Write2
    temp1=SetUpTag(); if temp1\='' then call ProcTag temp1, !force
    parse value false with ?titleflag 1 ?libraryflag 1 ?topicflag
    do i = 1 to saverec.!library.0
      call ProcTag saverec.!library.i||Br(), !force
      end
    if saverec.!title.0 > 0 then do
      if saverec.!library.0 > 0 then call ProcTag '<P>'
      do i = 1 to saverec.!title.0
        call ProcTag '<B>'saverec.!title.i'</B>'Br(), !force
        end
      if saverec.!topic.0 > 0 then call ProcTag '<P>'
      end
    do i=1 to saverec.!topic.0
      call ProcTag saverec.!topic.i||Br(),!force
      end
    if tversion\='' | trelease\=''
      then call ProcTag '<P>'tversion trelease,!force
    do i=1 to saverec.!pgmnum.0
      if i=1 then call ProcTag '<P>',!force
      call ProcTag saverec.!pgmnum.i||Br(),!force
      end
    if saverec.!author.0 > 0 then do
      temp1=SetUpTag('AUTHOR',1); temp2=SetUpTag('AUTHOR',2)
      call ProcTag temp1'<P>', !force
      do i=1 to saverec.!author.0
        call ProcTag saverec.!author.i||Br(),!force
        end
      if temp2\='' then call ProcTag temp2, !force
      end
    if saverec.!address.0 > 0 then do
      temp1=SetUpTag('ADDRESS',1); temp2=SetUpTag('ADDRESS',2)
      call ProcTag temp1'<P>', !force
      do i=1 to saverec.!address.0
        call ProcTag saverec.!address.i||Br(),!force
        end
      if temp2\='' then call ProcTag temp2, !force
      end
    if tdate    \= '' then call ProcTag '<P>'tdate, !force
    if tdocnum  \= '' then call ProcTag '<P>'deftext.!docnum tdocnum, !force
    if tvolnum  \= '' then call ProcTag '<P>'deftext.!volnum tvolnum, !force
    if tfilenum \= '' then call ProcTag '<P>'tfilenum, !force
    if tpartnum \= '' then call ProcTag '<P>'tpartnum, !force
    if tbindnum \= '' then call ProcTag '<P>'tbindnum, !force
    if tvendor  \= '' then call ProcTag '<P>'tvendor,  !force
    if tprtloc  \= '' then call ProcTag '<P>'tprtloc,  !force
    temp2=SetUpTag(,2); if temp2\='' then call ProcTag temp2, !force
    datastr=TAGtext; ?tipagedone=true
    parse value 0,
          with  saverec.!library.0 1 saverec.!title.0 1 saverec.!topic.0
    end
 
  when TAGnameuc=='TITLE' |,                /*----- :TITLE     -----*/
       TAGnameuc=='TITLEP' then do          /*----- :TITLEP    -----*/
    call Stack2Write2; call EvalTag TAGoptions
    if stitle = '' then stitle = strip(SymbSub(GetAttr('STITLE')))
    if TAGtext \= '' then call SaveRec !title,space(SymbSub(TAGtext))
    ?libraryflag=false; ?topicflag=false; ?titleflag=( TAGtext = '' )
    end
  when TAGnameuc=='ETITLEP' |,              /*----- :ETITLEP   -----*/
       TAGnameuc=='ETITLE' then do          /*----- :ETITLE    -----*/
    call Stack2Write2; ?libraryflag=false; ?topicflag=false; ?titleflag=false
    if ?addressflag then do
      call Put_Buffer ':'TAGnameuc'.'TAGtext||TAGresidual, !lifo
      call Put_Buffer ':eaddress.', !lifo
      signal End_ProcessTag1
      end
    if TAGnameuc='ETITLEP' then call Put_Buffer ':TIPAGE.'TAGtext, !lifo
    end
 
  when TAGnameuc=='TLINE'                   /*----- :TLINE     -----*/
    then do; call SaveRec !title,TAGtext||TAGresidual; TAGresidual=''; end
 
  when TAGnameuc=='TOPIC' then do           /*----- :TOPIC     -----*/
    call Stack2Write2
    ?titleflag=false; ?libraryflag=false; ?topicflag=true
    if TAGtext \= '' then call SaveRec !topic,SymbSub(TAGtext)
    end
 
  when TAGnameuc=='TNOTE' then do           /*----- :TNOTE     -----*/
    if ?tagcheck then if \?tableflag then call OutOfSeq !table
    call EvalTag TAGoptions
    parse value GetAttr('TEXT',,1) with ?def tnotetext
    if \?def then tnotetext = 'Note'
    if tnotetext \= '' then tnotetext = ':hp2.'tnotetext'&colon. :ehp2.'
    call Put_Buffer ':row refid=99999 temp. :c.'tnotetext ||,
                    TAGtext || TAGresidual,!lifo
    TAGresidual=''; if htmlrel = 2 then col = 0
    end
 
  when TAGnameuc=='TLIST' then if ?tlistwanted /*-- :TLIST     -----*/
   then if ?ftsep then if ?tlistfnd
    then do
      call ProcTag TAGstringall, !force
      tlistfile = currpartl
      end
    else do
      if TAGtext = '' then TAGtext = deftext.!tlist
      call EvalTag TAGoptions; tempid=GetAttr('ID')
      if tempid = ''
        then do
          TAGoptions = 'ID='TLISTname TAGoptions
          TLISTname = !hdref || TLISTname
          end
        else TLISTname = !hdref || tempid
      call Put_Buffer ':TLIST.', !lifo
      call Put_Buffer ':H1 B2HNUM=NO' TAGoptions'.'TAGtext||TAGresidual, !lifo
      TAGresidual=''; ?tlistfnd=true
      end
 
  when TAGnameuc=='TOC' then do             /*----- :TOC       -----*/
    call ProcTag TAGstring, !force          /* (handled in pass 2)  */
    if TAGtext \= '' then deftext.!toc=strip(TAGtext)
    _toccnt=_toccnt+1; toclfile=currpartl; ?tocfnd=1
    call EvalTag TAGoptions; headid=GetAttr('ID')
    if headid \= '' then do                 /* save ID= info        */
      TOCname=headid; _hnum=_hnum+1
      call MakeXref !hdref,headid,deftext.!toc,deftext.!toc,_hnum,,1
      end
    end
 
  when TAGnameuc=='TREF'                    /*----- :TREF      -----*/
    then if ?tableflag & htmlrel=2          /* if in a HTML 2 table */
      then datastr=RefInTable(!tref)        /* handle now, otherwise*/
      else call Handle_In_Pass2             /* handle in pass 2     */
 
  when TAGnameuc=='VAR' then do             /*----- :VAR       -----*/
    if ?tagcheck then if \?syntaxflag then call OutOfSeq !syntax
    call EvalTag TAGoptions; i=syndat.0 + 1; syndat.0=i
    syndat.i._text = SynData(TAGtext,'I')
    syndat.i._placement=SynPlace('DEF OPT REQ')
    syndat.syntax_container._contents = syndat.syntax_container._contents i
    syndat.i._inside = syntax_container
    end
 
  when TAGnameuc=='VNOTICE' then do         /*----- :VNOTICE   -----*/
    call Stack2Write2; ?vnotice=true
    if ?tagcheck then call TagNestS ,,!nonest
    end
  when TAGnameuc=='EVNOTICE' then do        /*----- :EVNOTICE  -----*/
    if ?coprext then call Stack2Write2; ?coprext=false
    ?vnotice=false; if ?tagcheck then call TagNestE
    if coprext \= '' then coprext = '<BR>'coprext
    call DefSymbol 'b2hcopyr',copyr, 'b2hibmcopyr',ibmcopyr,,
                   'b2hcoprext',coprext
    select
      when coprnote\='' then datastr = coprnote coprext
      when copyr   \='' then datastr = deftext.!copyr
      when ibmcopyr\='' & ugdoc='USERDOC' then datastr = deftext.!ibmcopyr
      otherwise nop
      end
    if datastr \= '' then datastr = '<P>'SymbSub(datastr)
    datastr = datastr || TAGtext
    end
 
  when TAGnameuc=='WARRANTY' then do        /*----- :WARRANTY  -----*/
    call EvalTag TAGoptions; wsubj='WARR'||GetAttr('SUBJECT',!uc)
    datastr=deftext.wsubj || TAGtext
    end
 
  when wordpos(TAGnameuc,'XMP CGRAPHIC')>0  /*--- :XMP/:CGRAPHIC ---*/
   then do
    call Stack2Write2; if ?tagcheck then call TagNestS ,,!nonest
    if TAGnameuc='XMP' then temp='XMPDEF'; else temp='CGDEF'
    call EvalTag TAGoptions, temp
    parse value Scale() with xmpbeg (nl) xmpend
    if ?tableflag & htmlrel=2
      then do; datastr='<BR>'xmpbeg||TAGtext; _BRcount=_BRcount+1;end
      else do; datastr=Pre()||xmpbeg||TAGtext; inwidth=0; end
    datastr = SetUpTag() || datastr
    end
  when wordpos(TAGnameuc,'EXMP ECGRAPHIC')>0 /*-- :EXMP/:ECGRAPHIC--*/
   then do
    call Stack2Write2; if ?tagcheck then call TagNestE
    if ?tableflag & htmlrel=2
      then do
        datastr = xmpend || SetUpTag(,2) || TAGtext
        _BRcount = max(0,_BRcount-1)
        end
      else do; datastr=xmpend||EPre()||SetUpTag(,2)||TAGtext; inwidth=0; end
    xmpbeg=''; xmpend=''
    end
 
  when TAGnameuc=='XMPDEF' then call DefTag /*----- :XMPDEF    -----*/
 
       /*----- :AUTHOR/:BINDNUM/:DATE/:DOCNUM/:FILENUM/:PARTNUM/  --*/
       /*----- :PGMNUM/:PRTLOC/:RELEASE/:VERSION/:VENDOR/:VOLNUM  --*/
  when wordpos(TAGnameuc,'AUTHOR BINDNUM DATE DOCNUM FILENUM PARTNUM',
               'PGMNUM PRTLOC RELEASE VERSION VENDOR VOLNUM')>0 then do
    ?titleflag=false; ?libraryflag=false; ?topicflag=false
    call EvalTag TAGoptions
    select
      when TAGnameuc = 'AUTHOR'  then do
        temp1 = GetAttr('TEXT')
        if temp1 = ''
          then call SaveRec !author,TAGtext
          else call SaveRec !author,temp1':' TAGtext
        end
      when TAGnameuc = 'BINDNUM' then tbindnum = TAGtext
      when TAGnameuc = 'DATE'
        then if TAGtext='' then tdate='&date'; else tdate=TAGtext
      when TAGnameuc = 'DOCNUM'  then do
        temp1=GetAttr('LEVEL')
        if temp1 = '' then tdocnum=TAGtext; else tdocnum=TAGtext'-'temp1
        end
      when TAGnameuc = 'FILENUM' then tfilenum = TAGtext
      when TAGnameuc = 'PARTNUM' then tpartnum = TAGtext
      when TAGnameuc = 'PGMNUM'  then call SaveRec !pgmnum,TAGtext
      when TAGnameuc = 'PRTLOC'  then tprtloc  = TAGtext
      when TAGnameuc = 'RELEASE' then trelease = TAGtext
      when TAGnameuc = 'VENDOR'  then tvendor  = TAGtext
      when TAGnameuc = 'VERSION' then tversion = TAGtext
      when TAGnameuc = 'VOLNUM'  then tvolnum  = TAGtext
      otherwise nop
      end
    end
 
  /*----- unknown Bookmaster tag -----*/
  otherwise do
    call MsgOut ?prcunktag 403, ,
                '"'TAGitself'"' ignoreumsg,TAGstringall,!recnumo
    datastr = '&gml.'substr(TAGstringall,2)
    end
  end
pt1result = datastr || TAGresidual
 
End_ProcessTag1:
if ?trcparse then call Here2 pt1result
return pt1result
 
 
 
/*----- Handle_In_Pass2: Pass tag onto pass-2 for handling -----*/
Handle_In_Pass2:
  datastr = TAGstringall
  ?rescan = 0
  return
 
/*----- DefTag: save options for a definition tag -----*/
DefTag:
  opts = EvalTag(TAGoptions,TAGnameuc,'IDSONLY')
  id = GetAttr('ID')
  if id = '' then id = 0
  tagdef.TAGnameuc.id = opts
  return
 
/*----- Conflict: show conflicting attributes -----*/
Conflict:
  Call Msgout !error 462, 'Conflicting attributes!',TAGstringall, !recnumo
  return
 
/*----- Do a "<PRE>" or "</PRE>" -----*/
Pre:
  if _PREcount = 0
    then preslt = '<PRE>'
    else preslt = ''
  _PREcount = _Precount + 1
  return preslt
EPre:
  if _PREcount=1
    then preslt = '</PRE>'
    else preslt = ''
  _PREcount = max(0,_PREcount-1)
  return preslt
/*----- Return a "<BR>" if not auto skipping to a new line -----*/
Br:
  if _PREcount=0 & _BRcount=0
    then return '<BR>'
    else return ''
 
/*----- HTag: Return appropriate begin/end text for a <Hx> tag -----*/
/*----- Also check next record and handle appropriately.       -----*/
/* Use: parse value HTag(num) with startext (x00) endtext (x00)     */
HTag: parse arg htgnum .
  parse value htag.htgnum with htg1 ',' htg2 ',' htg3 ',' htg4
  if htg3 \= '' then do                /* need to check next rec?   */
    parse value Get_Buffer(0),         /*   yes, get it and check   */
          with  1 ?tempeof 2 ?physread 3 htgrec
    if \?tempeof then do               /* if not EOF, check rec and */
      call Stack2Write2                /*   put result in buffer    */
      htg3=translate(htg3); htg3l=length(htg3)
      if translate(left(htgrec,htg3l)) == htg3
        then htgrec = htg4 || substr(htgrec,htg3l+1)
      call Put_Buffer htgrec, !lifo
      end
    end
  return htg1 || x00 || htg2 || x00
 
/*----- SetUpTag: Return appropriate begin/end setup text -----*/
/* string = SetUpTag(<tagname>,<idx>)   idx: 1=start/2=end     */
SetUpTag: parse arg suname, suidx
  if suname = '' then suname = TAGnameuc
  if suidx  = '' then suidx  = 1
  if suidx  = 2
    then if left(suname,1)='E'
      then suname = substr(suname,2)
  return setuptag.suname.suidx
 
/*----- HtmlX: Return a tag plus any defined attribute    -----*/
/* string = HtmlX(tagname,<anyotheropts>)                      */
HtmlX: parse arg hxtagname, hxtagopts
  hxresult = '<'hxtagname || htmlx.hxtagname
  if hxtagopts = ''
    then return hxresult'>'
    else return hxresult hxtagopts'>'
 
/*----- SynData: Return syntax data element w/wo a font -----*/
SynData: parse arg sd1, sd2
  if ?synfont
    then return '<'sd2'>'strip(SymbSub(sd1))'</'sd2'>'
    else return strip(SymbSub(sd1))
 
/*----- SynFont: set font for syntax diagram element -----*/
SynFont:
  sfgiven = GetAttr('CONSTANT',!uc) GetAttr('VAR',!uc)
  if words(sfgiven) > 1
    then do; call Conflict; sfgiven=''; end
    else sfgiven = space(sfgiven)
  if sfgiven = 'VAR'
    then return 'I'
    else return 'B'
 
/*----- SynPlace: set placement for syntax diagram element -----*/
SynPlace:
  parse upper arg spvalid
  spgiven = ''
  do while spvalid \= ''
    parse var spvalid atom spvalid
    spgiven = GetAttr(atom,!uc) spgiven
    end
  if words(spgiven) > 1
    then do; call Conflict; spgiven=''; end
    else spgiven = space(spgiven)
  select
    when spgiven = 'DEF' then spresult = 'ABOVE'
    when spgiven = 'OPT' then spresult = 'BELOW'
    otherwise                 spresult = 'ON'
    end
  return spresult
 
/*---- Return either chapter number or appendix letter -----*/
ChaptNum:
  if ?appendix
    then return substr(alphauc||alphalc,max(apdxcnt,1),1)
    else return max(1,_h1num)
 
/*----- Create :H0/:H1 header text -----*/
BodyHd:
  parse arg bhhd, bhnum, bhhdx, bhshownum
  if \bhshownum then bhnum=''
  bhrslt = space(bhhd bhnum bhhdx)
  if bhrslt \== ''
    then if ?appendix | bhhd\='' | bhhdx\=''
      then bhrslt = bhrslt'. '
      else bhrslt = bhrslt' '
  return bhrslt
 
/*----- Ensure end-of-table font nesting same as start-of-table ----*/
EndTableFont:
if arg(1) > revnest
  then return copies('</FONT>',arg(1)-revnest)
  else return ''
 
/*----- Handle SCALE= attribute -----*/
Scale:
  scrslt = ''
  scalenum = GetAttr('SCALE')
  if \datatype(scalenum,'N') then scalenum = 1
  select
    when scalenum = 1 then nop
    when htmlrel <= 3 then do
      scalenum = trunc(scalenum*3)
      scrslt = '<FONT SIZE="'scalenum'">'nl'</FONT>'
      end
    when htmlrel = 4 then do
      scalenum = format(abs(scalenum*100),,0)
      scrslt = '<SPAN STYLE="font-size:'scalenum'%">'nl'</SPAN>'
      end
    otherwise nop
    end
  return scrslt
 
/*----- Show tag-out-of-sequence -----*/
OutOfSeq:
  parse arg oos
  call MsgOut !warning 413, ,
              '"'TAGitself'"' seqtext.oos, TAGstringall, !recnumo
  return
 
/*----- see if "item" tag is logically in sequence -----*/
/* call CheckSeq num   where "num" is current tag       */
/*   0 - :DL/:GL   4 - :GDG      */
/*   1 - :DTHD     5 - :DD/:GD   */
/*   2 - :DDHD     6 - :EDL/:EGL */
/*   3 - :DT/:GT                 */
CheckSeq:
  parse arg cscurr
  csprev = listitem.listnest.!seq
  ?csOK  = 1
  select
    when cscurr=1 then ?csOK=( csprev=0 )
    when cscurr=2 then ?csOK=( csprev=1 )
    when cscurr=3 then ?csOK=( csprev=0 | csprev=2 | csprev=5 )
    when cscurr=4 then ?csOK=( csprev=3 )
    when cscurr=5 then ?csOK=( csprev=3 | csprev=4 | ( csprev=5 & ?gdnum ) )
    when cscurr=6 then ?csOK=( csprev=0 | csprev=2 | csprev=5 )
    otherwise nop
    end
  if \?csOK
    then call MsgOut !warning 414, ,
              '"'TAGitself'" out of sequence', TAGstringall, !recnumo
  listitem.listnest.!seq = cscurr
  return
 
/*------------------------------------------------------------------*/
/* TagNestS: Record the start of a tag                              */
/* Usage:    call TagNestS <tag>, <text>, <!NONEST>                 */
/*------------------------------------------------------------------*/
TagNestS: rtn='TAGNESTS'; trace value tracelist.rtn
  parse arg tntag, tntext, tnnest
  if tntag == '' then tntag = TAGitself
  tntag = translate(tntag)
  if ?trcparse then call Here1 rtn,tntag','tntext','tnnest,sigl,!parse
  ?tnestable = ( tnnest \= !nonest )
  if tntext == '' then tntext = TAGstring
  tni = tagnest.tntag.0
  if \?tnestable
    then if tni > 0
      then call MsgOut !warning 415, '"'tntag'" already in effect from line',
                       tagnest.tntag.tni,space(tntext),!recnumo
  if source_id_orig.infilecnt = ''
    then tns = source_id.infilecnt
    else tns = source_id_orig.infilecnt
  tni =tni + 1
  tagnest.tntag.tni = word(tns,1) 'of' subword(tns,2)
  tagnest.tntag.0 = tni
  tntext = x00 || tntag || x00
  if pos(tntext,tagnest) = 0 then tagnest=tagnest || tntext
  if ?trcparse then call Here2
  return
/*------------------------------------------------------------------*/
/* TagNestE: Record the end of a tag                                */
/* Usage:    call TagNestE <end-tag>,<text>                         */
/*------------------------------------------------------------------*/
TagNestE: rtn='TAGNESTE'; trace value tracelist.rtn
  parse arg tntag, tntext
  if tntag == '' then tntag = TAGitself
  tntag = translate(tntag)
  if ?trcparse then call Here1 rtn,tntag','tntext,sigl,!parse
  if left(tntag,2) = ':E' then tntag = ':'substr(tntag,3)
  if tntext == '' then tntext = TAGstring
  tni = tagnest.tntag.0
  if tni > 0
    then tagnest.tntag.0 = tni - 1
    else call MsgOut !warning 416,'No "'tntag'" outstanding!',tntext,!recnumo
  if ?trcparse then call Here2
  return
 
/*------------------------------------------------------------------*/
/* Miscellaneous routines to save records in appropriate arrays     */
/*------------------------------------------------------------------*/
ProcTag:  /* call ProcTag line <,FORCE>   */
  if ?trcpgm then call Here1 'PROCTAG',arg(1)','arg(2),sigl,!parse
  if ?OKtoUse then do
    xi = proctag.0+1
    proctag.0 = xi
    if pass1save==''
      then proctag.xi=arg(1)
      else do
        proctag.xi = pass1save || arg(1)
        pass1save = ''
        end
    proctagf.xi = ( arg(2) \= '' )
    end
  if ?trcpgm then call Here2
  return
SaveRec:
  if ?OKtoUse then do
    parse arg sri, srrec
    xi = saverec.sri.0 + 1
    saverec.sri.xi = srrec
    saverec.sri.0  = xi
    select
      when sri = !library then library_save = strip(library_save srrec)
      when sri = !title   then title_save   = strip(title_save srrec)
      when sri = !topic   then topic_save   = strip(topic_save srrec)
      otherwise nop
      end
    end
  return
 
/*------------------------------------------------------------------*/
/* SPLIT_FILE_HERE: Cause output to be split at this point          */
/*                  (this routine can be called only during Pass-1) */
/* Usage:  call Split_File_Here <physical-file>,<logical-file>      */
/*------------------------------------------------------------------*/
Split_File_Here: rtn='SPLIT_FILE_HERE'; trace value tracelist.rtn
  parse arg sfpfile, sflfile
  if ?trcpgm then call Here1 rtn,sfpfile','sflfile,sigl,!pgm
  if mc.!e \= '' then do
    call ProcTag mc.!e
    mc.!e = ''
    end
  call ERevTag                         /* end any revision code(s)  */
  call PrintFootNotes 0, pt1out        /* print footnotes so far    */
  partnamel.currpartnum = currpartl    /* save phys/log file name   */
  partnamep.currpartnum = outputp_file
  currpartnum = currpartnum + 1        /* increment file counter    */
  pfile = BHSplit(currpartnum,sfpfile,outputp_file,outputp_dsorg,!physical)
  lfile = BHSplit(currpartnum,sflfile,outputl_file,outputl_dsorg,!logical)
  call ProcTag ':BHSPLIT PF="'pfile'" LF="'lfile'" SPLITLINK='?splitlink'.'
  partnamel.currpartnum = lfile        /* save new phys/log filename*/
  partnamep.currpartnum = pfile
  currpartl = lfile
  i2 = BHSplit(currpartnum+1,,outputl_file,outputl_dsorg,!logical)
  i = currpartnum + 1
  partnamel.i = i2
  call RevTag                          /* restart revision code(s)  */
  if ?trcpgm then call Here2
  return
 
 
 
/*------------------------------------------------------------------*/
/* ProcessTag2: :tags not processed in pass 1 are processed here.   */
/*              Data returned to caller is included in Pass 2 output*/
/* Usage:  result = ProcessTag2()                                   */
/*     result - what should be written to the output                */
/*------------------------------------------------------------------*/
ProcessTag2: rtn='PROCESSTAG2'; trace value tracelist.rtn
if ?trcparse then call Here1 rtn,,sigl,!parse
parse value '' with datastr pt2result
?rescan = 1    /* Check returned string for more tags? 1=Y/0=N      */
 
select
  /*----- :ANSREF   -----*/
  when TAGnameuc=='ANSREF'
    then datastr = ResolveRef(!ansref,TAGoptions) || TAGtext
 
  /*----- :ANSWER   -----*/
  when TAGnameuc=='ANSWER' then do
    call EvalTag TAGoptions
    answerid = GetAttr('REFID')
    if ?dlfmt & htmlrel>=3
      then ansdl = 3
      else ansdl = 1
    datastr = list.!dl.ansdl.1 || list.!dl.ansdl.3 ||,
              ResolveRef(!answer,TAGoptions) ||,
              quest.answerid.!ansref || list.!dl.ansdl.5 ||,
              quest.answerid.!anstxt || list.!dl.ansdl.2
    end
 
  /*----- :BHCMT.comment -----*/
  when TAGnameuc=='BHCMT' then do
    call MC TAGtext || TAGresidual,'-'
    TAGresidual = ''
    end
 
  /*----- :BHFIG NUM=fignum. -----*/
  when TAGnameuc=='BHFIG' then do
    call EvalTag TAGoptions; _fignum=GetAttr('NUM')
    if GetAttr('LOC') = '1'
      then parse value '<P> <BR>' with datastr efigstr
      else efigstr = '<P>'
    if figcap._fignum \= '' then datastr = datastr || figcap._fignum
    if figdesc._fignum.0 > 0 then do
      if figcap._fignum \= '' then datastr = datastr'.'
      do p2temp = 1 to figdesc._fignum.0
        datastr = datastr figdesc._fignum.p2temp
        end
      end
    datastr = datastr || efigstr
    end
 
  /*----- :BHL TYPE=type ID=id. -----*/
  when TAGnameuc=='BHL' then do
    call EvalTag TAGoptions; bhtype=GetAttr('TYPE'); bhid=GetAttr('ID')
    if bhtype = 'BOOK'
      then do; rrfid=toclfile; bhid=''; end
      else do
        refidx = GetXrefEntry(bhtype,bhid)
        rrfid = xref.refidx.!file
        end
    if currpartl = rrfid
      then rrfid = ''
      else rrfid = Filecase(rrfid)
    if rrfid='' & bhid='' then rrfid=currpartl
    if bhid = ''
      then datastr = HtmlX(!a,'HREF="'rrfid'"') || TAGtext
      else datastr = HtmlX(!a,'HREF="'rrfid'#'bhtype||bhid'"') || TAGtext
    end
 
  /*----- :BHOPT name=value. -----*/
  when TAGnameuc=='BHOPT' then do
    call EvalTag TAGoptions
    ?splitlink = GetAttr('SPLITLINK')
    end
 
  /*----- :BHSPLIT LF='logicalfile' PF='physfile' SPLITLINK=x. -----*/
  when TAGnameuc=='BHSPLIT' then do
    if pass2save \= '' then do         /* flush buffer if not empty */
      call WrtLine outputp_file, pass2save
      pass2save = ''
      end
    call FooterRecords
    call EvalTag TAGoptions
    ?splitlink   = GetAttr('SPLITLINK')
    outputl_file = GetAttr('LF');
    outputp_file = GetAttr('PF')
    if outputl_file='' | outputp_file=''
      then call MsgOut !term 453,'Invalid syntax in' TAGstring
    call GetReadyForOutput outputp_file, MVSOutputDsorg
    call OpenFile outputp_file,!write,MVSalloc.MVSOutputDsorg
    outputp_path = fp.!path
    outputp_fn   = fp.!fn
    outputp_fn1  = fp.!fn1
    outputp_fn2  = fp.!fn2
    outputp_ft   = fp.!ft
    outputp_fm   = fp.!fm
    currpartl = outputl_file
    call DefSymbol b2hvars.7,currpartl
    call FileParts outputl_file, destsys
    outputl_path = fp.!path
    outputl_fn   = fp.!fn
    outputl_fn1  = fp.!fn1
    outputl_fn2  = fp.!fn2
    outputl_ft   = fp.!ft
    outputl_fm   = fp.!fm
    i1 = currpartnum
    currpartnum = currpartnum + 1
    i2 = currpartnum + 1
    call DefSymbol b2hvars.2,partnamel.i2, b2hvars.3,partnamel.i1,,
                   b2hvars.4,HREFlink(toclfile,TOCname),,
                   b2hvars.6,HREFlink(indexlfile,IDXname),,
                   b2hvars.8,HREFlink(word(ptoclfile toclfile,1),PTOCname)
    call HeaderRecords
    end
 
  when TAGnameuc=='BHTAB' then do           /*----- :BHTAB     -----*/
     call EvalTag TAGoptions
     colalignh. = 'L'
     colfill.   = ' '
     colHP.     = ''
     colEHP.    = ''
     parse value 0 with colwidthphys. 1 prevtotlen
     numcols_physical = GetAttr('PC')
     numcols_logical  = GetAttr('LC')
     temp1=GetAttr('CWP')
     do i = 1 to words(temp1)
       colwidthphys.i = word(temp1,i)
       colwidthphys.!totlen = colwidthphys.!totlen + colwidthphys.i
       end
     end
 
  /*----- :BHTABLE NUM=num. -----*/
  when TAGnameuc=='BHTABLE' then do
    call EvalTag TAGoptions
    _tablenum = GetAttr('NUM')
    if tcap._tablenum \= ''
      then datastr = '<P>'tcap._tablenum
    end
 
  /*----- :BHSYM NAME='n1 n2 ...' VALUE='xxx'. -----*/
  when TAGnameuc=='BHSYM' then do
    call EvalTag TAGoptions
    bhname  = GetAttr('NAME')
    bhvalue = GetAttr('VALUE')
    do while bhname \= ''
      parse var bhname atom bhname
      call DefSymbol atom, bhvalue
      end
    end
 
  /*----- :FIGREF   -----*/
  when TAGnameuc=='FIGREF'
    then datastr = ResolveRef(!figref,TAGoptions) || TAGtext
 
  /*----- :FIGLIST  -----*/
  when TAGnameuc=='FIGLIST' then call GenerateFigList !figref
 
  /*----- :FNREF    -----*/
  when TAGnameuc=='FNREF' then do
    p2temp  = word('ORIG LINK',?fnlinkto+1)
    datastr = ResolveRef(!fnref,TAGoptions,p2temp) || TAGtext
    end
 
  /*----- :HDREF    -----*/
  when TAGnameuc=='HDREF'
    then datastr = ResolveRef(!hdref,TAGoptions) || TAGtext
 
  /*----- :IHx, :Ix -----*/
  when wordpos(TAGnameuc,'IH1 IH2 IH3 I1 I2 I3') > 0 then if ?index
    then datastr = SaveIndex(TAGnameuc,TAGoptions,TAGtext,pass)
 
  /*----- :INDEX    -----*/
  when TAGnameuc=='INDEX' then call GenerateIndex
 
  /*----- :IREF     -----*/
  when TAGnameuc=='IREF' then if ?index
    then datastr = SaveIndex(TAGnameuc,TAGoptions,TAGtext,pass)||TAGtext
 
  /*----- :LIREF  -----*/
  when TAGnameuc=='LIREF'
    then datastr = ResolveRef(!liref,TAGoptions) || TAGtext
 
  /*----- :PTOC     -----*/
  when TAGnameuc=='PTOC' then do
    call EvalTag TAGoptions
    ptocstart = GetAttr('INDEX')
    pbp       = GetAttr('PART')
    ptocmost  = GetAttr('MOST')
    ptocleast = GetAttr('LEAST')
    _PTOCcnt  = _PTOCcnt + 1
    call DefSymbol b2hvars.8,HREFlink(currpartl,PTOCname||_PTOCcnt)
    do i = ptocstart to saverec.!toc.0
      parse var saverec.!toc.i . phead pbookpart .
      if phead<=ptocmost | pbookpart\=pbp then leave i
      end
    temp1 = 'NAME="'PTOCname || _PTOCcnt'"'
    select
      when tocret=2
        then temp1 = HtmlX(!a,temp1 'HREF="'HREFlink(toclfile,TOCname)'"')||,
                     deftext.!ptoc'</A>'
      when tocret=4
        then temp1 = deftext.!ptoc'     ',
                     HtmlX(!a,temp1 'HREF="'HREFlink(toclfile,TOCname)'"')||,
                     deftext.!ptoclt'</A>'
      otherwise temp1 = HtmlX(!a,temp1) || deftext.!ptoc'</A>'
      end
    call GenerateTOC 1,ptocstart,i-1,ptocmost,ptocleast,'<P>'temp1,PTOCname
    end
 
  /*----- :QREF     -----*/
  when TAGnameuc=='QREF'
    then datastr = ResolveRef(!qref,TAGoptions) || TAGtext
 
  /*----- :SPOTREF  -----*/
  when TAGnameuc=='SPOTREF'
    then datastr = ResolveRef(!spotref,TAGoptions) || TAGtext
 
  /*----- :TLIST    -----*/
  when TAGnameuc=='TLIST' then call GenerateFigList !tref
 
  /*----- :TOC      -----*/
  when TAGnameuc=='TOC' then do
    _toccnt = _toccnt - 1
    if _toccnt=0 & saverec.!toc.0>tocsuppress
      then call GenerateTOC 0,1,saverec.!toc.0,minhdlv,tocmax,,
                  list.!toc.5 || HtmlX('H1')   ||,
                  HtmlX(!a,'NAME="'TOCname'"') ||,
                  deftext.!toc'</A></H1>',TOCname
    if TAGtext \= '' then call WrtLine outputp_file, SymbSub(TAGtext)
    end
 
  /*----- :TREF     -----*/
  when TAGnameuc=='TREF' then datastr=ResolveRef(!tref,TAGoptions)||TAGtext
 
  /*----- Unknown, just pass it back, but don't rescan it -----*/
  otherwise do
    datastr = TAGstringall
    ?rescan = 0
    end
  end
 
End_ProcessTag2:
if datastr = omitrecord then datastr = ''
pt2result = datastr || TAGresidual
if ?trcparse then call Here2 pt2result
return pt2result
 
 
/*------------------------------------------------------------------*/
/* SetColumns: Evaluate a tag with COLS, CWIDTHS and ARRANGE. Sets: */
/*    ORIG_LINEWIDTH   - Line length req'd for 1st line of entity   */
/*    NUMCOLS_PHYSICAL - Number of physical columns in a line       */
/*    NUMCOLS_LOGICAL  - Number of logical columns in a row         */
/*    COLWIDTHLOGPCT.log - This column's percent width of the line  */
/*    COLWIDTHPHYS.phy - Actual width of this physical column       */
/*    COLWIDTHPHYSPCT.phy - This column's percent width of the line */
/*    TBLCOLSPAN.log   - Number of physical cols spanned by this    */
/*                       logical column                             */
/*    TBLROWSPAN.log   - Number of physical rows spanned by this    */
/*                       logical column                             */
/*    TBLCOLSTRT.log   - Physical col where this logical col starts */
/*    TBLROWSTRT.log   - Physical row where this logical col starts */
/*    "phy" is a number from 1 to "NUMCOLS_PHYSICAL"                */
/*    "log" is a number from 1 to "NUMCOLS_LOGICAL"                 */
/* Usage:  call SetColumns  <FORCE>, <linewidth>                    */
/*    If "FORCE" is specified, all arrays are set, even if omitted. */
/*    If "FORCE" not specified, then if neither COLS or CWIDTHS is  */
/*    found, control is returned immediately with no action taken.  */
/*    If 'linewidth' specified, it overrides any linewidth value    */
/*    currently defined                                             */
/*------------------------------------------------------------------*/
SetColumns: rtn='SETCOLUMNS'; trace value tracelist.rtn
parse arg scparms, sclinew
if ?trcparse then call Here1 rtn,scparms','sclinew,sigl,!parse
colstring=GetAttr('COLS',!uc)
if colstring = '' then colstring = GetAttr('CWIDTHS',!uc)
if colstring = '' then if scparms = ''
  then signal End_SetColumns
  else do
    call MsgOut !error 431, ,
        "Number of columns not specified! Assuming COLS='*'", ,
         TAGstringall,!recnumo
    colstring = '*'
    end
parse value 0 with colswithast 1 colwidthphys. 1 numast 1 scphysrownum,
                   1 tblcolspan. 1 tblrowspan.
tblrowstrt.=1; minnumast=99999
if scparms \= ''
  then parse value 0 with orig_linewidth 1 numcols_physical_prev
numcols_physical = words(colstring)
numcols_logical  = numcols_physical
/*----- check ARRANGE= -----*/
arrange = GetAttr('ARRANGE'); ?scarrange=(arrange\='')
if arrange = ''
  then do
    parse value 1 with 1 tblrowstrt. 1 tblrowspan. 1 tblcolspan.
    do i=1 to numcols_logical; tblcolstrt.i=i; end
    end
  else do
    /*----- get max logical column number -----*/
    parse value 0 with numcols_logical 1 tempray. 1 scfndstrt.
    tempstr = translate(arrange,' ','/')
    do while tempstr \= ''
      parse var tempstr atom tempstr
      if datatype(atom,'W') then do
        if atom > numcols_logical then numcols_logical = atom
        tempray.atom = 1
        do c = 1 to atom; if \tempray.c then do
            call MsgOut !warning 433,,
                        'Out-of-sequence ARRANGE cell layout detected',,
                        TAGstringall,!recnumo
            leave
            end
          end
        end
      end
    if htmlrel = 2
      /*----- logical cols must equal physical cols -----*/
      then do
        if numcols_logical > numcols_physical
          then colstring = colstring,
                           copies('* ',numcols_logical-numcols_physical)
        numcols_physical = numcols_logical
        do i=1 to numcols_logical; tblcolstrt.i=i; end
        end
      /*----- calculate ROWSPAN & COLSPAN values -----*/
      else do while arrange \= ''
        parse var arrange tempstr '/' arrange
        atom=''; tempray.=1; scphyscolnum=0; scphysrownum=scphysrownum+1
        do while tempstr \= ''
          parse var tempstr atom tempstr
          scphyscolnum = scphyscolnum + 1
          tblrowspan.atom = tblrowspan.atom + tempray.atom
          tempray.atom = 0
          if tblrowspan.atom = 1
            then tblcolspan.atom = tblcolspan.atom + 1
          if \scfndstrt.atom then do
            tblrowstrt.atom = scphysrownum
            tblcolstrt.atom = scphyscolnum
            scfndstrt.atom = 1
            end
          end
        end
    end
/*----- evaluate the COLS= string -----*/
select
  when datatype(sclinew,'N') then c = trunc(sclinew)
  when orig_linewidth > 0    then c = orig_linewidth
  otherwise                       c = linewidth.llcnt
  end
if htmlrel = 2
  then avail_for_text = c - ,
             ( numcols_physical * ( ctable2len.7 + ctable2len.8 ) ) -,
             ( ctable2len.4 * ( numcols_physical + 1 ) )
  else avail_for_text = word(sclinew '1200',1)
/*----- process 'hardcoded' widths -----*/
do c = 1 to numcols_physical
  type=''; suffix=''
  atom = translate(word(colstring,c),'.',',')
  i = verify(atom,'0123456789.')
  if i = 0
    then number = atom
    else do
      number=left(atom,i-1); atom=substr(atom,i)
      j = verify(atom,numchars,'M')
      if j = 0
        then type = atom
        else do; type=left(atom,j-1); suffix=substr(atom,j); end
      end
  if \datatype(number,'N') then number = 1
  select
    when type = 'I'  then colwidthphys.c = max(1,number * 10)
    when type = 'CM' then colwidthphys.c = max(1,number * 3.937)
    when type = 'M'  then colwidthphys.c = max(1,number * 2)
    when type = 'MH' then colwidthphys.c = max(1,number * 2)
    when type = 'MM' then colwidthphys.c = max(1,number * .3937)
    when type = 'P'  then colwidthphys.c = max(1,number * 1.666)
    when type = 'W'  then colwidthphys.c = max(1,length(w.suffix))
    when type = '*'  then do
      if \datatype(number,'W') then number = trunc(number)
      colswithast = colswithast + 1
      numast = numast + number
      colwidthphys.c = -number
      if number < minnumast then minnumast = number
      end
    otherwise colwidthphys.c = max(1,number)
    end
  if colwidthphys.c > 0 then do
    colwidthphys.c = trunc(colwidthphys.c + 0.5)
    avail_for_text = avail_for_text - colwidthphys.c
    end
  end c
/*----- if any "*" specified, process them now -----*/
if colswithast >  0 then do
  if minnumast <= 0 then minnumast = 1
  astsize = trunc( ( avail_for_text / ( numast / minnumast ) ) + 0.5 )
  if astsize < 0 then astsize = -astsize
  if astsize < 1 then astsize = 1
  do c = 1 to numcols_physical
    if colwidthphys.c < 0
      then colwidthphys.c = trunc(-((colwidthphys.c/minnumast)*astsize))
    end c
  end
/*----- calculate final line length -----*/
if htmlrel = 2
  then do
    colwidthphys.!totlen = ctable2len.4
    do c = 1 to numcols_physical
      colwidthphys.!totlen = colwidthphys.!totlen +,
         ctable2len.7 + colwidthphys.c + ctable2len.8 + ctable2len.4
      end c
    end
  else do
    colwidthphys.!totlen = 0
    do c = 1 to numcols_physical
      colwidthphys.!totlen = colwidthphys.!totlen + colwidthphys.c
      end c
    end
if prevtotlen \= 0
 then if colwidthphys.!totlen \= prevtotlen then do
  if htmlrel = 2
    then do
      c = numcols_physical
      colwidthphys.c = colwidthphys.c + prevtotlen - colwidthphys.!totlen
      colwidthphys.c = max(1,colwidthphys.c)
      end
    else do
      pct = prevtotlen / colwidthphys.!totlen
      do c=1 to numcols_physical; colwidthphys.c=colwidthphys.c * pct; end
      end
  colwidthphys.!totlen = prevtotlen
  end
prevtotlen = colwidthphys.!totlen
j = 0
do c=1 to numcols_physical; j = j + colwidthphys.c; end
do c=1 to numcols_physical; colwidthphyspct.c=(colwidthphys.c / j) * 100; end
if scparms \= ''
  /*----- first process of this tag, save orig values -----*/
  then do
    orig_linewidth = prevtotlen
    colwidthphyspct_orig.0 = numcols_physical
    do c=1 to numcols_physical; colwidthphyspct_orig.c=colwidthphyspct.c; end
    end
  /*----- calc spanning values if HTML>=3 & no ARRANGE -----*/
  else if htmlrel>=3 & \?scarrange then do
    parse value 0 with logicalcol 1 origtot 1 thistot
    do c = 1 to numcols_logical - 1
      origtot = origtot + colwidthphyspct.c
      colspan = 0
      do while thistot < origtot
        logicalcol = logicalcol + 1
        colspan = colspan + 1
        thistot = thistot + colwidthphyspct_orig.logicalcol
        end
      if logicalcol = colwidthphyspct_orig.0 then do
        logicalcol=logicalcol-1; colspan=colspan-1
        end
      tblcolspan.c = colspan
      colspan = 0
      end c
    tblcolspan.numcols_logical = colwidthphyspct_orig.0 - logicalcol
    end
/*----- set logical column widths -----*/
do i = 1 to numcols_logical
  j=tblcolstrt.i; colwidthlogpct.i=0
  do k = j to j + tblcolspan.i - 1
    colwidthlogpct.i = colwidthlogpct.i + colwidthphyspct_orig.k
     end
  end
End_SetColumns:
if ?trcparse then call Here2
return
 
/*------------------------------------------------------------------*/
/* SetAlignH: Evaluate ALIGN= parameter and set "colalignh." array. */
/* Usage:     call SetAlignH                                        */
/*------------------------------------------------------------------*/
SetAlignH: rtn='SETALIGNH'; trace value tracelist.rtn
if ?trcparse then call Here1 rtn,,sigl,!parse
colalignh.='L'; colfill.=' '; string=GetAttr('ALIGN',!uc)
if string \= '' then do
  colalignh. = left(word(string,words(string)),1)
  colnum = 0; fillc = ' '
  do while string\=''
    parse var string atom string; atom = left(atom,1)
    if pos(atom,'LCR') = 0 then do
      if atom = 'F' then parse var string fillc string
      if atom = '/' then parse var string . . string
      iterate
      end
    colnum = colnum + 1
    colalignh.colnum = atom
    colfill.colnum = left(fillc,1)
    fillc = ' '
    end
  end
if ?trcparse then call Here2
return
 
/*------------------------------------------------------------------*/
/* SetAlignV: Evaluate VALIGN= parameter and set "colalignv." array.*/
/* Usage:     call SetAlignV                                        */
/*------------------------------------------------------------------*/
SetAlignV: rtn='SETALIGNV'; trace value tracelist.rtn
if ?trcparse then call Here1 rtn,,sigl,!parse
colalignv.='T'; string=GetAttr('VALIGN',!uc)
if string \= '' then do
  colalignv. = left(word(string,words(string)),1)
  do colnum = 1 by 1 while string\=''
    parse var string atom string; atom = left(atom,1)
    select
      when atom = 'B' then colalignv.colnum = atom
      when atom = 'C' then colalignv.colnum = atom
      otherwise            colalignv.colnum = 'T'
      end
    end
  end
if ?trcparse then call Here2
return
 
/*------------------------------------------------------------------*/
/* SetConcat: Evaluate CONCAT= parameter and set "colconcat." array.*/
/* Usage:     call SetConcat                                        */
/*------------------------------------------------------------------*/
SetConcat: rtn='SETCONCAT'; trace value tracelist.rtn
if ?trcparse then call Here1 rtn,,sigl,!parse
colconcat.=0; string=GetAttr('CONCAT',!uc)
if string \= '' then do
  colconcat. = ( left(word(string,words(string)),1) = 'N' )
  do colnum = 1 by 1 while string\=''
    parse var string atom string; atom=left(atom,1)
    colconcat.colnum = ( atom = 'N' )
    end
  end
if ?trcparse then call Here2
return
 
/*------------------------------------------------------------------*/
/* SetShade: Evaluate SHADE= parameter and set "colshade." array.   */
/* Usage:    call SetShade                                          */
/*------------------------------------------------------------------*/
SetShade: rtn='SETSHADE'; trace value tracelist.rtn
if ?trcparse then call Here1 rtn,,sigl,!parse
colshade.=''; string=GetAttr('SHADE',!uc)
if string \= '' then do
  colshade. = word(string,words(string))
  colnum = 0
  do while string\=''
    parse var string atom string
    if wordpos(atom,shades) = 0 then atom = ''
    colnum = colnum + 1
    colshade.colnum = atom
    end
  end
if ?trcparse then call Here2
return
 
/*------------------------------------------------------------------*/
/* SetHP: Evaluate HP= parameter and set "colHP./colEHP." arrays.   */
/* Usage: call SetHP                                                */
/*------------------------------------------------------------------*/
SetHP: rtn='SETHP'; trace value tracelist.rtn
if ?trcparse then call Here1 rtn,,sigl,!parse
parse value '' with colHP. colEHP.; string=GetAttr('HP',!uc)
if string \= '' then do
  atom=left(word(string,words(string)),1)   /* set default using    */
  i2='HP'atom;  colHP. =sym.!tagtbl.i2      /*   last value         */
  i2='EHP'atom; colEHP.=sym.!tagtbl.i2
  do colnum = 1 by 1 while string\=''       /* set indiv values     */
    parse var string atom string; atom=left(atom,1)
    if atom = '0'
      then do; colHP.colnum=''; colEHP.colnum=''; end
      else do
        i2= 'HP'atom; colHP.colnum=sym.!tagtbl.i2
        i2='EHP'atom;colEHP.colnum=sym.!tagtbl.i2
        end
    end
  end
if ?trcparse then call Here2
return
 
/*------------------------------------------------------------------*/
/* GenCellStart: Generate start of an HTML 3 table cell             */
/* Usage:        str = GenCellStart(<text>)                         */
/*------------------------------------------------------------------*/
GenCellStart: rtn='GENCELLSTART'; trace value tracelist.rtn
if ?trcparse then call Here1 rtn,arg(1),sigl,!parse
if ?thd | ?tft then celltag = 'TH'; else celltag = 'TD'
gcstr = celltag || htmlx.celltag
gcsi = colalignh.col;      gcstr = gcstr   'ALIGN="'aligntexth.gcsi'"'
gcsi = colalignv.col;      gcstr = gcstr  'VALIGN="'aligntextv.gcsi'"'
if tblrowspan.col > 1 then gcstr = gcstr 'ROWSPAN="'tblrowspan.col'"'
if tblcolspan.col > 1 then gcstr = gcstr 'COLSPAN="'tblcolspan.col'"'
if colshade.col \= ''
  then do; gsci=colshade.col; gcstr=gcstr shade.gsci; end
/*----- set width if requested and not spanning columns -----*/
gcsi = trunc(colwidthlogpct.col + .5 )
if gcsi > 0 then gcstr = gcstr 'WIDTH="'gcsi'%"'
endcelltag = colEHP.col||SetUpTag('TABLE',2)||cellscale_e'</'celltag'>'
gcsrslt = '<'gcstr'>'  ||cellscale_s||SetUpTag('TABLE',1)||,
          colHP.col||RevTag(!s)||arg(1)
_BRcount = _BRcount + colconcat.col
if ?trcparse then call Here2 gcsrslt
return gcsrslt
 
/*------------------------------------------------------------------*/
/* GenCellEnd: Generate end of a potentially-open HTML 3 table cell */
/* Usage:      str = GenCellEnd()                                   */
/*------------------------------------------------------------------*/
GenCellEnd: rtn='GENCELLEND'; trace value tracelist.rtn
  if ?trcparse then call Here1 rtn,arg(1),sigl,!parse
  gcestr = ERevTag(!s) || defcelldata || endcelltag
  parse value '' with defcelldata endcelltag
  _BRcount = max(0,_BRcount-colconcat.col)
  if ?trcparse then call Here2 gcestr
  return gcestr
 
/*------------------------------------------------------------------*/
/* GenRowStart: Generate start of an HTML 3 table row               */
/* Usage:        str = GenRowStart()                                */
/*------------------------------------------------------------------*/
GenRowStart: rtn='GENROWSTART'; trace value tracelist.rtn
  if ?trcparse then call Here1 rtn,arg(1),sigl,!parse
  endrowtag = '</TR>'
  if ?trcparse then call Here2 HtmlX(!tr)
  return HtmlX(!tr)
 
/*------------------------------------------------------------------*/
/* GenRowEnd:  Generate end of a potentially-open HTML 3 table row  */
/* Usage:      str = GenRowEnd()                                    */
/*------------------------------------------------------------------*/
GenRowEnd: rtn='GENROWEND'; trace value tracelist.rtn
  if ?trcparse then call Here1 rtn,arg(1),sigl,!parse
  grestr = ''
  if endcelltag \= '' then do
    grestr = GenCellEnd()
    do grei = 1 to max(numcols_logical-col,0)
      col = col + 1
      grestr = grestr || GenCellStart(break) || GenCellEnd()
      end
    grestr = grestr || endrowtag
    end
  endrowtag = ''
  if ?trcparse then call Here2 grestr
  return grestr
 
/*------------------------------------------------------------------*/
/* GenListItemStart: Return start-of-list-item data                 */
/* Usage:            string = GenListItemStart()                    */
/*------------------------------------------------------------------*/
GenListItemStart:
  if listitem.listnest.!table
    then glisstr = RevTag(!s)
    else glisstr = ''
  return glisstr
 
/*------------------------------------------------------------------*/
/* SetListItemEnd: Set contents of end-of-list-item                 */
/* Usage:          call SetListItemEnd text                         */
/*------------------------------------------------------------------*/
SetListItemEnd:
  listitem.listnest.0 = arg(1)
  ?listactive.listnest = true
  return
/*------------------------------------------------------------------*/
/* GenListItemEnd: Return end-of-list-item data                     */
/* Usage:          string = GenListItemEnd()                        */
/*------------------------------------------------------------------*/
GenListItemEnd:
  if ?listactive.listnest
    then if listitem.listnest.!table
      then gliestr = ErevTag(!s) || listitem.listnest.0
      else gliestr = listitem.listnest.0
    else gliestr = ''
  return gliestr
 
/*------------------------------------------------------------------*/
/* StartNewList:    Setup to start a new list                       */
/* EndExistingList: Close out existing list                         */
/*------------------------------------------------------------------*/
StartNewList:
  listnest                  = listnest + 1
  ?listactive.listnest      = 0
  listitem.listnest.0       = ''
  listitem.listnest.!cnt    = 0
  listitem.listnest.!oltype = ''
  listitem.listnest.!revnest= 0
  listitem.listnest.!table  = 0
  listitem.listnest.!type   = 0
  return
EndExistingList:
  listitem.listnest.0       = ''
  ?listactive.listnest      = 0
  listnest                  = listnest - 1
  return
 
/*------------------------------------------------------------------*/
/* Write out prefix and suffix lines for an HTML 2 table            */
/*------------------------------------------------------------------*/
TablePrefix: rtn='TABLEPREFIX'; trace value tracelist.rtn
  if ?trcparse then call Here1 rtn,arg(1),sigl,!parse
  if \?tableprefix then do
    ?tableprefix = true
    do i = 1 to saverec.!tdesc.0
      if i = 1
        then call ProcTag '<P>'saverec.!tdesc.i, !force
        else call ProcTag      saverec.!tdesc.i, !force
      end
    saverec.!tdesc.0 = 0
    call ProcTag cellscale_s||Pre()'<TT>', !force
    end
  if ?trcparse then call Here2
  return
 
TableSuffix: rtn='TABLESUFFIX'; trace value tracelist.rtn
  if ?trcparse then call Here1 rtn,arg(1),sigl,!parse
  call ProcTag '</TT>'EPre()||cellscale_e'<P>', !force
  _PREcount = max(0,_PREcount-1)
  if ?trcparse then call Here2
  return
 
 
/*------------------------------------------------------------------*/
/* Format an HTML 2 table: generate a table using a monospaced font */
/*------------------------------------------------------------------*/
TableFormat: rtn='TABLEFORMAT'; trace value tracelist.rtn
  if ?trcparse then call Here1 rtn,arg(1),sigl,!parse
  numrows=row; numcols=numcols_physical
  /*----- construct frame & header lines -----*/
  if frameline = '' then do
    frameline = BuildFrame(2)
    hdrline   = translate(frameline,ctable2.6,ctable2.5)
    end
  /*----- write each row with formatted columns -----*/
  do r = 1 to numrows
    /*----- insert separator line -----*/
    if ( ?thd & ( r=1 | r=2 ) ) | ( ?tft & r=numrows )
      then call ProcTag hdrline, !force; else call ProcTag frameline, !force
    maxlinesinacol = 0; colray. = ''
    /*----- process each column this row -----*/
    do c = 1 to numcols
      colline=rowcol.r.c; linesthiscol=0; temp=''; cwidth=colwidthphys.c
      /*----- format text to fit in the column -----*/
      do while colline \= ''
        parse var colline atom colline
        /*----- see if a new line should be started -----*/
        do ni = 1 to words(newcol_tags)
          nj = word(newcol_tags,ni)
          if pos(nj,atom) > 0 then do
            parse var atom atom (nj) rpart
            select
              when atom  \= '' then colline = nj||rpart colline
              when rpart \= '' then colline = rpart colline
              otherwise nop
              end
            if atom = '' then atom = nj
            leave ni
            end
          end
        if InternalWidth(atom,0) > cwidth then do
          colline = substr(atom,cwidth+1) colline
          atom = left(atom,cwidth)
          end
        ?newline = ( wordpos(atom,newcol_tags) > 0 )
        if ?newline |,
           InternalWidth(temp atom,0) - (temp="") > cwidth then do
          linesthiscol = linesthiscol + 1
          colray.c.linesthiscol = temp
          maxlinesinacol = max(maxlinesinacol,linesthiscol)
          temp = ''; if ?newline then atom = ''
          end
        if temp == '' then temp=atom; else temp=temp atom
        end
      if temp \= '' then do
        linesthiscol = linesthiscol + 1
        colray.c.linesthiscol = temp
        maxlinesinacol = max(maxlinesinacol,linesthiscol)
        end
      end c
    /*----- format text for each column this row -----*/
    do i = 1 to maxlinesinacol
      temp = ctable2.4
      do c = 1 to numcols
        cwidth = InternalWidth(colray.c.i,colwidthphys.c)
        select
          when colalignh.c='C' then ftmp=center(colray.c.i,cwidth)
          when colalignh.c='R' then ftmp= right(colray.c.i,cwidth)
          otherwise                 ftmp=  left(colray.c.i,cwidth)
          end
        temp = temp || ctable2.7 || ftmp || ctable2.8 || ctable2.4
        end c
      call ProcTag temp, !force
      end i
    end r
  ?thd = false
  if ?trcparse then call Here2
  return
 
/*----- BuildFrame -----*/
BuildFrame: rtn='BUILDFRAME'; trace value tracelist.rtn
  parse arg bfnum
  if ?trcparse then call Here1 rtn,bfnum,sigl,!parse
  bf  = ctable2.1 ||,
        copies(ctable2.5,colwidthphys.!totlen - ctable2len.1 - ctable2len.3) ||,
        ctable2.3
  sum = ctable2len.4
  j   = ctable2len.7 + ctable2len.8 + ctable2len.4
  do c = 1 to numcols_physical
    sum = sum + colwidthphys.c + j
    bf = overlay(ctable2.2,bf,sum)
    end c
  if bfnum = 2 then do
    sum = ctable2len.4
    do c = 1 to numcols_physical_prev
      sum = sum + colwidthphys_prev.c + j
      bf = overlay(ctable2.2,bf,sum)
      end c
    end
  if ?trcparse then call Here2 bf
  return bf
 
/*----- return column width or real string length after     -----*/
/*----- adjusting for '&#xxx;', '&xxx;' and '<xxx>' symbols -----*/
/*----- len = InternalWidth(string,{colwidthphys|0})        -----*/
InternalWidth: rtn='INTERNALWIDTH'; trace value tracelist.rtn
  parse arg iwstring, iwlen
  if ?trcparse then call Here1 rtn,iwstring','iwlen,sigl,!parse
  iwcount=0; iwtemp=iwstring
  do while iwtemp \= ''                /* adjust for '&#32;'-type   */
    parse var iwtemp '&#' iwnum ';' iwtemp
    if datatype(iwnum,'W') then iwcount = iwcount + length(iwnum) + 2
    end
  iwtemp = translate(iwstring)
  do while iwtemp \= ''                /* adjust for '&gt;'-type    */
    parse var iwtemp '&' iwnum ';' iwtemp
    if iwnum \== ''
      then if verify(iwnum,alphaucnum) = 0
        then iwcount=iwcount+length(iwnum) + 1
    end
  iwtemp = iwstring
  do while iwtemp \= ''                /* adjust for '<xxxx>' tags  */
    parse var iwtemp '<' iwstr '>' iwtemp
    if iwstr \= '' then iwcount = iwcount + length(iwstr) + 2
    end
  if iwlen = 0
    then iwlen = length(iwstring) - iwcount
    else iwlen = iwlen + iwcount
  if ?trcparse then call here2 iwlen
  return iwlen
 
/*------------------------------------------------------------------*/
/* HorizWidth:  numcols = HorizWidth(value)     0=invalid value     */
/*------------------------------------------------------------------*/
HorizWidth: rtn='HORIZWIDTH'; trace value tracelist.rtn
  parse upper arg hzstr .
  if ?trcparse then call Here1 rtn,hzstr,sigl,!parse
  hztype=''; hzsuff=''
  hzatom = translate(hzstr,'.',',')
  i = verify(hzatom,'0123456789.')
  if i = 0
    then hznum = hzatom
    else do
      hznum=left(hzatom,i-1); hzatom=substr(hzatom,i)
      j = verify(hzatom,numchars,'M')
      if j = 0
        then hztype = hzatom
        else do; hztype=left(hzatom,j-1); hzsuff=substr(hzatom,j); end
      end
  if \datatype(hznum,'N') then hznum = linewidth.1
  select
    when hztype = 'I'  then hzrslt = hznum * 10
    when hztype = 'CM' then hzrslt = hznum * 3.937
    when hztype = 'M'  then hzrslt = hznum * 2
    when hztype = 'MH' then hzrslt = hznum * 2
    when hztype = 'MM' then hzrslt = hznum * .3937
    when hztype = 'P'  then hzrslt = hznum * 1.666
    when hztype = 'W'  then hzrslt = length(w.hzsuff)
    otherwise               hzrslt = hznum
    end
  if ?trcparse then call Here2 hzrslt
  return hzrslt
 
/*------------------------------------------------------------------*/
/* TabDataRec: Create a record for within :TABDATA/:ETABDATA        */
/*------------------------------------------------------------------*/
TabDataRec: rtn='TABDATAREC'; trace value tracelist.rtn
  parse arg tdrstr, tdrtab .
  if ?trcparse then call Here1 rtn,tdrstr','tdrtab,sigl,!parse
  if colalignh.1\='L' then if left(tdrstr,1)=tdrtab
    then tdrstr = substr(tdrstr,2)
  tdrrslt = ''
  do c = 1 by 1 while tdrstr \= ''
    parse var tdrstr coldata (tdrtab) tdrstr
    if c > numcols_physical
      then tdrrslt = tdrrslt || coldata'  '
      else do
        cwidth = InternalWidth(coldata,colwidthphys.c)
        tdrfillc = colfill.c
        select
          when colalignh.c='C' then tdrtemp=center(coldata,cwidth,tdrfillc)
          when colalignh.c='R' then tdrtemp= right(coldata,cwidth,tdrfillc)
          otherwise                 tdrtemp=  left(coldata,cwidth,tdrfillc)
          end
        tdrrslt = tdrrslt || tdrtemp || tdrfillc||tdrfillc
        end
    end
  if ?trcparse then call Here2 tdrrslt
  return tdrrslt
 
/*------------------------------------------------------------------*/
/* DentryRec: Create a record for within :DIRECT/:EDIRECT           */
/*------------------------------------------------------------------*/
DentryRec: rtn='DENTRYREC'; trace value tracelist.rtn
  parse arg linetext
  if ?trcparse then call Here1 rtn,linetext,sigl,!parse
  outrec = ''
  do c = 1 by 1 while linetext\=''
    parse value GetValue(linetext) with coldata (nl) linetext
    cwidth = InternalWidth(coldata,colwidthphys.c)
    select
      when colalignh.c='C' then ftmp=center(coldata,cwidth)
      when colalignh.c='R' then ftmp= right(coldata,cwidth)
      otherwise                 ftmp=  left(coldata,cwidth)
      end
    outrec = outrec || ftmp || '  '
    end
  if ?trcparse then call Here2 outrec
  return outrec
 
/*------------------------------------------------------------------*/
/* Eval_SETDVCF: Evaluate a ".SETDVCF" macro                        */
/* Usage:   call Eval_SETDVCF name { ON | OFF }                     */
/*------------------------------------------------------------------*/
Eval_SETDVCF: rtn='EVAL_SETDVCF'; trace value tracelist.rtn
  parse upper arg esname esonoff .
  if ?trcparse then call Here1 rtn,esname','esonoff,sigl,!parse
  if esonoff='ON' then sym.!dvcf.esname=1; else sym.!dvcf.esname=''
  if ?trcparse then call Here2
  return
 
/*------------------------------------------------------------------*/
/* Eval_SE: Evaluate a ".SE" command                                */
/* Usage:   call Eval_SE "name <=> value"                           */
/*------------------------------------------------------------------*/
Eval_SE: rtn='EVAL_SE'; trace value tracelist.rtn
  parse arg esname esremainder
  if ?trcparse then call Here1 rtn,esname','esremainder,sigl,!parse
  if translate(esremainder) = 'OFF'    /* cancelling a symbol?      */
    then parse value '',               /*  yes, turn it "off"       */
               with  sym.!amp.esname sym.!ampd.esname
    else do                            /*   no, do the assignment   */
      if pos('=',esname) > 0 then do   /* '=' is optional           */
        parse var esname esname '=' es2
        esremainder = es2 esremainder
        end
      if left(word(esremainder,1),1) = '='
        then do; ?isqstring=0; parse var esremainder '=' esremainder; end
        else     ?isqstring=1
      /*----- determine type of assignment and do it -----*/
      parse var esremainder esew1 esewz
      esew1 = translate(esew1)
      select
        when esew1 = 'INDEX' then do
          parse value GetValue(esewz) with esew2 (nl) esewz
          parse value GetValue(esewz) with esew3 (nl)
          estext = pos(SymbSub(esew3),SymbSub(esew2))
          end
        when esew1 = 'SUBSTR' then do
          parse value GetValue(esewz) with esew2 (nl) esewz
          parse value GetValue(esewz) with esew3 (nl) esewz
          parse value GetValue(esewz) with esew4 (nl)
          if datatype(esew3,'W') then if datatype(esew4,'W')
            then estext = substr(SymbSub(esew2),esew3,esew4)
            else estext = substr(SymbSub(esew2),esew3)
          end
        when left(esew1,1)\="'" & verify(esremainder,'+-/*','M')>0 then do
          signal on syntax  name EVALERR
          signal on novalue name EVALERR
          signal on halt    name EVALERR
          esremainder = SymbSub(esremainder)
          interpret 'estext=trunc('translate(esremainder,'%','/')')'
          signal on syntax  name TRAPIT
          signal on novalue name TRAPIT
          signal on halt    name TRAPIT
          end
        when ?isqstring then do          /* "qstring"-type assignment */
          parse value SymbSub(esremainder) with estext (nl) .
          estext = strip(estext,,"'")
          end
        otherwise parse value SymbSub(GetValue(esremainder)) with estext (nl) .
        end
      call DefSymbol SymbSub(esname), estext
      end
  if ?trcparse then call Here2
  return
 
EVALERR:
  call MsgOut !error 454, 'Invalid arithmetic expression!',cword arg(1),,
              'Expression resolves to:' space(esremainder),!recnum
  signal on syntax  name TRAPIT
  signal on novalue name TRAPIT
  signal on halt    name TRAPIT
  call DefSymbol esname,"0"
  return
 
/*------------------------------------------------------------------*/
/* Eval_NAMEIT: Evaluate a ".NAMEIT" macro                          */
/* Usage:   call Eval_NAMEIT "symbol=name text='...' <gmltype=xx>   */
/*------------------------------------------------------------------*/
Eval_NAMEIT: rtn='EVAL_NAMEIT'; trace value tracelist.rtn
  parse arg enstring
  if ?trcparse then call Here1 rtn,enstring,sigl,!parse
  call EvalTag enstring; symbol=GetAttr('SYMBOL')
  stext=SymbSub(GetAttr('TEXT')); hilite=GetAttr('GMLTYPE',!uc)
  if hilite\=''
    then if wordpos(hilite,gmltypes 'XMP RK TP')=0 then do
      call MsgOut !error 458, ,
                  hilite 'is an invalid GMLTYPE value',cmdremainder, !recnum
      hilite = ''
      end
  if hilite \= '' then do
    if hilite = 'XMP' then hilite = 'XPH'
    if sym.!tag.hilite = ''            /* direct substitute avail?  */
      then stext = ':'hilite'.'stext':E'hilite'.' /* no, gen ":"tag */
      else do                          /*   yes, use substitute     */
        temp2 = 'E'hilite
        stext = sym.!tag.hilite || stext || sym.!tag.temp2
        end
    end
  call DefSymbol symbol, stext
  if ?trcparse then call Here2
  return
 
/*------------------------------------------------------------------*/
/* Eval_Expression:  Evaluate a "comparand1 test comparand2"        */
/* Usage: {0|1} = Eval_Expression(comp1,test,comp2,control-word)    */
/*------------------------------------------------------------------*/
Eval_Expression: rtn='EVAL_EXPRESSION'; trace value tracelist.rtn
  parse arg eecomp1, eeif, eecomp2, eecword
  if ?trcparse
    then call Here1 rtn,eecomp1','eeif','eecomp2','eecword,sigl,!parse
  eecomp1=SymbSub(eecomp1); eecomp2=SymbSub(eecomp2)
  eeif = translate(eeif)
  select
    when wordpos(eeif,'EQ =')        > 0 then eeif = 1
    when wordpos(eeif,'NE *= \= <>') > 0 then eeif = 2
    when wordpos(eeif,'GT >')        > 0 then eeif = 3
    when wordpos(eeif,'LT <')        > 0 then eeif = 4
    when wordpos(eeif,'GE >=')       > 0 then eeif = 5
    when wordpos(eeif,'LE <=')       > 0 then eeif = 6
    otherwise eeif = 0
    end
  select
    when eeif = 1 then ?eecondx = ( eecomp1  = eecomp2 )
    when eeif = 2 then ?eecondx = ( eecomp1 \= eecomp2 )
    when eeif = 3 then ?eecondx = ( eecomp1  > eecomp2 )
    when eeif = 4 then ?eecondx = ( eecomp1  < eecomp2 )
    when eeif = 5 then ?eecondx = ( eecomp1 >= eecomp2 )
    when eeif = 6 then ?eecondx = ( eecomp1 <= eecomp2 )
    otherwise do
      call MsgOut !error 451, "Invalid '"eecword"' condition",commandmacro
      ?eecondx = false
      end
    end
  if ?trcparse then call Here2 ?eecondx
  return ?eecondx
 
/*------------------------------------------------------------------*/
/* DefSymbol: Define one or more 'normal' &symbol(s)                */
/* Usage:     call DefSymbol name, value <, name2, value2, ... >    */
/*------------------------------------------------------------------*/
DefSymbol:
  do dsi = 1 by 2;
    dsname = arg(dsi)
    if dsname == '' then leave dsi
    sym.!amp.dsname  = arg(dsi+1)
    sym.!ampd.dsname = 1
    end
  return
 
/*------------------------------------------------------------------*/
/* SymbSub:  Replace any &variables found in the passed string      */
/* string = SymbSub(string)                                         */
/*------------------------------------------------------------------*/
SymbSub: rtn='SYMBSUB'; trace value tracelist.rtn
  parse arg ssin
  if ( \?su & _macronest=0 ) | pos('&',ssin) = 0 then return ssin
  if ?trcparse then call Here1 rtn,ssin,sigl,!parse
  do forever
                   ssb1=pos("&E'",ssin)
    if ssb1=0 then ssb1=pos("&L'",ssin)
    if ssb1=0 then ssb1=pos("&T'",ssin)
    if ssb1=0 then ssb1=pos("&U'",ssin)
    if ssb1=0 then ssb1=pos("&V'",ssin)
    if ssb1=0 then ssb1=pos("&W'",ssin)
    if ssb1=0 then ssb1=pos("&X'",ssin)
    if ssb1=0 then leave
    ssleft = left(ssin,ssb1-1)
    parse value substr(ssin,ssb1) with sstype 3 4 ssmid ssright
    select
      when sstype='&E'
        then do; ssmid2=SymbSub2(ssmid); ssmid=(ssmid\=ssmid2); end
      when sstype='&L' then ssmid = length(SymbSub2(ssmid))
      when sstype='&T' then do
        ssmid=SymbSub2(ssmid)
        if datatype(ssmid,'W') | ssmid='' then ssmid='N'; else ssmid='C'
        end
      when sstype='&U' then ssmid = translate(SymbSub2(ssmid))
      when sstype='&W' then ssmid = length(SymbSub2(ssmid))
      when sstype='&X' then do
        ssmid = translate(SymbSub2(ssmid))
        if verify(ssmid,hexchars) = 0
          then ssmid=x2c(ssmid); else ssmid='0'
        end
      otherwise nop
      end
    ssin = ssleft || ssmid ssright
    end
  ssin = SymbSub2(ssin)
  if ?trcparse then call Here2 ssin
  return ssin
 
SymbSub2:
  parse arg ssstr
  symvalid = '@#$*ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' || symchars
  SymbSub2Loop:
  ?sssubdone = 0                       /* nothing has been done yet */
  ssstart = length(ssstr)              /* starting scan position    */
  do forever                           /* scan from right-to-left   */
    if ssstart < 1 then leave
    ssj = lastpos('&',ssstr,ssstart)   /* character in the string?  */
    if ssj = 0 then leave              /*   no, all done so quit    */
    do ssi = ssj+2 to length(ssstr)    /* find end of symbol name   */
      if pos(translate(substr(ssstr,ssi,1)),symvalid)=0 then leave
      end ssi
    ssc1 = substr(ssstr,ssi,1)         /* get 1st non-symbol char   */
    if ssc1='.' | ssc1=';'             /* include this ending char? */
      then ssi = ssi + 1               /*   yes, include it too     */
    sstemp  = substr(ssstr,ssj,ssi-ssj)/*end-of-name found, copy it */
    ssstr = delstr(ssstr,ssj,ssi-ssj)  /* remove from input string  */
    ssym = substr(sstemp,2)            /* delete leading character  */
    if right(ssym,1) = '.' then ssym = left(ssym,length(ssym)-1)
    if left(ssym,1)=='$' then ssym=translate(ssym)
    parse var ssym 1 ssyma 2 ssymb
    select
      when sym.!amp.ssym\=='' & sym.!amp.ssym\==!ignore /*data here?*/
        then do; ssym=sym.!amp.ssym; ?sssubdone=1; end  /*yes,use it*/
      when sym.!ampd.ssym = 1          /* symbol defined at all?    */
        then do; ssym=sym.!amp.ssym; ?sssubdone=1; end  /*yes,use it*/
      when ssym == '*'                 /* "&*" macro symbol?        */
        then do; ssym=macroparms;    ?sssubdone=1; end  /*yes,use it*/
      when ssyma='*' & datatype(ssymb,'W') /* "&*num" macro symbol? */
        then if ssymb < 1
          then do; ssym=words(macroparms); ?sssubdone=1; end
          else do; ssym=word(macroparms,ssymb); ?sssubdone=1; end
      when ssym = ''                   /* "&" only? (page num)      */
        then ssym = 1                  /*   yes, set to page 1      */
      otherwise ssym = sstemp          /* unknown, set value to name*/
      end
    ssstr = insert(ssym,ssstr,ssj-1)   /* insert into string        */
    ssstart = ssj - 1
    end
  if ?sssubdone then signal SymbSub2Loop /* rescan if changes made  */
  return ssstr
 
/*------------------------------------------------------------------*/
/* MakeXref: Store cross-reference info in the XREF. array          */
/* Usage: result=MakeXref(type,IDval,IDtxt,RIDtxt,cnt,file,hdl,ft)  */
/*    result    - Text to insert at ID= source point                */
/*    type      - Type of xref (e.g. FIG, HDR)                      */
/*    IDval     - ID= value                                         */
/*    IDtxt     - Text to show at ID= point                         */
/*    RIDtxt    - Text to show at REFID= point                      */
/*    cnt       - Counter unique to this type of xref               */
/*    file      - Entry is in this file (current file if omitted)   */
/*    hdl       - "header" level if entry should be placed in TOC   */
/*    ft        - List text if entry for :figlist/:tlist            */
/*------------------------------------------------------------------*/
MakeXref: rtn='MAKEXREF'; trace value tracelist.rtn
  parse arg mxtype,mxid,mxidtext,mxrefidtext,mxcnt,mxfile,mxhdlv,mxft
  if ?trcparse then call Here1 rtn,,
     mxtype','mxid','mxidtext','mxrefidtext','mxcnt','mxfile','mxhdlv','mxft,,
     sigl,!parse
  mxid = translate(mxid)
  if mxid \= ''
    then mxname = mxtype || mxid
    else mxname = reftype.mxtype || mxcnt
  if mxfile = '' then mxfile = currpartl
  mxi=SaveXrefEntry(mxtype,mxcnt,mxfile,mxname,mxid,mxidtext,mxrefidtext,1)
  /*----- handle if possible TOC entry -----*/
  returnjump = ''
  if mxhdlv\='' & ?wanttoc then do
    call SaveRec !toc, mxi mxhdlv bookpart
    select
      when tocret=0 then nop           /* TOCRET=NO */
      when tocret>=2 & ptoclfile\='' & ,/*can I point to PTOC entry?*/
           ptocmost<=mxhdlv & ptocleast>=mxhdlv
        then returnjump = ' HREF="'HREFlink(ptoclfile,PTOCname)'_'mxcnt'"'
      when mxhdlv <= tocmax            /* can I point to TOC entry? */
        then returnjump = ' HREF="&b2htoc_'mxcnt'"'
      otherwise nop
      end
    end
  /*----- save if possible :FIGLIST/:TLIST entry ------*/
  if mxft \= '' then do
    call SaveRec !figlist,mxtype mxi mxcnt mxft
    if ?ftlink then select
      when mxtype=!figref & ?figlistfnd
        then returnjump = ' HREF="'HREFlink(figlistfile,FTprefix||mxname)'"'
      when mxtype=!tref & ( ?tlistfnd | ( ?figlistfnd & \?ftsep ) )
        then returnjump = ' HREF="'HREFlink(tlistfile,  FTprefix||mxname)'"'
      otherwise nop
      end
    end
  /*----- return the linkage -----*/
  mxrslt = HtmlX(!a,'NAME="'xref.mxi.!name'"'returnjump)||mxidtext'</A>'
  if ?trcparse then call Here2 mxrslt
  return mxrslt
 
/*------------------------------------------------------------------*/
/* SaveXrefEntry: Determines entry for XREF and saves the values    */
/* Usage: entry = SaveXrefEntry(type,typecnt,file,name,ID,IDtxt,    */
/*                              REFIDtxt,local)                     */
/*    entry     - XREF.entry.xxx where values were stored           */
/*    type      - Type of xref (e.g. FIG, HDR)                      */
/*    typecnt   - Counter for this type of xref                     */
/*    file      - File where this source point resides              */
/*    name      - <A NAME=xxx> value                                */
/*    ID        - Tag's ID= value (if any)                          */
/*    IDtxt     - Text for ID= point                                */
/*    REFIDtxt  - Text for REFID= point                             */
/*    local     - 1=XREF for this input file, 0=another input file  */
/* Variables set:                                                   */
/* XREF.0               = counter of all cross-refs stored (index)  */
/* XREF.reftype.refid   = index in XREF.x for this ID= (else blank) */
/* XREF.reftype.0       = Number of xref items for this reftype     */
/* XREF.entry.!type     = Type of xref (e.g. FIG, HDR)              */
/* XREF.entry.!ID       = Tag's ID= value (if any)                  */
/* XREF.entry.!IDtxt    = Text to show at ID= location              */
/* XREF.entry.!REFIDtxt = Text to show at REFID= location           */
/* XREF.entry.!name     = <A NAME= value                            */
/* XREF.entry.!file     = Logical file where this item exists       */
/* XREF.entry.!counter  = Counter for this type of XREF             */
/* XREF.entry.!local    = 1=XREF for this input file, 0=another file*/
/*------------------------------------------------------------------*/
SaveXrefEntry:
  parse arg sxtype,sxtypecnt,sxfile,sxname,sxID,sxIDtxt,sxREFIDtxt,sxlocal
  if datatype(xref.sxtype.sxID,'W')    /* seen this tag's ID= yet?  */
    then sxi = xref.sxtype.sxID        /*   yes, get index number   */
    else do                            /*    no, add to arrays      */
      sxi=xref.0 + 1; xref.0=sxi
      if xref.sxtype.0 = '' then xref.sxtype.0 = 0
      xref.sxtype.0 = xref.sxtype.0 + 1
      if sxID \= '' then xref.sxtype.sxID = sxi
      end
  xref.sxi.!type   =sxtype   ;xref.sxi.!IDtxt   =sxIDtxt
  xref.sxi.!ID     =sxID     ;xref.sxi.!REFIDtxt=sxREFIDtxt
  xref.sxi.!name   =sxname   ;xref.sxi.!file    =sxfile
  xref.sxi.!counter=sxtypecnt;xref.sxi.!local   =sxlocal
  return sxi
 
/*------------------------------------------------------------------*/
/* GetXrefEntry: Get entry number for desired XREF                  */
/* Usage: entry = GetXrefEntry(type,ID)                             */
/*    entry     - XREF.entry.x where values were stored             */
/*    type      - Type of xref (e.g. FIG, HDR)                      */
/*    ID        - Tag's ID= value                                   */
/*------------------------------------------------------------------*/
GetXrefEntry:
  parse arg gxtype, gxid
  gxi = xref.gxtype.gxid
  if gxi='' & gxtype=!hdref then gxi = xref.!lenref.gxid
  return gxi
 
/*------------------------------------------------------------------*/
/* ResolveRef: Resolve a reference                                  */
/* Usage: string = ResolveRef(reftype, tagoptions, data-wanted)     */
/*   data-wanted: 'LINK' - hypertext link data (default)            */
/*                'ORIG' - original data shown to the user          */
/*------------------------------------------------------------------*/
ResolveRef: rtn='RESOLVEREF'; trace value tracelist.rtn
  parse arg rrtype, rrline, rrdata
  if ?trcparse then call Here1 rtn,rrtype','rrline','rrdata,sigl,!parse
  if rrdata = '' then rrdata = 'LINK'
  call EvalTag rrline
  refidx = GetXrefEntry(rrtype,GetAttr('REFID'))
  if refidx = ''                       /* REFID=name given & found? */
    then do                            /*    no, show error         */
      call MsgOut ?prcnoxref 440,,
           'Reference not found, following ignored:', TAGstringall
      rrstr = ''
      end
    else if rrdata = 'ORIG'
      then rrstr = xref.refidx.!IDtxt
      else do
        if currpartl = xref.refidx.!file
          then rrfid = ''
          else rrfid = Filecase(xref.refidx.!file)
        k = strip(xref.refidx.!REFIDtxt)
        if GetAttr('FORM',!uc) = 'TEXTONLY'
          then if right(k,1) = '"'
            then k = strip(translate(k,' ','"'))
        rrstr = HtmlX(!a,'HREF="'rrfid'#'xref.refidx.!name'"')||k'</A>'
        end
  if ?trcparse then call Here2 rrstr
  return rrstr
 
/*------------------------------------------------------------------*/
/* HREFlink: Return an HREF-type link to a file & label             */
/* Usage: string = HREFlink(file,label)                             */
/*   string = 'abc.htm#label' or '#label'                           */
/*------------------------------------------------------------------*/
HREFlink: rtn='HREFLINK'; trace value tracelist.rtn
  parse arg hreffid, hreflbl
  if currpartl = hreffid
    then return        '#'hreflbl
    else return hreffid'#'hreflbl
 
/*------------------------------------------------------------------*/
/* RefInTable: Resolve a cross-reference within an HTML 2 table     */
/* Usage: string = RefInTable(reftype)                              */
/*------------------------------------------------------------------*/
RefInTable: rtn='REFINTABLE'; trace value tracelist.rtn
  parse upper arg rrtype .
  if ?trcparse then call Here1 rtn,rrtype,sigl,!parse
  call EvalTag TAGoptions
  refid  = GetAttr('REFID')
  refidx = xref.rrtype.refid
  if refidx = ''                       /* REFID=name given & found? */
    then rrstr = deftext.!t2xref       /*   no, use fill-in text    */
    else rrstr = xref.refidx.!REFIDtxt
  if ?trcparse then call Here2 rrstr
  return rrstr
 
/*------------------------------------------------------------------*/
/* GenerateTOC: Generate a full or partial TOC                      */
/* Usage: call GenerateTOC type,start,end,mostsignif,leastsignif,   */
/*                         title,labelprefix                        */
/*          type - 0=Main TOC, 1=PTOC                               */
/*------------------------------------------------------------------*/
GenerateTOC: rtn='GENERATETOC'; trace value tracelist.rtn
  parse arg gttype, gtstr, gtend, gtmost, gtleast, gttitle, gtlabel
  if ?trcparse then call Here1 rtn,,
       gttype','gtstr','gtend','gtmost','gtleast','gttitle','gtlabel,sigl,!parse
  if \?wanttoc then signal End_GenerateTOC
  call WrtLine outputp_file,SetUpTag()||gttitle
  if gttype=1 & tocret=5
    then call WrtLine outputp_file,,
                 '<BR>'HtmlX(!a,'HREF="'HREFlink(toclfile,TOCname)'"')||,
                 deftext.!ptoclt'</A>'Br()
  prevheadlev=gtmost; k=0; gtindent=0
  do k1 = gtstr to gtend
    parse var saverec.!toc.k1 refidx headlev .
    if headlev > gtleast then iterate k1
    k = k + 1
    /*----- do spacing for this header -----*/
    select
      when headlev=0 & k=1 then prefix = tocspacer'<I><B>'
      when headlev=0 & k>1 then prefix = hrtag.7||tocspacer'<I><B>'
      when headlev=1       then prefix = tocspacer'<B>'
      otherwise                 prefix = ''
      end
    /*----- indent (P)TOC items if requested -----*/
    if ?tocindent
      then do
        templine = ''
        if headlev > prevheadlev
          then do headlev-prevheadlev
            templine = templine || list.!toc.1
            gtindent = gtindent + 1
            end
        if headlev < prevheadlev
          then do prevheadlev-headlev
            templine = templine || list.!toc.2
            gtindent = gtindent - 1
          end
        if templine \= '' then call WrtLine outputp_file, templine
        if headlev = gtmost
          then do; templine=prefix ;             suff2=Br();         end
          else do; templine=prefix||list.!toc.3; suff2=list.!toc.4 ; end
        end
      else do
        templine = prefix
        suff2 = Br()
        end
    /*----- set the header text -----*/
    if outputl_file = xref.refidx.!file
      then rrfid = ''
      else rrfid = FileCase(xref.refidx.!file)
    tocstr = HtmlX(!a,'NAME="'gtlabel'_'xref.refidx.!counter'"',
             'HREF="'rrfid'#'xref.refidx.!name'"')||xref.refidx.!IDtxt'</A>'
    templine = templine || SymbSub(tocstr)
    /*----- set the suffix for this header -----*/
    select
      when headlev = 0 then suffix = '</B></I>'
      when headlev = 1 then suffix = '</B>'
      otherwise             suffix = ''
      end
    call WrtLine outputp_file, templine || suffix || suff2
    prevheadlev = headlev
    end k1
  /*----- finish up the (P)TOC -----*/
  templine = ''
  if ?tocindent then do gtindent
    templine = templine || list.!toc.2
    end
  if gttype=1 & tocret=6
    then templine = templine'<BR>' ||,
                    HtmlX(!a,'HREF="'HREFlink(toclfile,TOCname)'"') ||,
                    deftext.!ptoclt'</A>'
  if gttitle \= '' then templine = templine||list.!toc.6
  call WrtLine outputp_file, templine||SetUpTag(,2)'<P>'
End_GenerateTOC:
  if ?trcparse then call Here2
  return
 
/*------------------------------------------------------------------*/
/* GenerateFigList: Generate a Figlist, Tlist or both               */
/* Usage: call GenerateFigList { !FIGREF | !TREF }                  */
/*------------------------------------------------------------------*/
GenerateFigList: rtn='GENERATEFIGLIST'; trace value tracelist.rtn
  parse upper arg gfparm
  if ?trcparse then call Here1 rtn,gfparm,sigl,!parse
  select
    when gfparm=!figref
      then if ?figlisthandled
        then signal End_GenerateFigList
        else ?figlisthandled = true
    when gfparm=!tref
      then if ?tlisthandled
        then signal End_GenerateFigList
        else ?tlisthandled = true
    otherwise nop
    end
  if \?ftsep then parse value true with ?figlisthandled 1 ?tlisthandled
  temp1 = SetUpTag()
  if temp1 \= '' then call WrtLine outputp_file, temp1
  call WrtLine outputp_file, list.!tfl.?fbc.1
 
  do k = 1 to saverec.!figlist.0
    parse var saverec.!figlist.k gftype refidx tftail xtext
    if ?ftsep & gfparm\=gftype then iterate k
    if outputl_file = xref.refidx.!file
      then rrfid = ''
      else rrfid = xref.refidx.!file
    if xtext = '' then xtext = xref.refidx.!IDtxt
    if ?ftlink
      then gfstring = 'NAME="'FTprefix||xref.refidx.!name'"'
      else gfstring = ''
    gfstring = HtmlX(!a,gfstring 'HREF="'rrfid'#'xref.refidx.!name'"') ||,
               xtext'</A>'
    if ?fbc then gfstring = tftail'.' gfstring
    templine = list.!tfl.?fbc.3 || SymbSub(gfstring) || list.!tfl.?fbc.4
    call WrtLine outputp_file, templine
    end k
  call WrtLine outputp_file, list.!tfl.?fbc.2
  temp2 = SetUpTag(,2)
  if temp2 \= '' then call WrtLine outputp_file, temp2
End_GenerateFigList:
  if ?trcparse then call Here2
  return
 
/*------------------------------------------------------------------*/
/* SaveIndex: Store an index entry into the INDEX. array            */
/* Usage: anchor = SaveIndex(tagname, tagopts, text, pass)          */
/*    anchor  - Anchor text to insert into the file                 */
/*    tagname - IH1, IH2, IH3, I1, I2 or I3                         */
/*    tagopts - ID=xxx, REFID=xxx, etc.                             */
/*    text    - Text for index entry                                */
/*    pass    - Pass number (entries saved in #1, inserted in #2)   */
/* Variables set:                                                   */
/* INDEXCNT             = total number of indexes encountered       */
/* INDEX.0              = number of unique index entries            */
/* INDEX.x              = upcasekey(FF)i1(00)i2(00)i3(00)           */
/* INDEX.!PG.x          = PG= value (seq. counter if omitted)       */
/* INDEX.i100           = cix1(FF)cix2(FF)...(FF)cix9(FF)           */
/* INDEX.i100i200i300   = (FF)href1(FF)href2(FF)...(FF)hrefx(FF)    */
/*                        Format of each href:                      */
/*                          (00)file#label                          */
/*                          (01):IHx text                           */
/* INDEX.!ID.IDname     = lvl {0|1} i1(00)i2(00)i3(00) 0/1=Header?  */
/* INDEX.!CNT.i100      = 1 (if any references "below" this :I1)    */
/* INDEX.!CNT.i100i200  = 1 (if any references "below" this :I2)    */
/* INDEX.i100i200i300.0 = Number of SEE= & SEEID= entries           */
/* INDEX.i100i200i300.x = "SEE"-type text                           */
/*------------------------------------------------------------------*/
SaveIndex: rtn='SAVEINDEX'; trace value tracelist.rtn
  parse arg sitag, sitagopts, sitext, sipass
  if ?trcparse
    then call Here1 rtn,sitag','sitagopts','sitext','sipass,sigl,!parse
  sianchor = ''
  sitext   = SymbSub(sitext)
  call EvalTag sitagopts
  sirefid  = GetAttr('REFID')
  sipg     = GetAttr('PG');
  sipguc   = translate(sipg)
  if sipguc = 'END' then signal End_SaveIndex
  indexcnt = indexcnt + 1
  if sitag = 'IREF'
    then do
      if index.!id.sirefid = '' then signal End_SaveIndex
      parse value index.!id.sirefid,
            with  sinum . idxthis.1 (x00) idxthis.2 (x00) idxthis.3 (x00)
      parse value 0 with ?sihdr siid siseeid sisee
      end
    else do
      sinum   = right(sitag,1)
      ?sihdr  = ( substr(sitag,2,1) == 'H' )
      siid    = GetAttr('ID')
      sisee   = GetAttr('SEE')
      siseeid = GetAttr('SEEID',!uc)
      select
        when sirefid \= ''
          then if index.!id.sirefid = ''
            then signal End_SaveIndex
            else parse value index.!id.sirefid,
                       with  . . idxthis.1 (x00) idxthis.2 (x00) idxthis.3 (x00)
        otherwise do
          idxthis.       = ''
          idxvalue.sinum = sitext
          end
        end
      idxthis.sinum = sitext
      do sii = 1 to sinum
        if idxthis.sii = '' then idxthis.sii = idxvalue.sii
        end
      end
  /*----- handle CIXn entries -----*/
  if sinum=1
    then do
      sicixstr = ''
      do sii = 1 to 9
        sij = GetAttr('CIX'sii)
        if sij = '' then leave
        sicixstr = sicixstr || sij || xFF
        end
      if sicixstr \= '' then do
        sij = idxthis.1 || x00
        index.sij = sicixstr
        end
      sicixstr = idxthis.1 || xFF || sicixstr
      end
    else do
      sij = idxthis.1 || x00
      sicixstr = idxthis.1 || xFF || index.sij
      end
  /*----- save the index(es) -----*/
  sianchor = HtmlX(!a,'NAME="IDX'indexcnt'"') || anchortext'</A>'
  if sipg\='' & wordpos(sipguc,'MAJOR START END')=0
    then index.!pg.indexcnt = sipg
    else index.!pg.indexcnt = indexcnt
  do scixnum = 1 by 1 while sicixstr \= ''
    parse var sicixstr idxthis.1 (xFF) sicixstr
    select
     when sinum=1 then idxvalue=idxthis.1||x00||           x00||           x00
     when sinum=2 then idxvalue=idxthis.1||x00||idxthis.2||x00||           x00
     otherwise         idxvalue=idxthis.1||x00||idxthis.2||x00||idxthis.3||x00
     end
    if scixnum = 1
      then if siid \= ''
        then index.!id.siid = sinum ?sihdr idxvalue
    if index.idxvalue = '' then do
      index.idxvalue=xFF; sii=index.0+1
      sortchar = left(idxvalue,1)
      if pos(sortchar,alphalc) > 0 then sortchar = translate(sortchar)
      sortchar = translate(sortchar,indexxlate) /* get sort character */
      index.sii=sortchar||translate(idxvalue)||xFF||idxvalue; index.0=sii
      end
    select
      when sinum=2 then idxcnt = idxthis.1||x00
      when sinum=3 then idxcnt = idxthis.1||x00||idxthis.2||x00
      otherwise         idxcnt = x00
      end
    if \?sihdr then index.!cnt.idxcnt=1
    /*----- if pass 1, save references -----*/
    if \?sihdr & sipass=1 then select
      when sipguc='MAJOR'
        then index.idxvalue = xFF||x00||currpartl'#'indexcnt||index.idxvalue
      when sipguc\='START' & sipguc\='' & \?indexref
        then index.idxvalue = index.idxvalue||x01||sipg||xFF
      otherwise index.idxvalue=index.idxvalue||x00||currpartl'#'indexcnt||xFF
      end
    /*----- handle SEE= & SEEID= parms -----*/
    if \datatype(index.idxvalue.0,'W') then index.idxvalue.0 = 0
    select
      when sipass=1 & sisee\='' then do
        sik = index.idxvalue.0 + 1
        index.idxvalue.sik = sisee
        index.idxvalue.0 = sik
        end
      when sipass=2 & siseeid\='' & scixnum=1 & index.!id.siseeid\='' then do
        parse value index.!id.siseeid,
              with  sitmnum . sitm.1 (x00) sitm.2 (x00) sitm.3 (x00)
        if \datatype(index.idxvalue.0,'W') then index.idxvalue.0 = 0
        sitmstr = ''
        do sij = 1 to sitmnum while sitm.sij\=''
          if sitmstr='' then sitmstr=sitm.sij;else sitmstr=sitmstr', 'sitm.sij
          end
        sik = index.idxvalue.0 + 1
        index.idxvalue.sik = sitmstr
        index.idxvalue.0 = sik
        end
      otherwise nop
      end
    end
  if ?sihdr then sianchor = ''
End_SaveIndex:
  if sianchor = '' then sianchor = omitrecord
  if ?trcparse then call Here2 sianchor
  return sianchor
 
/*------------------------------------------------------------------*/
/* GenerateIndex:  Write index records to current output file       */
/* Usage: call GenerateIndex                                        */
/*------------------------------------------------------------------*/
GenerateIndex: rtn='GENERATEINDEX'; trace value tracelist.rtn
  if ?trcparse then call Here1 rtn,arg(1),sigl,!parse
  call MsgOut !info 114, 'Generating the index ...'
 
  /*----- generate INDEX TOC if appropriate -----*/
  gitochdr. = ''
  gitemp1   = SetUpTag('INDEX',1)
  gitemp2   = SetUpTag('INDEX',2)
  if index.0 > indextoc then do
    call WrtLine outputp_file, gitemp1||list.!indextoc.1
    gitoc. = 0
    do gi = 1 to index.0
      gj = left(index.gi,1)
      gitoc.gj = 1
      end
    do gii = 0 to 255
      gj=d2c(gii)
      if \gitoc.gj then iterate gii
      select
        when gj = x00 then do
          gjtext  = deftext.!index0
          gjfront = list.!indextoc.3
          gjback  = list.!indextoc.4
          end
        when gj = x01 then do
          gjtext  = deftext.!index1
          gjfront = list.!indextoc.5
          gjback  = list.!indextoc.6
          end
        otherwise do
          gjtext  = gj
          gjfront = list.!indextoc.7
          gjback  = list.!indextoc.8
          end
        end
      gjx = c2x(gj)
      call WrtLine outputp_file, gjfront ||,
           HtmlX(!a,'NAME="IDX0_'gjx'" HREF="#IDX1_'gjx'"') ||,
           gjtext'</A>' || gjback
      gitochdr.gj = HtmlX(!a,'NAME="IDX1_'gjx'" HREF="#IDX0_'gjx'"')
      end gii
    call WrtLine outputp_file, list.!indextoc.2||gitemp2
    end
 
  /*----- generate the index itself -----*/
  if gitemp1\='' & index.0>0 then call WrtLine outputp_file, gitemp1
  lastlevel = 0
  lastchar  = x00
  do gi = 1 to index.0
    gilowstr=xFF; gilow=0
    /*----- retrieve stored indexes in alpha order -----*/
    do gj = 1 to index.0
      if index.gj \== xFF
        then if index.gj < gilowstr
          then do
            gilow    = gj;
            gilowstr = index.gj
            end
      end gj
    parse var index.gilow 1 thischar 2 (xFF) idx123; index.gilow=xFF
    parse var idx123 xdata.1 (x00) xdata.2 (x00) xdata.3 (x00)
    parse var index.idx123 (xFF) refstr
    /*----- index retrieved, generate item -----*/
    thischarsave = thischar
    select
      when thischar = x00 then thischar = deftext.!index0
      when thischar = x01 then thischar = deftext.!index1
      otherwise nop
      end
    if gitochdr.thischarsave = ''
      then thischarhdr = thischar
      else thischarhdr = gitochdr.thischarsave || thischar'</A>'
    thislevel = max(1,(xdata.1\='') + (xdata.2\='') + (xdata.3\=''))
    select
      when thislevel=1 then idxcnt = xdata.1||x00
      when thislevel=2 then idxcnt = xdata.1||x00||xdata.2||x00
      otherwise             idxcnt = xFF
      end
    ?newchar = ( thislevel=1 & thischar\==lastchar)
    thislevel = thislevel - ?newchar
    if thislevel < lastlevel
      then do gk = 1 to lastlevel-thislevel
        call WrtLine outputp_file, list.!index.2
        end
    if ?newchar then do
      call WrtLine outputp_file,list.!index.5||thischarhdr||list.!index.6
      lastlevel = 0
      end
    thislevel = thislevel + ?newchar
    if thislevel > lastlevel
      then do gk = 1 to thislevel-lastlevel
        call WrtLine outputp_file, list.!index.1
        end
    call WrtLine outputp_file, list.!index.3 || xdata.thislevel || ' '
    /*----- insert the references -----*/
    sistr2   = ''
    sistr2a  = ''
    ?silink2 = false
    do sik = 1 by 1 while refstr \= ''
      parse var refstr 1 reftype 2 refatom (xFF) refstr
      select
        when reftype = x00 then do
          parse var refatom sifile '#' sinum
          if sifile = outputl_file then sifile = ''
          sistr2 = sistr2 || sistr2a ||,
                   HtmlX(!a,'HREF="'FileCase(sifile)'#IDX'sinum'"') ||,
                   deftext.!indexentryl || index.!pg.sinum ||,
                   deftext.!indexentryr'</A>'
          ?silink2 = true
          end
        when reftype = x01 then sistr2 = sistr2 || sistr2a || refatom
        otherwise nop
        end
      sistr2a = ', '
      if ( sik // 5 ) = 0 then do
        if refstr = '' then sistr2a = ''
        call WrtLine outputp_file, sistr2||sistr2a
        sistr2  = ''
        sistr2a = ''
        end
      end
    if sistr2 \= '' then call WrtLine outputp_file, sistr2
    /*----- if "see"-type strings, do them now -----*/
    if \datatype(index.idx123.0,'W') then index.idx123.0 = 0
    if index.idx123.0 > 0 then do
      if ?silink2 | index.!cnt.idxcnt\=''
        then sistr2 = list.!index.1 || '<I>'deftext.!index2'</I> '
        else sistr2 = list.!index.1 || '<I>'deftext.!index3'</I> '
      sistr2a = ''
      do sik = 1 to index.idx123.0
        sistr2=sistr2||sistr2a||index.idx123.sik; sistr2a=', '
        end
      call Wrtline outputp_file, sistr2 || list.!index.2
      end
    lastlevel = thislevel
    lastchar  = thischar
    end
  do gi = 1 to lastlevel
    call WrtLine outputp_file, list.!index.2
    end
  if gitemp2\='' & index.0>0
    then call WrtLine outputp_file, gitemp2
  index.  = ''
  index.0 = 0
  if ?trcparse then call Here2
  return
 
 
/*------------------------------------------------------------------*/
/* NextTag:  Get location of next potential :tag                    */
/* Usage:    num = NextTag(string,start)    num=0 if no tag found   */
/*------------------------------------------------------------------*/
NextTag:
  parse upper arg ntstring, nti
  do forever
    ntj = pos(':',ntstring,nti)
    if ntj = 0 then leave
    if verify(substr(ntstring,ntj+1,1),tagcharsuc) = 0
      then return ntj
      else nti = ntj + 1
    end
  return 0
 
/*------------------------------------------------------------------*/
/* GETTAGPARTS: Scan the passed string and set the "TAGxxxxx" vars. */
/*              Add'l records read if required to complete the tag. */
/* Usage:       call GetTagParts string                             */
/* If string=":li id=abc.some text :li.last one :eol.", then:       */
/*    TAGname      = li                                             */
/*    TAGnameuc    = LI                                             */
/*    TAGitself    = :LI                                            */
/*    TAGstring    = :li id=abc.                                    */
/*    TAGstringall = :li id=abc.some text                           */
/*    TAGoptions   = id=abc                                         */
/*    TAGtext      = some text                                      */
/*    TAGresidual  =  :li.last one :eol.                            */
/*------------------------------------------------------------------*/
GetTagParts: rtn='GETTAGPARTS'; trace value tracelist.rtn
parse arg getstr
if ?trcparse then call Here1 rtn,getstr,sigl,!parse
parse value '',
      with  char TAGitself TAGoptions TAGname TAGnameuc TAGresidual,
            TAGstring TAGstringall TAGtext
 
parse value translate(getstr,'  ','.:') with 2 TAGname .
parse value length(TAGname)+2 with getstart 1 getoptstart
TAGnameuc = translate(TAGname)
TAGitself = left(getstr,1) || TAGnameuc
select
  when \?TAGvalid.TAGnameuc then do     /* ignore if unknown tag    */
    getperiodpos = getoptstart
    char = '.'
    end
  when ?litdata & TAGnameuc\='ELITDATA' /* within LITDATA mode?     */
    then do; getperiodpos=getoptstart; char='.'; end  /* yes,ignore */
  otherwise do getloop = 1 by 1         /* parse out this tag       */
    getperiodpos = 0
    getdelim     = ''
    ?getfndatt   = 0
    getin        = 0
    /*----- scan string byte-by-byte -----*/
    do i = getstart to length(getstr) while getperiodpos=0
      char = substr(getstr,i,1)
      select
        when char="'" | char='"' | char=b2hdelim  /* delimiter char?*/
         then select                              /* yes, check more*/
          when substr(getstr,i+1,1)=char then i=i+1 /*ignore double */
          when getdelim = ''   then getdelim = char /*leading delim */
          when getdelim = char then getdelim = ''   /*ending delim  */
          otherwise nop
          end
        when getdelim \= '' then nop   /* ignore if within a string */
        when char='.' | char=':' then getperiodpos = i
        when char = '=' then ?getfndatt = 1
        when char = ' '                /* if a blank, anything      */
         then if getin > 0 then do     /*   at all found yet?       */
          getnum  = verify(getstr,' ', 'N',i+1)
          getnum2 = verify(getstr,'= ','N',getnum+1)
          if getnum>0 & getnum2>0 & getnum2>getnum
            then if substr(getstr,getnum,1)='='
              then do; ?getfndatt=1; i=getnum2-1; iterate i; end
          if ( \?getfndatt & \?TAGvat.TAGnameuc ) |, /*if not, quit */
             (  ?getfndatt & \?TAGatt.TAGnameuc ) then getperiodpos = getin
          ?getfndatt=0; getin=0
          end
        otherwise if getin = 0 then getin = i
        end
      end i
    /*----- scan of record ended -----*/
    if getperiodpos = 0                /* did I find something?     */
      then do gtpi = 1 by 1            /*   no, get another record  */
        parse value Get_Buffer(0) with 1 ?geteof 2 ?physread 3 temprec
        if \?geteof                    /* was EOF reached?          */
          then if left(temprec,2) = '.*' /* no, got a comment?      */
            then iterate gtpi            /*     yes, read another   */
            else if left(temprec,1)\='.' /* no, can I use this rec? */
              then do                    /*     yes, append record  */
                getstart = length(getstr) + 1  /*    and continue   */
                getstr = getstr SymbSub(temprec)
                iterate getloop
                end
              else do                    /*     no, quit scan now   */
                call MsgOut ?prcnoper 455,noperiod,getstr,!recnumo
                getstr=getstr'.'; getperiodpos=length(getstr)
                call Put_Buffer temprec, !lifo
                end
          else if getperiodpos=0 then do /*EOF reached,append period*/
            call MsgOut ?prcnoper 455,noperiod,getstr,!recnumo
            getstr=getstr'.'; getperiodpos=length(getstr)
            end
        leave gtpi
        end gtpi
      /*----- tag logically ended, show error if not a period -----*/
      else if char \= '.' then do
        call MsgOut ?prcnoper 455,noperiod,getstr,!recnumo
        getstr = insert('.',getstr,getperiodpos-1)
        end
    leave getloop
    end getloop
  end
 
TAGstring  = left(getstr,getperiodpos)
TAGoptions = strip(substr(getstr,getoptstart,getperiodpos-getoptstart))
getstr = substr(getstr,getperiodpos+1)     /* get text after tag    */
if getstr='' & ?TAGimmed.TAGnameuc then do /* TOSL tag & no text?   */
  parse value Get_Buffer(0) with 3 getstr  /*   yes, get next line  */
  getstr1 = left(getstr,1)
  if getstr1=='.' | getstr1==':' then do
    call Put_Buffer getstr, !lifo
    getstr = ''
    end
  end
geti = NextTag(getstr,1)               /* another tag on this line? */
if geti = 0
  then do                              /*   no, remainder of line   */
    TAGtext     = getstr               /*       is "tag text"       */
    TAGresidual = ''
    end
  else do                              /*   yes, set text values    */
    TAGtext     = left(getstr,geti-1)
    TAGresidual = substr(getstr,geti)
    end
TAGstringall = TAGstring || TAGtext
if ?trcparse then do
  call Trc 'TAGname/uc   "'TAGname'"/"'TAGnameuc ||,
           '"    ATT='?TAGatt.TAGnameuc,
           'VAT='?TAGvat.TAGnameuc 'IT='?TAGimmed.TAGnameuc,
           'SE='?TAGse.TAGnameuc
  call Trc 'TAGitself    "'TAGitself'"'
  call Trc 'TAGstring    "'TAGstring'"'
  call Trc 'TAGstringall "'TAGstringall'"'
  call Trc 'TAGoptions   "'TAGoptions'"'
  call Trc 'TAGtext      "'TAGtext'"'
  call Trc 'TAGresidual  "'TAGresidual'"'
  call Here2
  end
return
 
/*------------------------------------------------------------------*/
/* EvalTag: Save the options/parameters for a tag                   */
/*          Values for ID= and REFID= always saved in upper-case.   */
/* Usage:   call EvalTag options,deftagname,<IDSONLY><FORCE>        */
/* Example: call EvalTag "id=xxx text='a1 a2'", 'tref'              */
/*------------------------------------------------------------------*/
EvalTag: rtn='EVALTAG'; trace value tracelist.rtn
  parse arg evtstr, evtdeftagname, p3
  if ?trcparse then call Here1 rtn,evtstr','evtdeftagname','p3,sigl,!parse
  parse value '0' with optrayid. evtid evtrefid optray. evtresult
  /*----- get ID= and REFID= attributes -----*/
  i = pos(' ID=',' 'translate(evtstr))
  if i = 0 then i = pos(' ID ',' 'translate(evtstr)' ')
  if i > 0 then do
    parse upper value substr(evtstr,i) with '=' evtid . '.'
    if evtid \= '' then evtstr = delstr(evtstr,i,length(evtid)+3)
    evtid = strip(translate(evtid,' ','''"'))
    end
  evtopt          = 'ID'
  optray.evtopt   = evtid
  optrayid.evtopt = 1
  i = pos(' REFID=',' 'translate(evtstr))
  if i = 0 then i = pos(' REFID ',' 'translate(evtstr)' ')
  if i > 0 then do
    parse upper value substr(evtstr,i) with '=' evtrefid . '.'
    if evtrefid \= '' then evtstr = delstr(evtstr,i,length(evtrefid)+6)
    evtrefid = strip(translate(evtrefid,' ','''"'))
    end
  evtopt          = 'REFID'
  optray.evtopt   = evtrefid
  optrayid.evtopt = 1
  if evtdeftagname \= ''
    then evtstr = evtstr nl,
                  tagdef.evtdeftagname.evtrefid nl,
                  tagdef.evtdeftagname.0
  if p3 = 'IDSONLY' then do            /* quit if getting IDs only  */
    evtresult = evtstr
    signal End_EvalTag
    end
  /*----- extract remaining attributes -----*/
  ?evtarrOK = true
  do eti = 1 by 1 while evtstr \= ''
    parse var evtstr evtopt evtstr
    evtstr = strip(evtstr)
    if evtopt = nl then do             /* allow ARRANGE= from most  */
      evtopt = 'ARRANGE'               /*   significant tag only    */
      if optray.evtopt \= '' then ?evtarrOK = false
      iterate eti
      end
    j = pos('=',evtopt)
    if j = 0
      then do
        if left(evtstr,1) = '=' then do
          evtstr = evtopt || evtstr
          iterate eti
          end
        parse var evtopt evtopt '.'      /* "keyword" attribute       */
        parse value DcfAbbrev(evtopt) with evtopt 1 evtdata
        adjust = 0
        end
      else do                            /* "opt=value" attribute     */
        evtstr = substr(evtopt,j+1) evtstr
        evtopt = DcfAbbrev(left(evtopt,j-1))
        if left(evtstr,1)==' ' then evtstr = strip(evtstr,'L')
        dlc = left(evtstr,1)
        if dlc\="'" & dlc\='"' & dlc\=b2hdelim
          then do                        /* non-delimited value       */
            evtdata = word(evtstr,1)
            parse var evtdata evtdata '.'
            adjust = 1
            end
          else do                        /* delimited string value    */
            evtdata = ''
            adjust  = 3
            do i = 2 to length(evtstr)
              char = substr(evtstr,i,1)
              if char\=dlc
                then evtdata = evtdata || char
                else if substr(evtstr,i+1,1)=dlc
                  then do; evtdata=evtdata||char; i=i+1; end
                  else leave i
              end i
            end
        evtstr = delstr(evtstr,1,length(evtdata)+adjust)
        end
    optrayid.evtopt=1
    select
      when optray.evtopt = '' then optray.evtopt = evtdata
      when p3 = 'FORCE'       then optray.evtopt = evtdata
      otherwise if evtopt='ARRANGE' & ?evtarrOK
        then optray.evtopt = optray.evtopt '/' evtdata
      end
    end eti
End_EvalTag:
  if ?trcparse then call Here2 evtresult
  return evtresult
 
 
/*------------------------------------------------------------------*/
/* GETATTR: Returns desired tag option after "EvalTag" has parsed it*/
/* Usage:   value = GetAttr(parm <,UC>)                             */
/*  (or)    parse value GetAttr(parm,<UC>,1) with def value         */
/*            parm  - Name of tag option (e.g. ID, TEXT)            */
/*            UC    - If specified, returned value is upper-cased   */
/*            1     - If specified, the "def" value is also returned*/
/*            def   - Was option specified at all? 0=No/1=Yes       */
/*            value - Option's value (null if option not specified) */
/*------------------------------------------------------------------*/
GetAttr: rtn='GETATTR'; /* trace value tracelist.rtn */
  parse upper arg ga1 ., ga2, ga3
  if ?trcparse then call Here1 rtn,ga1','ga2','ga3,sigl,!parse
  if ga3 = ''
    then garslt = optray.ga1;
    else garslt = optrayid.ga1 optray.ga1
  if ga2 = !uc then garslt = translate(garslt)
  if ?trcparse then call Here2 garslt
  return garslt
 
/*------------------------------------------------------------------*/
/* GETVALUE: Extracts a quoted or non-quoted value from a string    */
/*           and returns both the value and the remainder of the    */
/*           string.  If the value starts with a single or double   */
/*           quote, they are used as delimiter characters.          */
/*           Otherwise, the value up to the first blank or period   */
/*           is returned (If 'ALL' is specified, the remainder of   */
/*           the string is returned as the value).                  */
/* Usage:    parse value GetValue(operand<,ALL>) with str (nl) more */
/*------------------------------------------------------------------*/
GetValue: rtn='GETVALUE'; trace value tracelist.rtn
  parse arg gvstring, gvs2
  if ?trcparse then call Here1 rtn,gvstring','gvs2,sigl,!parse
  gvstring = strip(gvstring)
  ?allmode = ( gvs2 \= '' )
  dlc      = left(gvstring,1)
  gvrslt   = ''
  select
    when ?allmode
      then do i = 1 to length(gvstring)
        char = substr(gvstring,i,1)
        if char="'" | char='"' | char=b2hdelim
          then if substr(gvstring,i+1,1)=char then i = i + 1
        gvrslt = gvrslt || char
        end i
    when dlc\="'" & dlc\='"' & dlc\=b2hdelim
      then do i = 1 to length(gvstring)
        char = substr(gvstring,i,1)
        if char=' ' | char='.' then leave i
        gvrslt = gvrslt || char
        end i
    otherwise do i = 2 to length(gvstring)
      char = substr(gvstring,i,1)
      if char="'" | char='"'
        then if substr(gvstring,i+1,1)=char
          then i = i + 1
          else if char = dlc then leave i
      gvrslt = gvrslt || char
      end i
    end
  gvrslt = SymbSub(gvrslt) || nl || substr(gvstring,i+1)
  if ?trcparse then call Here2 gvrslt
  return gvrslt
 
/*------------------------------------------------------------------*/
/* If passed value an abbreviation, return real; else return orig   */
/* Usage:  id = DcfAbbrev(abbrev)                                   */
/*------------------------------------------------------------------*/
DcfAbbrev:
  parse upper arg daid .
  return word(Abbrev.daid daid,1)
 
/*------------------------------------------------------------------*/
/* Border: Return appropriate BORDER attribute                      */
/*------------------------------------------------------------------*/
Border:
  parse arg borp1 .
  if htmlrel >= 3
    then return bordertag.borp1
    else return 'BORDER'
 
 
/*------------------------------------------------------------------*/
/* Save/Restore the environment.                                    */
/* Usage:  call SaveRestore {SAVE|RESTORE} <environame>             */
/*------------------------------------------------------------------*/
SaveRestore: rtn='SAVERESTORE'; trace value tracelist.rtn
  parse upper arg srtype srname
  if ?trcparse then call Here1 rtn,srtype srname,sigl,!parse
  select
    when srtype = !save then do
      if srname='' then do; _sa=_sa+1; srname=_sa; end
      sare_names = strip(sare_names srname)
      sare.srname.1  = _uc
      sare.srname.2  = _us
      sare.srname.3  = _ce
      sare.srname.4  = _PREcount
      sare.srname.5  = _BRcount
      sare.srname.6  = dottis
      sare.srname.7  = dottit
      sare.srname.8  = dottrs
      sare.srname.9  = dottrt
      sare.srname.10 = ?!!gml !!gml_len !!gml
      sare.srname.11 = !!egml_len !!egml
      sare.srname.12 = !!cw_len !!cw
      sare.srname.13.0 = llcnt
      do sri = 1 to llcnt; sare.srname.13.sri=linewidth.sri; end
      end
    when srtype = !restore then do
      select
        when words(sare_names) = 0 then sridx = 0
        when srname \= ''          then sridx = wordpos(srname,sare_names)
        otherwise                       sridx = words(sare_names)
        end
      if sridx = 0                     /* anything to restore?      */
        then do                        /*  no, restore to orig value*/
          call Reset_PRE _PREcount, 0
          parse value '0',
                with  _uc 1 _us 1 _ce 1 _PREcount 1 BRcount
          parse value '' with dottis dottit dottrs dottrt
          linewidth.=78; llcnt=1
          !!gml =!!gml_def;  !!gml_len =length(!!gml);
          !!egml=!!egml_def; !!egml_len=length(!!egml); ?!!gml=false
          end
        else do                        /*  yes, restore saved values*/
          srname = word(sare_names,sridx)
          _uc       = sare.srname.1
          _us       = sare.srname.2
          _ce       = sare.srname.3
          call Reset_PRE _PREcount, sare.srname.4
          _PREcount = sare.srname.4
          _BRcount  = sare.srname.5
          dottis    = sare.srname.6
          dottit    = sare.srname.7
          dottrs    = sare.srname.8
          dottrt    = sare.srname.9
          parse value sare.srname.10 with ?!!gml !!gml_len !!gml
          parse value sare.srname.11 with !!egml_len !!egml
          parse value sare.srname.12 with !!cw_len !!cw
          llcnt = sare.srname.13.0
          do sri = 1 to llcnt; linewidth.sri=sare.srname.13.sri; end
          end
      end
    otherwise nop
    end
  if ?trcparse then call Here2
  return
 
Reset_PRE:
  parse arg rp_curr, rp_new
  select
    when rp_curr < rp_new then call Put_Buffer '<PRE>',  !lifo
    when rp_curr > rp_new then call Put_Buffer '</PRE>', !lifo
    otherwise nop
    end
  return
 
 
/*------------------------------------------------------------------*/
/* SYNTAX_FORMAT: Format a portion of a syntax diagram.             */
/* Usage:  result = syntax_format(syntax_item, max_width, ?OKToWrap)*/
/*           syntax_item - index in the syndat. array of the        */
/*                         item to be formatted.                    */
/*           max_width   - maximum width of the result.             */
/*           ?OKToWrap   - True if OK to wrap the diagram baseline. */
/* Returns: width baseline height data                              */
/*------------------------------------------------------------------*/
SYNTAX_FORMAT:
  procedure expose alphaucnum deftext. lentext. syndat. synctl. tracelist. xff
  rtn='SYNTAX_FORMAT'; trace value tracelist.rtn
  parse upper arg item ., max_width ., ?OKToWrap .
  select
    when syndat.item._order = 'SEQ'
      then retval = Syntax_Format_Sequential(Item, ,
             copies(deftext._dash,2), 2*lentext._dash, max_width, ?OKToWrap)
    when syndat.item._order = 'CHOICE'
      then retval = Syntax_Format_Choice(Item, max_width, ?OKToWrap)
    when syndat.item._order = 'COMPOSITE'
      then retval = Syntax_Format_Sequential(Item,'',0,max_width, ?OKToWrap)
    otherwise retval = Syntax_Format_Item(Item)
    end
  return retval
 
/*------------------------------------------------------------------*/
/* SYNTAX_FORMAT_SEQUENTIAL: Format a sequential or composite       */
/*                           group in a syntax diagram.             */
/* Usage:  result = syntax_format_sequential(syntax_item, separator,*/
/*                           sep_width, max_width, ?OKToWrap)       */
/*           syntax_item - index in the syndat. array of the        */
/*                         group to be formatted.                   */
/*           separator   - string to separate items in the group.   */
/*           sep_width   - length of sep string                     */
/*           max_width   - maximum width of the result.             */
/*           ?OKToWrap   - True if OK to wrap the diagram baseline. */
/* Returns: width baseline height data                              */
/*------------------------------------------------------------------*/
SYNTAX_FORMAT_SEQUENTIAL:
  procedure expose alphaucnum deftext. lentext. syndat. synctl. tracelist. xff
  rtn='SYNTAX_FORMAT_SEQUENTIAL'; trace value tracelist.rtn
  parse upper arg group ., separator ., separator_width ., ,
                  max_width ., ?OKToWrap
  if separator = '' then ?OKToWrap = 0     /* Can't wrap COMPOSITEs */
  group.=''; group._width=0; group._height=0; group._baseline=0
  spacesep = copies(' ', separator_width)
  do w = 1 by 1 while w <= words(syndat.group._contents)
    item = word(syndat.group._contents, w) /* do next item in group */
    drop item.; item. = ''
    max_item_width = max_width - (group._width + separator_width)
    parse value SYNTAX_FORMAT(item, max_item_width, 0) ,
          with  item._width item._baseline item._height item._data
    item._placement = syndat.item._placement
    /* If we need to wrap and can do so, now's the time to do it.   */
    /* We won't try to wrap if this is a one-element top-level, as  */
    /* that way lie infinite loops.                                 */
    OneElementTopLevel = ,
      (syndat.group._inside=1) & (words(syndat.group._contents)=3)
    StartOfWrappedSequence = ,
      (w=2) & (word(syndat.group._contents,1)='WRAP2')
 
    if \OneElementTopLevel & \StartOfWrappedSequence & ?OKToWrap & ,
       (item._width >= max_item_width) then do
      /*--- Build a new group to follow this one. ---*/
      new=syndat.0 + 1; syndat.0=new
      syndat.new._inside = syndat.group._inside
      syndat.new._placement = syndat.group._placement
      syndat.new._order = syndat.group._order
      /*--- Move the remainder of this group to the new group ---*/
      syndat.new._contents   = 'WRAP2' subword(syndat.group._contents,w)
      syndat.group._contents = subword(syndat.group._contents, 1, w-1)
      /*--- Insert the new group after this one. ---*/
      parent = syndat.group._inside
      i = wordpos(group, syndat.parent._contents)
      syndat.parent._contents = ,
        subword(syndat.parent._contents,1,i) new ,
        subword(syndat.parent._contents,i+1)
      /*--- Format the wrap terminator ---*/
      item = 'WRAP1'
      parse value SYNTAX_FORMAT(item, max_width - group._width, 0) ,
            with  item._width item._baseline item._height item._data
      item._placement = syndat.item._placement
      end
    /*--- Build item._line. array from item's data ---*/
    select
      /*--- Optional non-CHOICE-group items go below baseline ---*/
      when item._placement='BELOW' & syndat.item._order\='CHOICE' then do
        item._line.1 = deftext._teedown || separator || ,
                       copies(deftext._dash, item._width) || ,
                       separator || deftext._teedown
        do i = 2 to item._baseline
          parse var item._data line (xFF) item._data
          item._line.i = deftext._middleleft || spacesep || ,
                         line || spacesep || deftext._middleright
          end
        i=item._baseline+1; parse var item._data line (xFF) item._data
        item._line.i = deftext._lowerleft || separator || ,
                       line || separator || deftext._lowerright
        do i = item._baseline+2 to item._height+1
          parse var item._data line (xFF) item._data
          item._line.i = ' 'spacesep || line || spacesep' '
          end
        item._height = item._height + 1
        item._width = item._width + (2 * (1+separator_width))
        item._baseline = 1
        end
      /*--- Default items go above baseline ---*/
      when item._placement = 'ABOVE' then do
        do i = 1 to item._baseline-1
          parse var item._data line (xFF) item._data
          item._line.i = ' 'spacesep || line || spacesep' '
          end
        i=item._baseline; parse var item._data line (xFF) item._data
        item._line.i = deftext._upperleft || separator || ,
                       line || separator || deftext._upperright
        do i = item._baseline+1 to item._height
          parse var item._data line (xFF) item._data
          item._line.i = deftext._middleleft || spacesep || ,
                         line || spacesep || deftext._middleright
          end
        i = item._height + 1
        item._line.i = deftext._teeup || separator || ,
                       copies(deftext._dash, item._width) || ,
                       separator || deftext._teeup
        item._height=item._height+1; item._width=item._width+2
        item._baseline = item._height
        end
      /*--- Req'd items & non-default CHOICE grps go on baseline ---*/
      otherwise do
        do i = 1 to item._height
          parse var item._data item._line.i (xFF) item._data
          end
        end
      end
    /*--- Normalize the baselines of the item and our data ---*/
    newbaseline = max(group._baseline, item._baseline)
    group._baselinedelta = newbaseline - group._baseline
    item._baselinedelta  = newbaseline - item._baseline
    /*--- Add the item's data to ours ---*/
    newheight = ,
      max(group._height+group._baselinedelta,item._height+item._baselinedelta)
    do i = newheight to 1 by -1
      j = i - group._baselinedelta
      select
        when j < 1 then left = copies(' ', group._width)
        when group._line.j == '' then left = copies(' ', group._width)
        otherwise left = group._line.j
        end
      k = i - item._baselinedelta
      select
        when k < 1 then right = copies(' ', item._width)
        when item._line.k == '' then right = copies(' ', item._width)
        otherwise right = item._line.k
        end
      seplen = separator_width
      select
        when group._width = 0 then do; sep=''; seplen=0; end
        when i = newbaseline then sep = separator
        otherwise sep = copies(' ', separator_width)
        end
      group._line.i = left || sep || right
      end
    group._height = newheight
    group._baseline = newbaseline
    group._width = group._width + seplen + item._width
    end
  /*--- Construct output string --- */
  data = ''
  if syndat.group._repsep \= '' then do
    /* Format the group's REPSEP and add some indentation */
    parse value SYNTAX_FORMAT(syndat.group._repsep, 0),
          with  item._width item._baseline item._height item._data
    save_width = group._width
    group._width = group._width +,
                   lentext._repsepleft + lentext._repsepright
    leading  = copies(' ', lentext._repsepleft)
    trailing = copies(' ', lentext._repsepright)
    do i = 1 to item._baseline-1
      parse var item._data line (xFF) item._data
      line = leading || line || trailing
      data = data || line || copies(' ', (group._width - item._width)) || xFF
      end
    parse var item._data line (xFF) item._data
    line = deftext._repsepleft || line || ,
           copies(deftext._dash, (save_width - item._width)) || ,
           deftext._repsepright
    data = data || line || xFF
    do i = item._baseline+2 to item._height
      parse var item._data line (xFF) item._data
      line = leading || line || trailing
      data = data || line || copies(' ', (group._width - item._width)) || xFF
      end
    group._baselineoffset=1; group._heightoffset=1
    end
  else do
    leading=''; trailing=''
    group._baselineoffset=0; group._heightoffset=0
    end
  /*--- Put empty line above the group if supposed to ---*/
  if synctl._addverticalspacing & group._line.1 \= '' then do
    data = copies(' ', group._width) || xFF || data
    group._baselineoffset = group._baselineoffset + 1
    group._heightoffset   = group._heightoffset   + 1
    end
  do i = 1 to group._baseline-1
    data = data || leading || group._line.i || trailing || xFF
    end
  i = group._baseline
  if syndat.group._repsep = ''
    then data=data || copies(deftext._dash, length(leading)) || ,
           group._line.i || copies(deftext._dash, length(trailing)) || xFF
    else data=data || deftext._repsepjoinl ||,
           copies(deftext._dash,max(0,length(leading)-lentext._repsepjoinl))||,
           group._line.i ||,
           copies(deftext._dash,max(0,length(trailing)-lentext._repsepjoinr))||,
           deftext._repsepjoinr || xFF
  do i = group._baseline+1 to group._height
    data = data || leading || group._line.i || trailing || xFF
    end
  return group._width group._baseline+group._baselineoffset ,
         group._height+group._heightoffset data
 
 
/*------------------------------------------------------------------*/
/* SYNTAX_FORMAT_CHOICE: Format a choice group in a syntax diagram. */
/* Usage:  result = syntax_format_choice(syntax_item, max_width,    */
/*                                       ?OKToWrap)                 */
/*           syntax_item - index in the syndat. array of the        */
/*                         group to be formatted.                   */
/*           max_width   - maximum width of the result.             */
/*           ?OKToWrap   - True if OK to wrap the diagram baseline. */
/* Returns: width baseline height data                              */
/*------------------------------------------------------------------*/
SYNTAX_FORMAT_CHOICE:
  procedure expose alphaucnum deftext. lentext. syndat. synctl. tracelist. xff
  rtn='SYNTAX_FORMAT_CHOICE'; trace value tracelist.rtn
  parse upper arg group ., max_width ., ?OKToWrap
  group.=''; group._leftwidth=0; group._datawidth=0
  group._rightwidth=0; group._width=0
  group._height=0; group._baseline=0; nextsection=1
  do w = 1 by 1 while w <= words(syndat.group._contents)
    item = word(syndat.group._contents, w) /* do next item in group */
    drop item.; item. = ''
    parse value SYNTAX_FORMAT(item, max_width - group._width, 0),
          with  item._width item._baseline item._height item._data
    /*--- Put empty line above each item if supposed to ---*/
    if w>1 synctl._addverticalspacing then do
      parse var item._data x (xFF)
      if x \= '' then do
        item._data = copies(' ',item._width) || xFF || item._data
        item._height=item._height+1; item._baseline=item._baseline+1
        end
      end
    /*--- Save item for rendering later--- */
    if syndat.item._placement = 'ABOVE'
      then do
        section='_DEFAULT'; group.section._placement='_ABOVE'
        group._sections = '_DEFAULT' group._sections
        end
      else do
        section=nextsection; nextsection = nextsection+1
        group._sections = group._sections section
        group.section._placement = '_BELOW'
        end
    do i = 1 to item._height
      parse var item._data group.section.i (xFF) item._data
      end
    x = group.section._placement
    leftlen  = max(synctl._choice.x._topleft._len + 1, ,
                   synctl._choice.x._baseleft._len, ,
                   synctl._choice.x._bottomleft._len + 1)
    rightlen = max(synctl._choice.x._topright._len + 1, ,
                   synctl._choice.x._baseright._len, ,
                   synctl._choice.x._bottomright._len + 1)
    group.section._height = item._height
    group.section._datawidth = item._width
    group.section._baseline = item._baseline
    group._leftwidth = max(group._leftwidth, leftlen)
    group._datawidth = max(group._datawidth, group.section._datawidth)
    group._rightwidth = max(group._rightwidth, rightlen)
    group._width = group._leftwidth + group._datawidth + group._rightwidth
    end
  select
    /*--- An optional group, the baseline is extended through ---*/
    when syndat.group._placement='BELOW' | group._sections='_DEFAULT' then do
      section = '_BASELINE'
      if word(group._sections, 1) = '_DEFAULT'
        then do
          group._sections = '_DEFAULT' section subword(group._sections,2)
          group.section._placement = '_ONDEF'
          end
        else do
          group._sections = section group._sections
          group.section._placement = '_ONNODEF'
          end
      if synctl._addverticalspacing
        then do; i=2; group.section.1=copies(' ',group._datawidth); end
        else i = 1
      group.section.i = copies(deftext._dash, group._datawidth)
      group.section._height=i; group.section._baseline=i
      group.section._datawidth = lentext._dash * group._datawidth
      end
    /*--- A req'd group with a default, so 1st non-dflt---*/
    /*--- is baseline, and formatted above             ---*/
    when word(group._sections, 1) = '_DEFAULT' then do
      section = word(group._sections, 2)
      group.section._placement = '_ONDEF'
      end
    /*--- A required group without a default, so 1st is baseline ---*/
    otherwise do
      section = word(group._sections, 1)
      group.section._placement = '_ONNODEF'
      end
    end
  /*----- set values if :REPSEP. is in effect -----*/
  if syndat.group._repsep \= '' then do
    section='_REPSEP'; group._sections='_REPSEP' group._sections
    parse value SYNTAX_FORMAT(syndat.group._repsep, 0),
          with  group.section._datawidth group.section._baseline ,
                group.section._height data
    do i = 1 to group.section._height
      parse var data group.section.i (xFF) data
      end
    group.section._placement = '_REPSEP'
    leftlen  = max(synctl._choice._REPSEP._topleft._len + 1, ,
                   synctl._choice._REPSEP._baseleft._len, ,
                   synctl._choice._REPSEP._bottomleft._len + 1)
    rightlen = max(synctl._choice._REPSEP._topright._len + 1, ,
                   synctl._choice._REPSEP._baseright._len, ,
                   synctl._choice._REPSEP._bottomright._len + 1)
    group._leftwidth = max(group._leftwidth, leftlen)
    group._datawidth = max(group._datawidth, group.section._datawidth)
    group._rightwidth = max(group._rightwidth, rightlen)
    repvl=deftext._middleleft;  repvr=deftext._middleright
    reptl=deftext._repsepjoinl; reptr=deftext._repsepjoinr
    end
  else do
    repvl=' '; repvr=' '; reptl=deftext._dash; reptr=deftext._dash
    end
  /*--- Format the lowest section differently from the rest ---*/
  section = word(group._sections, words(group._sections))
  select
    when group.section._placement = '_BELOW'
      then group.section._placement = '_LOWEST'
    when group.section._placement = '_ONDEF'
      then group.section._placement = '_ONDEFLOW'
    when group.section._placement = '_ONNODEF'
      then group.section._placement = '_ONNODEFLOW'
    otherwise nop
    end
  /*--- Construct output string ---*/
  string=''; list=group._sections
  do while list \= ''
    parse var list section list; placement=group.section._placement
    if syndat.group._repsep\='' & wordpos(placement,'_ABOVE _ONDEF')>0
      then do; tmpl=repvl; tmpr=repvr; end
      else do; tmpl=' ';   tmpr=' ';   end
    do i = 1 to group.section._baseline-1
      string = string || ,
        LeftSide(group._leftwidth, synctl._choice.placement._topleft,,
                 synctl._choice.placement._topleft._len,tmpl,' ') ||,
        group.section.i || ,
        copies(synctl._choice.placement._toppad, ,
               group._datawidth - group.section._datawidth) ||,
        RightSide(group._rightwidth, synctl._choice.placement._topright,,
                  synctl._choice.placement._topright._len,tmpr,' ') ||,
        xFF
      end
 
    i = group.section._baseline
    select
      when wordpos(placement, '_ONDEF _ONNODEF _ONDEFLOW _ONNODEFLOW') > 0
        then do
          group._baseline = group._height + group.section._baseline
          pad = deftext._dash
          if syndat.group._repsep = ''
            then do; tmpl=pad;   tmpr=pad;   end
            else do; tmpl=reptl; tmpr=reptr; end
          end
      when placement = '_ABOVE' then do
        pad = ' '
        if syndat.group._repsep = ''
          then do; tmpl=pad;   tmpr=pad;   end
          else do; tmpl=repvl; tmpr=repvr; end
        end
      otherwise pad = ' '
      end
    sglen1=group._leftwidth; sglen2=synctl._choice.placement._baseleft._len
    if sglen1 >= sglen2
      then string = string ||,
           PadCopy(0,sglen1-sglen2,tmpl) ||,
           synctl._choice.placement._baseleft
      else string = string || PadCopy(0,sglen1-sglen2,tmpl)
    string = string || ,
             group.section.i || ,
             copies(synctl._choice.placement._basepad, ,
                    group._datawidth - group.section._datawidth)
    sglen1=group._rightwidth; sglen2=synctl._choice.placement._baseright._len
    if sglen1 >= sglen2
      then string = string ||,
           synctl._choice.placement._baseright ||,
                   PadCopy(1,sglen1-sglen2,tmpr) || xFF
      else string = string || PadCopy(1,sglen1-sglen2,tmpr) || xFF
    do i = group.section._baseline+1 to group.section._height
      string = string || ,
        LeftSide(group._leftwidth, synctl._choice.placement._bottomleft,,
                 synctl._choice.placement._bottomleft._len,' ',' ') ||,
        group.section.i || ,
        copies(synctl._choice.placement._bottompad, ,
               group._datawidth - group.section._datawidth) ||,
        RightSide(group._rightwidth, synctl._choice.placement._bottomright,,
                  synctl._choice.placement._bottomright._len,' ',' ') ||,
        xFF
      end
    group._height = group._height + group.section._height
    end
  return (group._leftwidth + group._datawidth + group._rightwidth) ,
         group._baseline group._height string
 
/* LeftSide: */
LeftSide: parse arg lswidth, lschar, lscharlen, lsrep, lspad
  select
    when lswidth < lscharlen   then lsrslt = copies(lspad,lswidth)
    when lswidth = lscharlen   then lsrslt = lschar
    when lswidth = lscharlen+1 then lsrslt = lschar || copies(lspad,lswidth-1)
    otherwise lsrslt = lsrep||copies(lspad,lswidth-lscharlen-2) ||,
                       lschar || lspad
    end
  return lsrslt
 
/* RightSide: */
RightSide: parse arg rswidth, rschar, rscharlen, rsrep, rspad
  select
    when rswidth < rscharlen   then rsrslt = copies(rspad,rswidth)
    when rswidth = rscharlen   then rsrslt = rschar
    when rswidth = rscharlen+1 then rsrslt = copies(lspad,lswidth-1) || rschar
    otherwise rsrslt = rspad || rschar ||,
                       copies(rspad,rswidth-rscharlen-2)||rsrep
    end
  return rsrslt
 
/* PadCopy: */
PadCopy: parse arg pctype, pclen, pcrep
select
  when pclen <= 0 then pcrslt = ''
  when pclen  = 1 then pcrslt = pcrep
  otherwise if pctype='0'              /* 0=left side, 1=right side */
    then pcrslt = pcrep || copies(pad,pclen-1)
    else pcrslt = copies(pad,pclen-1) || pcrep
  end
return pcrslt
 
/*------------------------------------------------------------------*/
/* SYNTAX_FORMAT_ITEM: Format an item in a syntax diagram.          */
/* Usage:  result = syntax_format_item(syntax_item)                 */
/*           syntax_item - index in the syndat. array of the        */
/*                         item to be formatted.                    */
/* Returns: width baseline height data                              */
/*------------------------------------------------------------------*/
SYNTAX_FORMAT_ITEM:
  procedure expose alphaucnum deftext. lentext. syndat. synctl. tracelist. xff
  rtn='SYNTAX_FORMAT_ITEM'; trace value tracelist.rtn
  parse upper arg item .
  line = syndat.item._text
  ?trcparse = 0                       /* Keeps InternalWidth() happy  */
  width = InternalWidth(line, 0)
  return width 1 1 line
 
 
/*------------------------------------------------------------------*/
/* Handle any options specified in the source file until the first  */
/* non-comment record is encountered.                               */
/*------------------------------------------------------------------*/
Initial_Source_Options:
rtn='INITIAL_SOURCE_OPTIONS'; trace value tracelist.rtn
isfile=input_file; call OpenFile isfile,!read; ?iseof=false
do prereadnum = 0 by 1 while \?iseof
  parse value RdLine(isfile,,'NO') with 1 ?iseof 2 isline
  source_id_orig.infilecnt = source_id.infilecnt
  if left(isline,2) \= '.*' then leave prereadnum
  if substr(isline,3,1) == ' ' then iterate prereadnum
  ?b2hfound = ( translate(word(isline,1)) = '.*B2H' )
  if ?b2hreq & \?b2hfound then iterate prereadnum
  if \?b2hfound                        /* what format is record?    */
    then parse var isline 3 word1 remainder   /* .*xxxx             */
    else do                                   /* .*B2H ...          */
      remainder = subword(isline,2)
      if left(remainder,1) = '(' then do      /* system-specific?   */
        parse var remainder '(' b2env ')' remainder  /* yes         */
        if \UseOnPlatform(b2env) then iterate prereadnum
        end
      parse var remainder word1 remainder
      end
  if translate(word1) = 'OPTION' then call SetOpts remainder,1,0,1
  end prereadnum
call Closefile isfile
incount.isfile = 0
return
 
/*------------------------------------------------------------------*/
/* Set processing options: call SetOpts line,x,y,z                  */
/*  x - 1=OK to process USERPROF and USERSYM options                */
/*  y - 0=Processing command line and profile options               */
/*      1=Processing contents of a document                         */
/*  z - 1=OK to process "cumulative"-type options (e.g. FOOTER=)    */
/*------------------------------------------------------------------*/
SetOpts: rtn='SETOPTS'; trace value tracelist.rtn
soc = soc + 1                          /* uniqueness counter        */
parse arg optsline.soc,?OKtoProcess.soc,?WithinFile.soc,?OKcum.soc
do while optsline.soc \= ''
  atom = word(optsline.soc,1)          /* get next parameter        */
  if left(atom,2)=='--' then leave     /* quit if rest is comments  */
  ?sodelim.soc = 0                     /* assume not delimited      */
  ?soprosym.soc = 0                    /* assume no pro/sym char    */
  soword1.soc  = ''                    /* assume no 1st word        */
  if pos('=',atom) > 0                 /* what kind of parameter?   */
    then do                            /*   keyword parameter       */
      parse var optsline.soc parm . '=' optsline.soc
      if right(parm,1) = '*' then do
        ?soprosym.soc=1; parm=left(parm,length(parm)-1)
        end
      char1=left(optsline.soc,1); data2=''
      ?sodelim.soc = ( char1 == "'" )  /* 1=value enclosed in quote */
      if char1="'" | char1='"' | char1=b2hdelim
        then parse var optsline.soc 2 data (char1) optsline.soc
        else parse var optsline.soc data optsline.soc
      soword1.soc = word(data,1)
      if left(optsline.soc,1)=',' then do /* 2nd external option?   */
        optsline.soc = substr(optsline.soc,2)
        char1=left(optsline.soc,1)
        if char1="'" | char1='"' | char1=b2hdelim
          then parse var optsline.soc 2 data2 (char1) optsline.soc
          else parse var optsline.soc data2 optsline.soc
        end
      end
    else do                            /*   single word parameter   */
      parse var optsline.soc parm optsline.soc
      data=''; data2=''
      end
  if ?WithinFile.soc then parm = SymbSub(parm)
  parse upper var parm parm  . 1 parm1 '.' pid .
  datauc = translate(data)
  if ?WithinFile.soc then datasym=SymbSub(data); else datasym=data
 
  /*----- handle the parameter (and value) if recognized -----*/
  select
    when parm='ABSTRACT' then abstract=datasym /*-- ABSTRACT   -----*/
    when parm='ALARM' then select           /*----- ALARM      -----*/
      when datauc = !yes then _alarmcnt = 99999999
      when datauc = !no  then _alarmcnt = -1
      otherwise if datatype(data,'W')
        then _alarmcnt=data; else call BadParm parm,datauc,noyes 'number'
      end
    when parm='ANCHORTEXT' then anchortext=data /*- ANCHORTEXT -----*/
    when parm='ANNOT'                       /*----- ANNOT      -----*/
      then ?annot = ValOpt(datauc,,noyes,noyesval)
    when parm='APPHD1'  then apphd1 =datasym /*---- APPHD1     -----*/
    when parm='APPHD1X' then apphd1x=datasym /*---- APPHD1X    -----*/
    when parm='ARTLINKIMG'                  /*----- ARTLINKIMG -----*/
      then if data \= '' then artlinkimg = data
    when parm='ARTSHOW' then do             /*----- ARTSHOW    -----*/
      temp1=!none !link !view; artshow=ValOpt(datauc,,temp1,temp1)
      end
    when parm='ARTTYPE'                     /*----- ARTTYPE    -----*/
      then if data \= '' then arttype = data
    when parm='AUTOSPLIT' | parm='AUTOPART' /*----- AUTOSPLIT  -----*/
      then if \?pipe then do while datauc\=''
        parse var datauc atom datauc
        select
          when atom=!no then parse value '-1 0 0 0 0 0',
                 with autosplit ?autosplit. ?autoimbed ?autosetup,
                      ?autolen. ?autolensep
          when atom=!yes then parse value 0 with autosplit 1 ?autosplit.
          when left(atom,7)='BYPASS='
            then autobypass = MaxNumDigit(substr(atom,8))
          when atom='IMBED'
            then parse value true max(0,autosplit) with ?autoimbed autosplit
          when atom='NOIMBED'  then ?autoimbed = false
          when atom='SETUP'
            then parse value true max(0,autosplit) with ?autosetup autosplit
          when atom='NOSETUP' then ?autosetup = false
          when left(atom,4)='LEN=' then do; atom=substr(atom,5)
            select
              when atom='SEP' then ?autolensep = 1
              when datatype(atom,'W') then ?autolen.atom = 1
              otherwise do i1=0 to MaxNumDigit(atom); ?autolen.i1=1; end
              end
            end
          when datatype(atom,'W')
            then do; ?autosplit.=0; autosplit=1; ?autosplit.atom=1; end
          when left(atom,1)='*' & datatype(substr(atom,2),'W') then do
            ?autosplit.=0; autosplit=1
            do i1 = 0 to MaxNumDigit(atom); ?autosplit.i1=1; end
            end
          otherwise call MsgOut !term 120,,
                         "'"atom"' is an unknown AUTOSPLIT option!"
          end
        end
    when parm='B2HREQ'                      /*----- B2HREQ     -----*/
      then ?b2hreq = ValOpt(datauc,,noyes,noyesval)
    when parm='BODYHD0'  then bodyhd0 =datasym /*-- BODYHD0    -----*/
    when parm='BODYHD0X' then bodyhd0x=datasym /*-- BODYHD0X   -----*/
    when parm='BODYHD1'  then bodyhd1 =datasym /*-- BODYHD1    -----*/
    when parm='BODYHD1X' then bodyhd1x=datasym /*-- BODYHD1X   -----*/
    when parm='BODYTAG'  then bodytag=data     /*-- BODYTAG    -----*/
    when parm='BORDERTAG' then bordertag.=data /*-- BORDERTAG  -----*/
    when parm1='BORDERTAG' & pid\='' then do   /*-- BORDERTAG.x ----*/
      i2 = "'x' must be a number from 1 to 10"
      select
        when \datatype(pid,'W') then call BadParm 'BORDERTAG.x',pid,i2
        when pid<1 | pid>10     then call BadParm 'BORDERTAG.x',pid,i2
        otherwise bordertag.pid = data
        end
      end
    when parm='CENTERTAG'                   /*----- CENTERTAG  -----*/
      then ?centertag = ValOpt(datauc,,noyes,noyesval)
    when parm='CHARSET'  then charset=data  /*----- CHARSET    -----*/
    when parm='COMMENT'  then if ?OKcum.soc /*----- COMMENT    -----*/
      then select
        when data  ='' then nop
        when datauc='CLEAR' then saverec.!htmlcmt.0=0
        otherwise call SaveRec !htmlcmt,datasym
        end
    when parm='COMMENTHEAD'                 /*----- COMMENTHEAD ----*/
      then commenthead = space(data)
    when parm='CONTACT' then contact=datasym/*----- CONTACT    -----*/
    when parm='DEBUG' then do               /*----- DEBUG      -----*/
      ?debug = ValOpt(datauc,,noyes,noyesval)
      parse value ?debug with 1 ?showprof 1 ?showsym
      end
    when parm1='DEFTEXT' & pid\=''          /*----- DEFTEXT.x  -----*/
      then if left(pid,1) = '_'
        then do
          deftext.pid=data; lentext.pid=data2
          if lentext.pid = '' then lentext.pid = length(deftext.pid)
          end
        else deftext.pid=data
    when parm='DESTSYS'                     /*----- DESTSYS    -----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed
        else do                                          /* !OPSYS! */
          temp1 = platform.AIX platform.CMS platform.OS2 platform.HPFS,
                  platform.WIN95 platform.WINNT platform.MVS,
                  platform.LINUX platform.UNIX 'OS/2 VM TSO'
          temp2 = AIX CMS OS2 HPFS WIN95 WINNT MVS LINUX UNIX OS2 CMS MVS
          destsys = ValOpt(datauc,,temp1,temp2)
          end
    when parm='DIALOG' then do              /*----- DIALOG     -----*/
        dialog=datauc; j1='LABEL FONT COLOR'
        do while datauc \= ''
          parse var datauc atom datauc
          if wordpos(atom,j1) = 0
            then call BadParm parm,atom,"One or more of '"j1"'"
          end
        end
    when parm1='DIALOGTAG' & pid\=''        /*----- DIALOGTAG.x ----*/
      then if pid\='0' & pid\='1'
        then call BadParm 'DIALOGTAG.x',pid,"'x' must be either '0' or '1'"
        else do
          if pid=0 then pid=!sys; else pid=!user
          parse value data,
                with  list.pid.0.1 ',' list.pid.0.2 ',',
                      list.pid.1.1 ',' list.pid.1.2 ',',
                      list.pid.2.1 ',' list.pid.2.2
          end
    when parm='DLFMT'                       /*----- DLFMT      -----*/
      then ?dlfmt = ValOpt(datauc,,'DL TABLE',false true)
    when parm1='DLTAG' & pid\=''            /*----- DLTAG.x    -----*/
      then parse var data list.!dl.pid.1 ',' list.!dl.pid.2 ',',
       list.!dl.pid.3 ',' list.!dl.pid.4 ',' list.!dl.pid.5 ',' ,
       list.!dl.pid.6
    when parm1='DOCDESC' & pid\=''          /*----- DOCDESC.x  -----*/
      then docdesc.pid=data
    when parm1='DOCDESC' & pid=''           /*----- DOCDESC    -----*/
      then docdesc.=data
    when parm='DOCPROF' then nop            /*----- DOCPROF    -----*/
    when parm='DUMPVARS' then ?dumpvars=true/*----- DUMPVARS   -----*/
    when parm='DVCF' then do while data\='' /*----- DVCF       -----*/
      parse var data atom data; call Eval_SETDVCF atom 'ON'
      end
    when parm='EXPDATE' then expdate=datauc /*----- EXPDATE    -----*/
    when parm='FBC' then select             /*----- FBC        -----*/
      when datauc=!yes
        then parse value '1 Part Chapter' with ?fbc bodyhd0 bodyhd1
      when datauc=!no
        then parse value '0' with ?fbc bodyhd0 bodyhd1
      otherwise call BadParm parm, datauc, noyes
      end
    when parm='FIGCAPLOC'                   /*----- FIGCAPLOC  -----*/
      then ?figcaptop = ValOpt(datauc,,'BEFORE AFTER',true false)
    when parm='FIGLIST' then do             /*----- FIGLIST    -----*/
      temp1=noyes 'NOPAGE PAGE'; temp2=noyesval true true
      ?figlistwanted = ValOpt(datauc,,temp1,temp2,noyes)
      end
    when parm='FNLINK' then select          /*----- FNLINK     -----*/
     when datauc=!no   then parse value false with ?fnlinkto 1 ?fnlinkfrom
     when datauc=!to   then parse value true false with ?fnlinkto ?fnlinkfrom
     when datauc=!from then parse value false true with ?fnlinkto ?fnlinkfrom
     when datauc=!both then parse value true with ?fnlinkto 1 ?fnlinkfrom
     otherwise call BadParm parm, datauc, !no !to !from !both
     end
    when parm='FNTAG' then if ?OKcum.soc    /*----- FNTAG      -----*/
      then parse var data list.!fn.1 ',' list.!fn.2 ',' list.!fn.3 ',',
           list.!fn.4 ',' list.!fn.5 ',' list.!fn.6 ',' list.!fn.7 ',',
           list.!fn.8 ',' list.!fn.9 ',' list.!fn.10 ','
    when parm='FONTTAG' then do             /*----- FONTTAG    -----*/
      parse var data d1 ',' d2 ',' d3
      font.=d1; efont.=d2
      fontprop.=ValOpt(translate(d3),'PROP','PROP NOPROP','1 0')
      end
    when parm1='FONTTAG' then do            /*----- FONTTAG.name ---*/
      parse var data d1 ',' d2 ',' d3
      font.pid=d1; efont.pid=d2
      fontprop.pid=ValOpt(translate(d3),'PROP','PROP NOPROP','1 0')
      end
    when parm='FOOTER' then if ?OKcum.soc   /*----- FOOTER     -----*/
      then if data \= '' then if datauc = 'NO'
        then saverec.!footer.0 = 0
        else do; k=0
          if currsys=MVS &,                              /* !OPSYS! */
             translate(left(datauc,3))='DD:' then do
            parse var datauc 'DD:' ddff . '(' ddmem . ')'
            datauc=GetDSNbyDD(ddff,ddmem,'IN',1); data=datauc
            DDname.datauc=ddff; ?DDprealloc.datauc=1; k=1
            end
          j=0; do i=1 to saverec.!footer.0 while j=0
            j=(translate(saverec.!footer.i)=datauc)
            end
          if \j then if k
            then call SaveRec !footer, CurrSysFile("'",data"'",1)
            else call SaveRec !footer, CurrSysFile(data)
          end
    when parm='FTLINK'                      /*----- FTLINK     -----*/
      then ?ftlink = ValOpt(datauc,,noyes,noyesval)
    when parm='FTSEP'                       /*----- FTSEP      -----*/
      then ?ftsep = ValOpt(datauc,,noyes,noyesval)
    when parm='GLFMT'                       /*----- GLFMT      -----*/
      then ?glfmt = ValOpt(datauc,,'DL TABLE',false true)
    when parm1='GLTAG' & pid\=''            /*----- GLTAG.x    -----*/
      then parse var data list.!gl.pid.1 ',' list.!gl.pid.2 ',',
       list.!gl.pid.3 ',' list.!gl.pid.4 ',' list.!gl.pid.5 ',',
       list.!gl.pid.6 ',' list.!gl.pid.7 ',' list.!gl.pid.8 ',',
       list.!gl.pid.9
    when parm='H3ADDONS' then nop           /*----- H3ADDONS (old) -*/
    when parm='H3TABLE'  then nop           /*----- H3TABLE  (old) -*/
    when parm='HEADER' then if ?OKcum.soc   /*----- HEADER     -----*/
      then if data \= '' then if datauc = 'NO'
        then saverec.!header.0 = 0
        else do; k=0
          if currsys=MVS &,                              /* !OPSYS! */
             translate(left(datauc,3))='DD:' then do
            parse var datauc 'DD:' ddff . '(' ddmem . ')'
            datauc=GetDSNbyDD(ddff,ddmem,'IN',1); data=datauc
            DDname.datauc=ddff; ?DDprealloc.datauc=1; k=1
            end
          j=0; do i=1 to saverec.!header.0 while j=0
            j=(translate(saverec.!header.i)=datauc)
            end
          if \j then if k
            then call SaveRec !header, CurrSysFile("'",data"'",1)
            else call SaveRec !header, CurrSysFile(data)
          end
    when parm='HEADNUM' then select         /*----- HEADNUM    -----*/
      when datauc=!no  then numberh=0
      when datauc=!yes then numberh=6
      otherwise             numberh=MaxNumDigit(data)
      end
    when parm = 'HEADREC'                   /*----- HEADREC    -----*/
      then if datauc = 'CLEAR'
        then saverec.!headrec.0 = 0
        else call BadParm parm,datauc,'CLEAR'
    when parm1='HEADREC' then if ?OKcum.soc /*----- HEADREC.x  -----*/
      then select
        when pid = 'FILE' then call SaveRec !headrec, 'F' data
        when pid = 'TEXT' then call SaveRec !headrec, 'T' data
        otherwise call BadParm 'HEADREC.x',pid,"'x' must be 'FILE' or 'TEXT'"
        end
    when parm='HRTAG' then hrtag. = data    /*----- HRTAG      -----*/
    when parm1='HRTAG' & pid\='' then do    /*----- HRTAG.x    -----*/
      i2 = "'x' must be a number from 1 to 13"
      select
        when \datatype(pid,'W') then call BadParm 'HRTAG.x',pid,i2
        when pid<1 | pid>13     then call BadParm 'HRTAG.x',pid,i2
        otherwise hrtag.pid = data
        end
      end
    when parm='HTAG' then htag. = data      /*----- HTAG       -----*/
    when parm1='HTAG' & pid\='' then do     /*----- HTAG.x     -----*/
      i2 = "'x' must be a number from 0 to 20"
      select
        when \datatype(pid,'W') then call BadParm 'HTAG.x',pid,i2
        when pid<0 | pid>20     then call BadParm 'HTAG.x',pid,i2
        otherwise htag.pid = data
        end
      end
    when parm='HTML'                        /*----- HTML       -----*/
      then if wordpos(datauc,'2 3 4') > 0
        then do
          htmlrel = datauc
          if htmlrel=2 then parse value '0' with 1 ?dlfmt 1 ?glfmt
          select
            when htmlrel=2 then htmlenvs='2 2+'
            when htmlrel=3 then htmlenvs='2+ 3 3+'
            when htmlrel=4 then htmlenvs='2+ 3+ 4 4+'
            otherwise nop
            end
          end
        else call BadParm parm,datauc,'2 3 4'
    when parm1='HTMLDOCID' & pid\=''        /*----- HTMLDOCID.x ----*/
      then htmldocid.pid=data
    when parm='HTMLATT'                     /*----- HTMLATT    -----*/
      then if data = ''
        then htmlx. = ''
        else htmlx. = ' 'data
    when parm1='HTMLATT' & pid\=''          /*----- HTMLATT.x  -----*/
      then if data = ''
        then htmlx.pid = ''
        else htmlx.pid = ' 'data
    when parm='HTMLEXT'                     /*----- HTMLEXT    -----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed; else if datauc\='' then htmlext=data
    when parm='HTMPEXT'                     /*----- HTMPEXT    -----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed
        else if currsys=CMS | currsys=MVS                /* !OPSYS! */
          then htmpext=datauc; else htmpext=data
    when parm='IMBEDID'                     /*----- IMBEDID    -----*/
      then ?imbedid = ValOpt(datauc,,noyes,noyesval)
    when parm='IMBFT' then if datauc \= ''  /*----- IMBFT      -----*/
      then if currsys=CMS | currsys=MVS                  /* !OPSYS! */
        then defimbft=datauc; else defimbft=data
    when parm='IMBFTEXT' then do            /*----- IMBFTEXT   -----*/
      parse var data ?imbftext ',' imbftextcase ',' data
      ?imbftext = ValOpt(?imbftext,'NO',noyes,noyesval)
      imbftextcase = ValOpt(imbftextcase,'LC','ASIS LC UC','0 1 2')
      do while data \= ''; parse var data soft '=' soext data
        soft=translate(soft); imbftext.soft=soext
        end
      end
    when parm='IMBPATH' then if ?OKcum.soc  /*----- IMBPATH    -----*/
     then select
      when datauc ='CLEAR' then imbpath=''
      when data   =''      then nop
      when imbpath=''      then imbpath=strip(data)
      otherwise imbpath=imbpath';'strip(data)
      end
    when parm='IMGPATH' then imgpath=strip(data)/*- IMGPATH    -----*/
    when parm='INDEX' then do               /*----- INDEX      -----*/
      select
        when datauc=!yes then ?index=true
        when datauc=!no  then ?index=false
        when datauc=''   then ?index=true
        otherwise call BadParm parm,datauc,noyes 'or nothing to assume YES'
        end
      call Set_SplitLink; call DefSymbol '$INDX',?index
      end
    when parm='INDEXREFLINK'                /*----- INDEXREFLINK ---*/
      then ?indexref = ValOpt(datauc,,noyes,noyesval)
    when parm='NOINDEX'                     /*----- NOINDEX    -----*/
      then do; ?index=false; call DefSymbol '$INDX',0; end
    when parm1='INDEXSORT' &,               /*----- INDEXSORT.x ----*/
         wordpos(pid,'SPEC NUM LETTER')>0
      then do while datauc \= ''
        parse var datauc atom datauc
        parse var atom i1 '-' i2; if i2='' then i2=i1
        i1=HexChar(i1,,1); i2=HexChar(i2,,1)
        if i1='' | i2='' then call BadParm parm, atom
        if i1 > i2 then call MsgOut !term 121,,
                             "'"atom"' not an ascending range for" parm
        do i3 = c2d(i1) to c2d(i2)
          select
            when pid='SPEC' then i4='00'x
            when pid='NUM'  then i4='01'x
            otherwise            i4=d2c(i3)
            end
          indexxlate = overlay(i4,indexxlate,i3+1)
          end
        end
    when parm='INDEXTAG' then parse value data,/*-- INDEXTAG   -----*/
      with list.!index.1 ',' list.!index.2 ',' list.!index.3 ',',
           list.!index.4 ',' list.!index.5 ',' list.!index.6
    when parm='INDEXTOC' then select        /*----- INDEXTOC   -----*/
      when datauc = !no         then indextoc=9999999
      when datauc = !yes        then indextoc=0
      when datatype(datauc,'W') then indextoc=datauc
      otherwise call BadParm parm,datauc,noyes 'or a numeric value'
      end
    when parm='INDEXTOCTAG' then parse value data,/*INDEXTOCTAG ----*/
      with list.!indextoc.1 ',' list.!indextoc.2 ',' list.!indextoc.3 ',',
           list.!indextoc.4 ',' list.!indextoc.5 ',' list.!indextoc.6 ',',
           list.!indextoc.7 ',' list.!indextoc.8
    when parm='LINENUM' then select         /*----- LINENUM    -----*/
      when datauc='NO'    then linenum=0
      when datauc='BEGIN' then linenum=1
      when datauc='END'   then linenum=2
      otherwise do
        parse var datauc scol '-' ecol .
        if datatype(scol,'W') & datatype(ecol,'W') & scol<ecol
          then do; linenum=3; linenums=scol; linenuml=ecol-scol+1; end
          else call BadParm parm,datauc,'NO BEGIN END startcol-endcol'
        end
      end
    when parm='LINES'                       /*----- LINES      -----*/
      then ?lines = ValOpt(datauc,,'BR PRE',true false)
    when parm='LINEWIDTH'                   /*----- LINEWIDTH  -----*/
      then if datatype(datasym,'W')
        then if datasym < 40
          then call BadParm parm,datasym,'Numeric value of 40 or larger'
          else linewidth. = datasym
        else call BadParm parm, datasym
    when parm='LIREF'                       /*----- LIREF      -----*/
      then ?liref=ValOpt(datauc,,'NO ID ACTUAL NUM ','0 1 2 2','NO ID ACTUAL')
    when parm='LOG'                         /*----- LOG        -----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed
        else do
          parse var data data ',' temp2; datauc=translate(data)
          if ?OKcum.soc & datauc\='' then select
            when datauc=!no  then logfile=''
            when datauc=!yes then logfile=logdflt
            when ?pipe & left(datauc,6)=='STREAM' then do
              temp1 = substr(datauc,7)
              if datatype(temp1,'W')
                then do
                  'streamstate output' temp1
                  if rc>=0 & rc<=8
                    then do; logfile=datauc; logstream=temp1; end
                    else call MsgOut ?prcunkopt 128, ,
                        'Output stream' temp1 'not defined for LOG='datauc
                  end
                else call BadParm parm,datauc,
                     "STREAMx where 'x' is a numeric value"
              end
            otherwise logfile=CurrSysFile(data)
            end
          ?logappend = ValOpt(translate(temp2),'CREATE','CREATE APPEND',0 1)
          end
    when parm='LTGT'                        /*----- LTGT       -----*/
      then ?ltgt = ValOpt(datauc,,'CONVERT ASIS',true false)
    when parm='MASTALT' then mastalt=data   /*----- MASTALT    -----*/
    when parm='MASTIMG' then do             /*----- MASTIMG    -----*/
      parse var data data ',' temp2; mastimg=data
      ?mastimg = ValOpt(translate(temp2),'ALL','ALL FIRST',1 0)
      end
    when parm='MAXWIDTH' then select        /*----- MAXWIDTH   -----*/
      when datauc = 'NOSPLIT' then maxwidth = 0
      when datatype(data,'W') then maxwidth = max(0,data)
      otherwise call BadParm parm, data,"'NOSPLIT' or a numeric value"
      end
    when parm='META'                        /*----- META       -----*/
      then ?wantmeta = ValOpt(datauc,,noyes,noyesval)
    when parm='METAKEYS'                    /*----- METAKEYS   -----*/
      then metakeys = space(datauc)
    when parm='MSGLEVEL'                    /*----- MSGLEVEL   -----*/
      then msglevel = ValOpt(datauc,,'INFO WARNING ERROR',,
                             rc.!info rc.!warning rc.!error)
    when parm='MSGNUM'                      /*----- MSGNUM     -----*/
      then ?msgnum = ValOpt(datauc,,noyes,noyesval)
    when parm1='MVSALLOC' & pid\=''         /*----- MVSALLOC.x -----*/
      then MVSalloc.pid=datauc
    when parm='NOERASE' then ?noerase=true  /*----- NOERASE    -----*/
    when parm='NOISY' then ?noisy=true      /*----- NOISY      -----*/
    when parm1='NOTELTAG' & pid\=''         /*----- NOTELTAG.x -----*/
      then parse var data list.!notel.pid.1 ',' list.!notel.pid.2 ',',
                          list.!notel.pid.3 ',' list.!notel.pid.4
    when parm='OLSEQ'                       /*----- OLSEQ      -----*/
      then if verify(data,'AaxRryNn') = 0
        then olseq = translate(data,'AaaIii11','AaxRryNn')
        else call BadParm parm, data,,
                  "any of 'A', 'a', 'x', 'R', 'r', 'y', 'N', 'n'"
    when parm1='OLTAG' & pid\=''            /*----- OLTAG.x    -----*/
      then parse var data list.!ol.pid.1 ',' list.!ol.pid.2 ',',
                          list.!ol.pid.3 ',' list.!ol.pid.4
    when parm='OUTPUTFM'                    /*----- OUTPUTFM   -----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed
        else if datauc>='A' & datauc<='Z'
          then outputfm = datauc
          else call BadParm parm, datauc, 'A, B, C, ..., Z'
    when parm='OUTPUTL'                     /*----- OUTPUTL    -----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed; else outputl_file=data
    when parm='OUTPUTL83'                   /*----- OUTPUTL83  -----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed
        else ?outputl83 = ValOpt(datauc,,noyes,noyesval)
    when parm='OUTPUTLCASE'                 /*----- OUTPUTLCASE ----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed
        else outputl_case = ValOpt(datauc,,'ASIS LC UC','0 1 2')
    when parm='OUTPUTP'                     /*----- OUTPUTP    -----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed
        else if left(datauc,3) = 'DD:'
          then outputp_file=datauc; else outputp_file=CurrSysFile(data)
    when parm='OUTPUTP83'                   /*----- OUTPUTP83  -----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed
        else ?outputp83 = ValOpt(datauc,,noyes,noyesval)
    when parm='OUTPUTPCASE'                 /*----- OUTPUTPCASE ----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed
        else outputp_case = ValOpt(datauc,,'ASIS LC UC','0 1 2')
    when parm='OWNER' then owner=datasym    /*----- OWNER      -----*/
    when parm='PROCACT'                     /*----- PROCACT    -----*/
      then do while datauc \= ''
        parse var datauc parm '=' m2 datauc
        m3 = ValOpt(m2,,'IGNORE INFO WARNING ERROR TERM',,
                     !msgignore !info !warning !error !term)
        select
          when parm='NOENDTAG' then ?prcnoendtag=m3
          when parm='NOIMBED'  then ?prcnoimbed =m3
          when parm='NOINDEX'  then ?prcnoindex =m3
          when parm='NOPER'    then ?prcnoper   =m3
          when parm='NOXREF'   then ?prcnoxref  =m3
          when parm='UNKOPT'   then ?prcunkopt  =m3
          when parm='UNKSYM'   then ?prcunksym  =m3
          when parm='UNKTAG'   then ?prcunktag  =m3
          otherwise call BadParm 'PROCACT',parm,,
              'NOENDTAG NOIMBED NOINDEX NOPER NOXREF UNKOPT UNKSYM UNKTAG'
          end
        end
    when parm='PSC' then psc = datauc       /*----- PSC        -----*/
    when parm='PTOC' then if datauc='NO'    /*----- PTOC       -----*/
      then ptoclevel=-1; else ptoclevel=word(MaxNumDigit(data) '4',1)
    when parm='QRESET' then select          /*----- QRESET     -----*/
      when datauc = !no then qreset = -1
      when \datatype(datauc,'W') then call BadParm parm,datauc,'NO, 0 to 20'
      when datauc<0 | datauc>20  then call BadParm parm,datauc,'NO, 0 to 20'
      otherwise qreset = datauc
      end
    when parm='QUESTION' then do            /*----- QUESTION   -----*/
      parse var data p1 . ',' p2 . ',' questurl ',' p4 ',' ansfilel
      ?questform  = ValOpt(translate(p1),'TEXT','TEXT FORM',0 1)
      questmethod = ValOpt(translate(p2),'GET','GET POST','GET POST')
      if p4 = '' then p4 = 'HIDDEN'
      data=p4; datauc=translate(p4)
      select
        when datauc='NONE'   then ?questans=0
        when datauc='HIDDEN' then ?questans=1
        otherwise do
          ?questans = 2
          call CloseAnsFile
          ansfilep = CurrSysFile(data,1)
          if currsys=CMS & ansfilep\=''                  /* !OPSYS! */
            then ansfilep=CMSfile(ansfilep,'DATA', outputfm)
          call GetReadyForOutput ansfilep, !ansfile
          call OpenFile ansfilep,!write,MVSalloc.!ansfile
          end
        end
      end
    when parm='QUIET' then ?noisy=false     /*----- QUIET      -----*/
    when parm='REVDATE' then revdate=datauc /*----- REVDATE    -----*/
    when parm='REVTAG' then do              /*----- REVTAG     -----*/
      parse var data d1 ',' d2 ',' d3
      rev.=d1; erev.=d2
      revprop.=ValOpt(translate(d3),'PROP','PROP NOPROP','1 0')
      end
    when parm1='REVTAG' then do             /*----- REVTAG.id  -----*/
      parse var data d1 ',' d2 ',' d3
      rev.pid=d1; erev.pid=d2
      revprop.pid=ValOpt(translate(d3),'PROP','PROP NOPROP','1 0')
      end
    when parm='SCREEN'                      /*----- SCREEN     -----*/
      then ?screenshade=(datauc='SHADE')
    when parm='SECURITY' then security=datasym /*-- SECURITY   -----*/
    when parm1='SETUPTAG' & pid\=''         /*----- SETUPTAG.x -----*/
      then do; setuptag.pid.1=data; setuptag.pid.2=data2; end
    when parm1='SHADE' & pid\='' then select/*----- SHADE.x    -----*/
      when wordpos(pid,shades)=0 then call BadParm parm1,pid,shades
      when length(datauc)\=6 | verify(datauc,hexchars) > 0
        then call BadParm parm, datauc, 'Six hexadecimal digits'
      otherwise shade.pid='BGCOLOR="#'datauc'"'
      end
    when parm='SHOWLINES' then select       /*----- SHOWLINES  -----*/
      when datatype(datauc,'W') then showlines=datauc
      when datauc = !no         then showlines=noshowlines
      otherwise call BadParm parm, datauc, 'NO or numeric value'
      end
    when parm='SHOWPROF'                    /*----- SHOWPROF   -----*/
      then ?showprof = ValOpt(datauc,,noyes,noyesval)
    when parm='SHOWSYM'                     /*----- SHOWSYM    -----*/
      then ?showsym  = ValOpt(datauc,,noyes,noyesval)
    when parm1='SLTAG' & pid\=''            /*----- SLTAG.x    -----*/
      then parse var data list.!sl.pid.1 ',' list.!sl.pid.2 ',',
                          list.!sl.pid.3 ',' list.!sl.pid.4
    when parm='SOURCE'                      /*----- SOURCE     -----*/
      then if ?WithinFile.soc
        then call ParmNotAllowed
        else do; parse var datauc part1 . ',' part2 . ',' part3
          select
            when part1=!script     then source=!script
            when part1=!scriptonly then source=!scriptonly
            when part1 \= !flat
              then call BadParm parm,datauc,!script !scriptonly !flat
            otherwise do; source=!flat
              if part2='' then part2='PRE'
              if part3='' then part3='NO'
              select
                when part2='PRE'   then precol=0
                when part2='NOPRE' then precol=-1
                when \datatype(part2,'W')
                  then call BadParm parm,part2,'PRE, NOPRE or numeric value'
                otherwise precol=part2
                end
              select
                when part3=!no  then blankrec=''
                when part3=!yes then blankrec='<P>'
                otherwise blankrec=part3
                end
              end
            end
          end
    when parm='SPLITDIGITS' | parm='PARTDIGITS' /*- SPLITDIGITS ----*/
     then do; parse var datauc pdnum ',' pdtype .
      if \datatype(pdnum,'W')
        then pdnum=2; else pdnum=trunc(max(min(pdnum,4),1))
      pdtype = ValOpt(pdtype,'DEC','DEC HEX ALPHA LALPHA',0 1 2 3)
      end
    when parm1='SPLITDIR' |,                /*-- SPLITDIR<.x<-y>> --*/
         parm1='PARTDIR' then do
      parse var data i1 ',' i2; i1=strip(i1); i2=strip(i2)
      select
        when pid = '' then do; partdirp.=i1; partdirl.=i2; end
        when pid = 'NEXT'
          then do; pid=currpartnum+1; partdirp.pid=i1; partdirl.pid=i2; end
        otherwise do
          parse var pid x1 '-' x2; if x2='' then x2=x1
          if datatype(x1,'W') & datatype(x2,'W') & x1<=x2
            then do i = x1 to x2; partdirp.i=i1; partdirl.i=i2; end
            else call BadParm 'SPLITDIR.x',pid,
                 "'x' is an invalid number or range!"
          end
        end
      end
    when parm='SPLITLINK' | parm='PARTLINK' /*----- SPLITLINK  -----*/
      then ?splitlink = ValOpt(datauc,,noyes,noyesval)
    when ( parm1='SPLITLINK' | parm1='PARTLINK'),/*-SPLITLINK.x ----*/
          & pid\='' then do
     i2 = "'x' must be a number from 1 to 6 or 11 to 16"
     select
      when \datatype(pid,'W')          then call BadParm 'SPLITLINK.x',pid,i2
      when pid<1|pid>16|(pid>6&pid<11) then call BadParm 'SPLITLINK.x',pid,i2
      when datauc = 'CLEAR'            then splitlink.pid = ''
      otherwise splitlink.pid = splitlink.pid || data || ' '
      end
     end
    when parm1='SPLITNAME' | parm1='PARTNAME' /*--- SPLITNAME.x ----*/
      then select
        when datatype(pid,'W') then if pid = 1
          then nop
          else do
            parse var data i1 ',' i2
            partnamep.pid=CurrSysFile(strip(i1),1); partnamel.pid=strip(i2)
            end
        when pid = 'NEXT' then do
          pid=currpartnum+1; parse var data i1 ',' i2
          partnamep.pid=CurrSysFile(strip(i1),1); partnamel.pid=strip(i2)
          end
        otherwise call badParm 'SPLITNAME.x',pid,"'x' must be numeric or 'NEXT'"
        end
    when parm='STYLE'                       /*----- STYLE      -----*/
      then if datauc \= '' then docstyle = datauc
    when parm='SYMCHARS' then symchars=data /*----- SYMCHARS   -----*/
    when parm='SYNFONT'                     /*----- SYNFONT    -----*/
      then ?synfont = ValOpt(datauc,,noyes,noyesval)
    when parm='SYSVAR' then do while datasym\=''/*- SYSVAR     -----*/
      parse var datasym atom datasym; atom=translate(atom)
      select
        when atom='A' then do
          parse var datasym atom datasym; atom=translate(atom)
          select
            when atom=!yes then ?annot=true
            when atom=!no  then ?annot=false
            otherwise call MsgOut !term 122,"SYSVAR 'A' value not YES or NO!"
            end
          end
        when atom='W' then do
          sysvarwfid=CurrSysFile(datasym,1,'.'dsmrefft); datasym=''
          end
        when atom>='1' & atom<='9' then do
          parse var datasym atom datasym; call Eval_SETDVCF atom 'ON'
          end
        when atom='0' then if ?OKcum.soc then do
          sysvar0fid=CurrSysFile(datasym,1); datasym=''
          parse value FindFile(sysvar0fid) with qrc (nl)
          if qrc = 0
            then do; call ReadingFile 'SYSVAR 0', sysvar0fid
              do forever
                parse upper value RdLine(sysvar0fid),
                            with  1 ?syseof 2 sysw1 sysrem
                if ?syseof then leave
                if sysw1 = '.SETDVCF' then call Eval_SETDVCF sysrem
                end
              end
            else call FileNotFound !error,'SYSVAR file',sysvar0fid
          end
        otherwise nop
        end
      end
    when parm='TABLE2' then do              /*----- TABLE2     -----*/
      parse value data,
            with  table2.1 ',' table2.2 ',' table2.3 ',' table2.4 ',',
                  table2.5 ',' table2.6 ',' table2.7 ',' table2.8
      do i = 1 to 8; table2len.i = length(table2.i); end
      end
    when parm='TAGCHECK'                    /*----- TAGCHECK   -----*/
      then ?tagcheck = ValOpt(datauc,,noyes,noyesval)
    when parm1='TFIGLISTTAG' & pid\=''      /*----- TFIGLISTTAG.x --*/
      then parse var data list.!tfl.pid.1 ',' list.!tfl.pid.2 ',',
                          list.!tfl.pid.3 ',' list.!tfl.pid.4
    when parm='TITLE' then titleopt=data    /*----- TITLE      -----*/
    when parm='TLIST' then do               /*----- TLIST      -----*/
      temp1=noyes 'NOPAGE PAGE'; temp2=noyesval true true
      ?tlistwanted = ValOpt(datauc,,temp1,temp2,noyes)
      end
    when parm='TOC' then select             /*----- TOC        -----*/
      when datauc=!no  then ?wanttoc=false
      when datauc=!yes then ?wanttoc=true
      otherwise do; ?wanttoc=true; tocmax=MaxNumDigit(data); end
      end
    when parm='TOCC'                        /*----- TOCC       -----*/
      then tocspacer = ValOpt(datauc,,'NO YES','<P>',noyes)
    when parm='TOCINDENT'                   /*----- TOCINDENT  -----*/
      then ?tocindent = ValOpt(datauc,,noyes,noyesval)
    when parm='TOCRET' then do              /*----- TOCRET     -----*/
      temp1 = 'NO TOC PTOC PTOC0 PTOC1 PTOC2 PTOC3 YES'
      temp2 = '0 1 2 3 4 5 6 2'
      tocret = ValOpt(datauc,,temp1,temp2)
      end
    when parm='TOCSUPPRESS'                 /*----- TOCSUPPRESS ----*/
      then if datatype(data,'W')
        then tocsuppress = data
        else call BadParm parm, datauc, 'numeric value'
    when parm='TOCTAG' then parse value data,/*---- TOCTAG     -----*/
      with list.!toc.1 ',' list.!toc.2 ',' list.!toc.3 ',' list.!toc.4 ',',
           list.!toc.5 ',' list.!toc.6 ','
    when parm='TOPHEAD' then select         /*----- TOPHEAD    -----*/
      when datauc=!yes then tophead=1
      when datauc=!no  then tophead=0
      when \datatype(datauc,'W') then call BadParm parm,datauc,noyes '1 to 6'
      when datauc<1 | datauc>6   then call BadParm parm,datauc,noyes '1 to 6'
      otherwise tophead = datauc
      end
    when parm='TRACE' then do               /*----- TRACE      -----*/
      parse value false,
            with  ?trcany 1 ?trcio 1 ?trcparse 1 ?trcpgm 1 ?trace2disk
      datauc = translate(datauc,' ',',')
      do while datauc \= ''
        parse var datauc atom datauc
        select
          when atom='ALL'
            then parse value true  with ?trcio 1 ?trcparse 1 ?trcpgm
          when atom=!no
            then parse value false with ?trcio 1 ?trcparse 1 ?trcpgm
          when atom='I/O'   then ?trcio    = true
          when atom='PARSE' then ?trcparse = true
          when atom='PGM'   then ?trcpgm   = true
          when atom='TERM'  then ?trace2disk = false
          when atom='DISK'  then ?trace2disk = true
          otherwise call BadParm parm, atom, ,
                                 !no 'ALL I/O PARSE PGM TERM DISK'
          end
        end
      ?trcany = ( ?trcio | ?trcparse | ?trcpgm )
      end
    when parm='TRACELIST' then do           /*----- TRACELIST  -----*/
      call MsgOut !info 112, 'Tracing:' datauc
      do while datauc\='';parse var datauc atom datauc;tracelist.atom='I';end
      end
    when parm1='ULTAG' & pid\=''            /*----- ULTAG.x    -----*/
      then parse var data list.!ul.pid.1 ',' list.!ul.pid.2 ',',
                          list.!ul.pid.3 ',' list.!ul.pid.4
    when parm='USERPROF'                    /*----- USERPROF   -----*/
      then if ?OKtoProcess.soc & data\=''
        then call LoadProfile CurrSysFile(data),'user profile',,
                  ?OKtoProcess.soc,?WithinFile.soc,?OKcum.soc
    when parm='USERSYM'                     /*----- USERSYM    -----*/
      then if ?OKtoProcess.soc & data\=''
        then call LoadSymbols CurrSysFile(data),'user symbol table'
    when parm='XEDITG'                      /*----- XEDITG     -----*/
      then ?xeditgchk = ValOpt(datauc,,noyes,noyesval)
    when wordpos(parm,docprof_parms) > 0 then nop  /* :DOCPROF.     */
    otherwise call MsgOut ?prcunkopt 123,"'"parm"' is an unknown option!"
    end
  /*----- process indicated profile/symbol table if requested -----*/
  if ?soprosym.soc then if ?OKtoProcess.soc & soword1.soc\='' then do
    if profilesuffix \= ''
      then call LoadProfile CurrSysFile(soword1.soc||profilesuffix),,
                    'user profile',,
                    ?OKtoProcess.soc,?WithinFile.soc,?OKcum.soc
    if symbolsuffix \= ''
      then call LoadSymbols CurrSysFile(soword1.soc||symbolsuffix),,
                    'user symbol table'
    end
  end
 
soc = soc - 1                          /* reduce uniqueness counter */
return
 
/*------------------------------------------------------------------*/
/* ValOpt: Validate/verify an option's value and return new value   */
/* Usage:  val = OptVal(data,default,valid,replace,errmsg)          */
/*           data    - Value to check                               */
/*           default - Use this value if "data" is null             */
/*           valid   - String of valid user values                  */
/*           replace - One-for-one replacement internal values      */
/*           errmsg  - Error msg if not showing "valid" values      */
/*------------------------------------------------------------------*/
ValOpt:
  parse arg ovdata, ovdef, ovval, ovrep, overr
  if ovdata == '' then ovdata = ovdef
  ovi = wordpos(translate(ovdata),ovval)
  if ovi>0 then return word(ovrep,ovi)
  if overr = '' then overr = ovval
  call BadParm parm, translate(ovdata), overr
  return ovdef
 
ParmNotAllowed:  /*----- current option not allowed right now  -----*/
  call MsgOut !warning 124, parm 'option can not be set from within',
              'a source file', 'unless prior to the first non-comment',
              'record of the main input file', '('input_file')!'
  return
 
BadParm: /* Invalid option's value: call BadParm parm,val,OKvalues  */
  parse arg bp1 ., bp2, bp3
  if bp3 = '' then bp4=''; else bp4='  Valid values:' bp3
  call MsgOut ?prcunkopt 125,"'"bp2"' is an invalid value for" bp1, bp4
  signal Exit_Program
 
CurrSysFile: /* return file processed according to current system */
  parse arg csf1, csf2, csf3; ?csfq=?sodelim.soc
  if currsys=MVS then if csf2 \= '' then do
    ?csfq=(left(csf1,1)="'"); if ?csfq then parse var csf1 "'" csf1 "'"
    end
  select
    when currsys = CMS then csfrslt = translate(csf1)
    when currsys = MVS then if ?csfq
      then csfrslt = translate(csf1)
      else csfrslt = translate(tsoprefix||csf1||csf3)
    otherwise csfrslt = csf1
    end
  return csfrslt
 
 
/*------------------------------------------------------------------*/
/* Routines for checking option values                              */
/*------------------------------------------------------------------*/
SetOpts_FinalProcess:    /* check platform/filename-related options */
  if imgpath \= ''
    then if right(imgpath,1) \= '/' then imgpath=imgpath'/'
  if ?centertag = '' then ?centertag = ( htmlrel >= 3 )
  if currsys = CMS then do                               /* !OPSYS! */
    if ansfilep \= '' then ansfilep = CMSfile(ansfilep,'DATA', outputfm)
    if logfile\='' & logstream='' then logfile = CMSfile(logfile,'LOG',outputfm)
    if outputp_file \= ''
      then outputp_file = CMSfile(outputp_file,htmpext 'HTML',outputfm)
    end
  return
 
/*----- set an output CMS fn/ft/fm -----*/
CMSFile: parse arg cfid, cfft, cffm
  if cfid\='' then do
    parse var cfid cf1 cf2 cf3 .
    cfid = cf1 word(cf2 cfft,1) word(cf3 cffm outputfm,1)
    end
  return translate(cfid)
 
/*----- Check and set overall option relationships -----*/
SetOpts_GlobalCheck:
  if \?wanttoc & tocret\=0 then tocret=0
  if ?fbc & qreset<0 then qreset = 1
  call DefSymbol 'b2hhtmlid',htmldocid.htmlrel
  /*----- insure appropriate HTML level(s) set -----*/
  spi=wordpos('HTML2', psc); if spi>0 then psc=delword(psc,spi,1)
  spi=wordpos('HTML2+',psc); if spi>0 then psc=delword(psc,spi,1)
  spi=wordpos('HTML3', psc); if spi>0 then psc=delword(psc,spi,1)
  spi=wordpos('HTML3+',psc); if spi>0 then psc=delword(psc,spi,1)
  spi=wordpos('HTML4', psc); if spi>0 then psc=delword(psc,spi,1)
  select
    when htmlrel=2 then psc=psc 'HTML2 HTML2+'
    when htmlrel=3 then psc=psc 'HTML2+ HTML3 HTML3+'
    when htmlrel=4 then psc=psc 'HTML2+ HTML3+ HTML4 HTML4+'
    otherwise nop
    end
  spi='b2hhtml'; sym.!amp.spi=htmlrel  /* reset &b2hhtml symbol     */
  spi='$LDEV';   sym.!amp.spi='HTML'htmlrel  /* reset &$LDEV        */
  /*----- ensure DLFMT= & HTML= -----*/
  if ?dlfmt & htmlrel=2 & \?dlfmterr then do
    call NotInHTML2 'DLFMT=TABLE', 'DLFMT=DL assumed'
    ?dlfmt=0; ?dlfmterr=1
    end
  /*----- ensure GLFMT= & HTML= -----*/
  if ?glfmt & htmlrel=2 & \?glfmterr then do
    call NotInHTML2 'GLFMT=TABLE', 'GLFMT=DL assumed'
    ?glfmt=0; ?glfmterr=1
    end
 
  /*----- Syntax diagram definitions -----------*/
  synctl._addverticalspacing = 1     /* Add some vertical spacing */
  synctl._maxwidth = linewidth.llcnt
  /* synctl._choice.<type>.<position> are character sequences     */
  /* used to format choice groups in syntax diagrams.             */
  /* synctl._choice._repsep. : Repetition separator.              */
  synctl._choice._repsep._topleft           = ' '
  synctl._choice._repsep._topright          = ' '
  synctl._choice._repsep._toppad            = ' '
  synctl._choice._repsep._baseleft          = deftext._repsepleft ||,
                                              deftext._dash
  synctl._choice._repsep._baseright         = deftext._dash ||,
                                              deftext._repsepright
  synctl._choice._repsep._basepad           = deftext._dash
  synctl._choice._repsep._bottomleft        = ' '
  synctl._choice._repsep._bottomright       = ' '
  synctl._choice._repsep._bottompad         = ' '
 
  synctl._choice._repsep._topleft._len      = 1
  synctl._choice._repsep._topright._len     = 1
  synctl._choice._repsep._toppad._len       = 1
  synctl._choice._repsep._baseleft._len     = lentext._repsepleft + ,
                                              lentext._dash
  synctl._choice._repsep._baseright._len    = lentext._dash + ,
                                              lentext._repsepright
  synctl._choice._repsep._basepad._len      = lentext._dash
  synctl._choice._repsep._bottomleft._len   = 1
  synctl._choice._repsep._bottomright._len  = 1
  synctl._choice._repsep._bottompad._len    = 1
  /* synctl._choice._above. : Element positioned above baseline.  */
  synctl._choice._above._topleft            = ' '
  synctl._choice._above._topright           = ' '
  synctl._choice._above._toppad             = ' '
  synctl._choice._above._baseleft           = deftext._upperleft ||,
                                              deftext._dash
  synctl._choice._above._baseright          = deftext._dash ||,
                                              deftext._upperright
  synctl._choice._above._basepad            = deftext._dash
  synctl._choice._above._bottomleft         = deftext._middleleft
  synctl._choice._above._bottomright        = deftext._middleright
  synctl._choice._above._bottompad          = ' '
 
  synctl._choice._above._topleft._len       = 1
  synctl._choice._above._topright._len      = 1
  synctl._choice._above._toppad._len        = 1
  synctl._choice._above._baseleft._len      = lentext._upperleft + ,
                                              lentext._dash
  synctl._choice._above._baseright._len     = lentext._dash +,
                                              lentext._upperright
  synctl._choice._above._basepad._len       = lentext._dash
  synctl._choice._above._bottomleft._len    = lentext._middleleft
  synctl._choice._above._bottomright._len   = lentext._middleright
  synctl._choice._above._bottompad._len     = 1
  /* synctl._choice._ondef.  : Element positioned on baseline     */
  /* with elements above and below.                               */
  synctl._choice._ondef._topleft            = deftext._middleleft
  synctl._choice._ondef._topright           = deftext._middleright
  synctl._choice._ondef._toppad             = ' '
  synctl._choice._ondef._baseleft           = deftext._cross || deftext._dash
  synctl._choice._ondef._baseright          = deftext._dash || deftext._cross
  synctl._choice._ondef._basepad            = deftext._dash
  synctl._choice._ondef._bottomleft         = deftext._middleleft
  synctl._choice._ondef._bottomright        = deftext._middleright
  synctl._choice._ondef._bottompad          = ' '
 
  synctl._choice._ondef._topleft._len       = lentext._middleleft
  synctl._choice._ondef._topright._len      = lentext._middleright
  synctl._choice._ondef._toppad._len        = 1
  synctl._choice._ondef._baseleft._len      = lentext._cross +  lentext._dash
  synctl._choice._ondef._baseright._len     = lentext._dash +  lentext._cross
  synctl._choice._ondef._basepad._len       = lentext._dash
  synctl._choice._ondef._bottomleft._len    = lentext._middleleft
  synctl._choice._ondef._bottomright._len   = lentext._middleright
  synctl._choice._ondef._bottompad._len     = 1
  /* synctl._choice._ondeflow. : Element positioned on baseline   */
  /* with an element above and none below.                        */
  synctl._choice._ondeflow._topleft         = deftext._middleleft
  synctl._choice._ondeflow._topright        = deftext._middleright
  synctl._choice._ondeflow._toppad          = ' '
  synctl._choice._ondeflow._baseleft        = deftext._teeup || deftext._dash
  synctl._choice._ondeflow._baseright       = deftext._dash || deftext._teeup
  synctl._choice._ondeflow._basepad         = deftext._dash
  synctl._choice._ondeflow._bottomleft      = ' '
  synctl._choice._ondeflow._bottomright     = ' '
  synctl._choice._ondeflow._bottompad       = ' '
 
  synctl._choice._ondeflow._topleft._len    = lentext._middleleft
  synctl._choice._ondeflow._topright._len   = lentext._middleright
  synctl._choice._ondeflow._toppad._len     = 1
  synctl._choice._ondeflow._baseleft._len   = lentext._teeup +  lentext._dash
  synctl._choice._ondeflow._baseright._len  = lentext._dash +  lentext._teeup
  synctl._choice._ondeflow._basepad._len    = lentext._dash
  synctl._choice._ondeflow._bottomleft._len = 1
  synctl._choice._ondeflow._bottomright._len= 1
  synctl._choice._ondeflow._bottompad._len  = 1
  /* synctl._choice._onnodef. : Elements positioned on baseline   */
  /* without an element above and with one below.                 */
  synctl._choice._onnodef._topleft          = ' '
  synctl._choice._onnodef._topright         = ' '
  synctl._choice._onnodef._toppad           = ' '
  synctl._choice._onnodef._baseleft         = deftext._teedown || deftext._dash
  synctl._choice._onnodef._baseright        = deftext._dash || deftext._teedown
  synctl._choice._onnodef._basepad          = deftext._dash
  synctl._choice._onnodef._bottomleft       = deftext._middleleft
  synctl._choice._onnodef._bottomright      = deftext._middleright
  synctl._choice._onnodef._bottompad        = ' '
 
  synctl._choice._onnodef._topleft._len     = 1
  synctl._choice._onnodef._topright._len    = 1
  synctl._choice._onnodef._toppad._len      = 1
  synctl._choice._onnodef._baseleft._len    = lentext._teedown +  lentext._dash
  synctl._choice._onnodef._baseright._len   = lentext._dash +  lentext._teedown
  synctl._choice._onnodef._basepad._len     = lentext._dash
  synctl._choice._onnodef._bottomleft._len  = lentext._middleleft
  synctl._choice._onnodef._bottomright._len = lentext._middleright
  synctl._choice._onnodef._bottompad._len   = 1
  /* synctl._choice._onnodeflow.  : Element positioned on         */
  /* baseline without an element above or below.                  */
  synctl._choice._onnodeflow._topleft         = ' '
  synctl._choice._onnodeflow._topright        = ' '
  synctl._choice._onnodeflow._toppad          = ' '
  synctl._choice._onnodeflow._baseleft        = deftext._cross || deftext._dash
  synctl._choice._onnodeflow._baseright       = deftext._dash || deftext._cross
  synctl._choice._onnodeflow._basepad         = deftext._dash
  synctl._choice._onnodeflow._bottomleft      = ' '
  synctl._choice._onnodeflow._bottomright     = ' '
  synctl._choice._onnodeflow._bottompad       = ' '
 
  synctl._choice._onnodeflow._topleft._len    = 1
  synctl._choice._onnodeflow._topright._len   = 1
  synctl._choice._onnodeflow._toppad._len     = 1
  synctl._choice._onnodeflow._baseleft._len   = lentext._cross +  lentext._dash
  synctl._choice._onnodeflow._baseright._len  = lentext._dash +  lentext._cross
  synctl._choice._onnodeflow._basepad._len    = lentext._dash
  synctl._choice._onnodeflow._bottomleft._len = 1
  synctl._choice._onnodeflow._bottomright._len= 1
  synctl._choice._onnodeflow._bottompad._len  = 1
  /* synctl._choice._below. : Elements positioned below baseline. */
  synctl._choice._below._topleft            = deftext._middleleft
  synctl._choice._below._topright           = deftext._middleright
  synctl._choice._below._toppad             = ' '
  synctl._choice._below._baseleft           = deftext._teeleft || deftext._dash
  synctl._choice._below._baseright          = deftext._dash || deftext._teeright
  synctl._choice._below._basepad            = deftext._dash
  synctl._choice._below._bottomleft         = deftext._middleleft
  synctl._choice._below._bottomright        = deftext._middleright
  synctl._choice._below._bottompad          = ' '
 
  synctl._choice._below._topleft._len       = lentext._middleleft
  synctl._choice._below._topright._len      = lentext._middleright
  synctl._choice._below._toppad._len        = 1
  synctl._choice._below._baseleft._len      = lentext._teeleft +  lentext._dash
  synctl._choice._below._baseright._len     = lentext._dash +  lentext._teeright
  synctl._choice._below._basepad._len       = lentext._dash
  synctl._choice._below._bottomleft._len    = lentext._middleleft
  synctl._choice._below._bottomright._len   = lentext._middleright
  synctl._choice._below._bottompad._len     = 1
  /* synctl._choice._lowest. : Lowest element positioned below baseline */
  synctl._choice._lowest._topleft           = deftext._middleleft
  synctl._choice._lowest._topright          = deftext._middleright
  synctl._choice._lowest._toppad            = ' '
  synctl._choice._lowest._baseleft          = deftext._lowerleft ||,
                                              deftext._dash
  synctl._choice._lowest._baseright         = deftext._dash ||,
                                              deftext._lowerright
  synctl._choice._lowest._basepad           = deftext._dash
  synctl._choice._lowest._bottomleft        = ' '
  synctl._choice._lowest._bottomright       = ' '
  synctl._choice._lowest._bottompad         = ' '
 
  synctl._choice._lowest._topleft._len      = lentext._middleleft
  synctl._choice._lowest._topright._len     = lentext._middleright
  synctl._choice._lowest._toppad._len       = 1
  synctl._choice._lowest._baseleft._len     = lentext._lowerleft +,
                                              lentext._dash
  synctl._choice._lowest._baseright._len    = lentext._dash + ,
                                              lentext._lowerright
  synctl._choice._lowest._basepad._len      = lentext._dash
  synctl._choice._lowest._bottomleft._len   = 1
  synctl._choice._lowest._bottomright._len  = 1
  synctl._choice._lowest._bottompad._len    = 1
  return
 
/*------------------------------------------------------------------*/
/* MaxNumDigit: Returns largest single numeric digit in string      */
/* Usage:  x = MaxNumDigit('01234')             "x" set to "4"      */
/*         x = MaxNumDigit('*3')'               "x" set to "3"      */
/*------------------------------------------------------------------*/
MaxNumDigit: mndstr=arg(1); mndmax=0
  if left(mndstr,1) == '*' then mndstr = substr(mndstr,2)
  do while mndstr\=''
    parse var mndstr 1 atom 2 mndstr
    if \datatype(atom,'W')
      then call BadParm parm, datauc
      else if atom > mndmax then mndmax = atom
    end
  return mndmax
 
/*------------------------------------------------------------------*/
/* AlphaSeq: Convert a number to alpha (e.g. 5 = e)                 */
/* RomanSeq: Convert a number to roman numerals (e.g. 23 = XXIII)   */
/* Usage: str = AlphaSeq(number,case)     case: 0=lc  1=UC          */
/*        str = RomanSeq(number,case)                               */
/*------------------------------------------------------------------*/
AlphaSeq: parse arg asnum, ?ascase; asrslt=''
  do asi = 3 to 1 by -1
    asj=26**asi; if asj >= asnum then iterate
    asdigit = (asnum-asj-1) % asj + 1
    asrslt = asrslt || substr(alphalc,asdigit,1)
    asnum = asnum // asj
    end; if asrslt\='' & asnum=0 then asnum=26
  asrslt = asrslt || substr(alphalc,asnum,1)
  if ?ascase then asrslt=translate(asrslt)
  return asrslt
 
RomanSeq: parse arg ronum, ?rocase; rorslt=''
  ro_b='111344447'; ro_l='123212342'; ro_r='iiiviiixxxlxxxcccdcccmmmmm'
  ro_m = ronum %1000
  ro_c = ronum//1000 %100
  ro_x = ronum//1000//100 %10
  ro_i = ronum//1000//100//10
  if ro_m>0 then rorslt=rorslt||substr(ro_r,22,m)
  if ro_c>0 then
     rorslt=rorslt||substr(ro_r,substr(ro_b,ro_c,1)+14,substr(ro_l,ro_c,1))
  if ro_x>0 then
     rorslt=rorslt||substr(ro_r,substr(ro_b,ro_x,1)+ 7,substr(ro_l,ro_x,1))
  if ro_i>0 then
     rorslt=rorslt||substr(ro_r,substr(ro_b,ro_i,1)+ 0,substr(ro_l,ro_i,1))
  if ?rocase then rorslt=translate(rorslt)
  return rorslt
 
/*------------------------------------------------------------------*/
/* MSGOUT:  Display a message on the terminal                       */
/* Usage:   call Msgout type <number>, msg1 <, msg2, ... msgx >     */
/*     type   - Msg type: !info, !warning, !error, !term, !usermsg  */
/*                        or !msgignore                             */
/*              If "!term", the message is shown and the program    */
/*              is terminated; if "!msgignore", control is returned */
/*              immediately.  Else the message is shown if at or    */
/*              above the current MSGLEVEL.                         */
/*     number - Optional message number.  If omitted, 3 blanks shown*/
/*     msgx   - Lines(s) of message text.  If a line contains the   */
/*              variable '!recnum', the record number of the        */
/*              current input file is displayed. If a line contains */
/*              '!recnumo', the saved record number is shown.       */
/*              msg2-msgx are indented 2 spaces.                    */
/*------------------------------------------------------------------*/
MsgOut: rtn='MSGOUT'; trace value tracelist.rtn
  parse arg msgtype msgnum .
  select
    when msgtype = !msgignore then return
    when msgtype = !term
      then parse value !error 'EXIT' true with msgtype msgexit ?noisy
    otherwise msgexit = ''
    end
  if rc.msgtype > rc.!info then quit_rc = max(quit_rc,rc.msgtype - 4)
  select
    when \?msgnum             then msgnum=''
    when datatype(msgnum,'W') then msgnum='B2H'right(msgnum,3,'0')
    otherwise                      msgnum=left(msgnum,6)
    end
 
  if rc.msgtype=0 | msglevel<=rc.msgtype then do
    /*----- show eye-catcher line if not shown yet -----*/
    if \?eyesay then do; if ?noisy then say EyeLine(); ?eyesay=true; end
    if ?WriteToLog & \?eyelog then do
      call WriteLog 'Command:' pgmfn pgmparms
      call WriteLog EyeLine()
      ?eyelog = true
      end
    if ?trcany then if ?trace2disk & \?eyetrc
      then do; call TraceMsg EyeLine(),sigl,'Msg'; ?eyetrc=true; end
    /*----- process the message -----*/
    do msgi = 2 to arg()
      msgtext = arg(msgi)
      select
        when msgtext = !recnum
          then msgtext='(in line' word(source_id.infilecnt,1),
                       'of' subword(source_id.infilecnt,2)')'
        when msgtext = !recnumo
          then msgtext='(in line' word(source_id_orig.infilecnt,1),
                       'of' subword(source_id_orig.infilecnt,2)')'
        otherwise nop
        end
      if msgtext == '' then iterate
      if msgi > 2 then msgtext = '  'msgtext
      select
        when msgtype = !error   then msgtypec = '|'msgnum 'ERROR:  '
        when msgtype = !warning then msgtypec = '|'msgnum 'WARNING:'
        when msgtype = !info    then msgtypec = '|'msgnum 'Info:   '
        when msgtype = !userinp then msgtypec = '|'msgnum 'UserInp:'
        when msgtype = !usermsg then msgtypec = '|'msgnum 'UserMsg:'
        otherwise                    msgtypec = ''
        end
      alarm = ''
      if ?pc then if rc.msgtype > rc.!info then do
        _alarmcnt=_alarmcnt-1; if _alarmcnt>=0 then alarm=x2c('07')
        end
      if ?trcany then call TraceMsg msgtypec msgtext,sigl,'Msg'
      if ?noisy then say msgtypec msgtext alarm
      if ?WriteToLog then call WriteLog msgtypec msgtext
      end
    if msgexit \= '' then signal Exit_Program  /* quit if requested */
    end
  return
 
EyeLine: return eyecatch.?msgnum '|-----' left(pgmfn release' ',45,'-')'|'
 
/*------------------------------------------------------------------*/
/* WriteLog:  Write a log record, either directly to the log file   */
/*            (if it's open) or to an array (if file not yet open)  */
/*------------------------------------------------------------------*/
WriteLog:
  if ?WriteToLog then if ?LogIsOpen
    then if logstream = ''             /* write log record where?   */
      then call WrtLine logfile, arg(1)  /*  to disk                */
      else do                            /*  to pipeline stream     */
        'select output' logstream
        'output' arg(1)
        'select output 0'
        outcount.logfile=outcount.logfile + 1
        end
    else do; wli=logrecs.0 + 1; logrecs.wli=arg(1); logrecs.0=wli; end
  return
 
/*----- call SyntaxErr stmt,<msglevel> -----*/
SyntaxErr: parse arg se1,se2
  if se2 = '' then se2 = !error
  call MsgOut se2 456, ,
      'Syntax error detected in the following:',se1,!recnum
  return
 
/*------------------------------------------------------------------*/
/* RevTag/ERevTag: Get revision start/end tags and font start/end   */
/*                 tags and either write to output file or return   */
/*                 caller as a string                               */
/* Usage: e.g. call RevTag  or  string=RevTag(!s)                   */
/*------------------------------------------------------------------*/
RevTag:
  revstr = ''
  /*----- first do any font definitions -----*/
  if fontnest > 0 then do
    ?revstr = ( arg(1) \= '' )
    do rti = 1 to fontnest
      if ?fontprop.rti
        then if ?revstr
          then revstr = revstr || SymbSub(font.rti)
          else call ProcTag SymbSub(font.rti)
      end
    end
  /*----- now do any revision definitions -----*/
  if revnest > 0 then do; spi = 'b2hrevchar'
    ?revstr = ( arg(1) \= '' )
    do rti = 1 to revnest
      if \?revprop.rti then iterate rti
      sym.!amp.spi=revchar.rti; rtj=revid.rti
      if ?revstr
        then revstr = revstr || SymbSub(rev.rtj)
        else call ProcTag SymbSub(rev.rtj)
      end
    end
  return revstr
 
ERevTag:
  erevstr = ''
  /*----- first undo any revision definitions -----*/
  if revnest > 0 then do; spi = 'b2hrevchar'
    ?erevstr = ( arg(1) \= '' )
    do rti = revnest to 1 by -1
      if \?revprop.rti then iterate rti
      sym.!amp.spi=revchar.rti; rtj=revid.rti
      if ?erevstr
        then erevstr = erevstr || SymbSub(erev.rtj)
        else call ProcTag SymbSub(erev.rtj)
      end
    sym.!amp.spi=revchar.revnest
    end
  /*----- now undo any font definitions -----*/
  if fontnest > 0 then do
    ?revstr = ( arg(1) \= '' )
    do rti = 1 to fontnest
      if ?fontprop.rti
        then if ?revstr
          then erevstr = erevstr || SymbSub(efont.rti)
          else call ProcTag SymbSub(efont.rti)
      end
    end
  return erevstr
 
 
/*------------------------------------------------------------------*/
/* OutFileName: Create a fully-qualified file name                  */
/* Usage: file=OutFileName(current,path,fn1,fn2,ext,mem,sys,logphy) */
/*    current - Current name to use as model (if any)               */
/*    path    - Use as "path" if provided, else use "current"'s     */
/*    fn1     - Use as "fn1"  if provided, else use "current"'s     */
/*    fn2     - Use as "fn2"  if provided, else use "current"'s     */
/*    ext     - Use as "ext"  if provided, else use "current"'s     */
/*    mem     - Use as "mem"  if provided, else use "current"'s     */
/*    sys     - destination system                                  */
/*    logphy  - Logical or Physical name                            */
/*------------------------------------------------------------------*/
OutFileName: rtn='OUTFILENAME'; trace value tracelist.rtn
  parse arg ofcurrent, ofpath, offn1, offn2, ofext, ofmem, ofsys, oflogphy
  if ?trcpgm then call Here1 rtn,ofcurrent','ofpath','offn1','offn2','||,
             ofext','ofmem','ofsys','oflogphy,sigl,!pgm
  call FileParts ofcurrent, ofsys
  if ofpath == '' then ofpath = fp.!path
  if offn1  == '' then offn1  = fp.!fn1
  if offn2  == '' then offn2  = fp.!fn2
  if ofext  == '' then ofext  = fp.!ext
  if ofmem  == '' then ofmem  = fp.!mem
  select                                                 /* !OPSYS! */
    when ofsys=AIX | ofsys=LINUX | ofsys=UNIX
      then ofrslt=ofpath||offn1||offn2'.'ofext
    when ofsys=CMS   then if oflogphy = !physical
      then ofrslt = offn2 ofext word(fp.!fm outputfm,1)
      else ofrslt = offn2'.'ofext
    when ofsys=HPFS  then ofrslt=ofpath||offn1||offn2'.'ofext
    when ofsys=MVS   then do
      ofrslt=ofpath||offn1||offn2'.'ofext
      if ofmem\='' then ofrslt=ofrslt'('ofmem')'
      end
    when ofsys=OS2   then ofrslt=ofpath||offn1||offn2'.'ofext
    when ofsys=WIN95 then ofrslt=ofpath||offn1||offn2'.'ofext
    when ofsys=WINNT then ofrslt=ofpath||offn1||offn2'.'ofext
    otherwise ofrslt=ofcurrent
    end
  ofrslt = FileCase(ofrslt,oflogphy)
  if ?trcpgm then call Here2 ofrslt
  return ofrslt
 
/*------------------------------------------------------------------*/
/* FileCase:  Translate the passed file (if appropriate)            */
/* Usage:     str = FileCase(file,{!physical|!logical|0|1|2})       */
/*------------------------------------------------------------------*/
FileCase: rtn='FILECASE'; trace value tracelist.rtn
  parse arg fc1, fc2
  if ?trcpgm then call Here1 rtn,fc1','fc2,sigl,!pgm
  select
    when fc2=''        then fccase=outputl_case
    when fc2=!physical then fccase=outputp_case
    when fc2=!logical  then fccase=outputl_case
    otherwise               fccase=fc2 /* 0=ASIS, 1=LC, 2=UC        */
    end
  select
    when fccase=1 then fcrslt=translate(arg(1),alphalc,alphauc)
    when fccase=2 then fcrslt=translate(arg(1))
    otherwise          fcrslt=arg(1)
    end
  if ?trcpgm then call Here2 fcrslt
  return fcrslt
 
/*------------------------------------------------------------------*/
/* SubDir: Determine a file's sub-directory (path)                  */
/* Usage:  path = SubDir(sourcefile,systype,partdir)                */
/*------------------------------------------------------------------*/
SubDir: rtn='SUBDIR'; trace value tracelist.rtn
  parse arg sdsource, sdtype . , sdpdir
  if ?trcpgm then call Here1 rtn,sdsource','sdtype','sdpdir,sigl,!pgm
  select                               /* use source dir (if there) */
    when pos('/',sdsource)>0 then sdoutdir=left(sdsource,lastpos('/',sdsource))
    when pos('\',sdsource)>0 then sdoutdir=left(sdsource,lastpos('\',sdsource))
    otherwise sdoutdir=''
    end
  if sdoutdir = '' then do             /* check PARTDIR if none yet */
    sdoutdir = strip(sdpdir)
    select
      when pos('/',sdoutdir) > 0
        then if right(sdoutdir,1)\='/' then sdoutdir=sdoutdir'/'
      when pos('\',sdoutdir) > 0
        then if right(sdoutdir,1)\='\' then sdoutdir=sdoutdir'\'
      otherwise if sdoutdir\='' then if right(sdoutdir,1)\=dirchar.sdtype
        then sdoutdir = sdoutdir || dirchar.sdtype
      end
    end
  if ?trcpgm then call Here2 sdoutdir
  return sdoutdir
 
/*------------------------------------------------------------------*/
/* OpenFile:  Open the referenced file(s)                           */
/* Usage:     call OpenFile file,{READ|WRITE},<allocn>,<alloce>,    */
/*                          <f2,rw2,ae2,an2,f3,rw3......>           */
/*   file   - fully-qualified file name                             */
/*   READ/WRITE - Intended operation for the file                   */
/*   allocn - MVS "ALLOC" parms for an output file if it's new      */
/*   alloce - MVS "ALLOC" parms for an output file if it exists     */
/*   (multiple files can be opened with one invocation)             */
/*------------------------------------------------------------------*/
OpenFile: rtn='OPENFILE'; trace value tracelist.rtn
if ?trcpgm then parse value sigl with ofsigl ofrslt
do ofi = 1 by 4 while arg(ofi) \= ''
  offid=arg(ofi); oftype=arg(ofi+1)
  select                                                 /* !OPSYS! */
    when ?pc then call stream offid,'C','OPEN' oftype
    when currsys = CMS then result = '0'
    when currsys = MVS then do
      ofallocn=arg(ofi+2); ofalloce=arg(ofi+3)
      if DDname.offid = ''             /* create DDNAME if none     */
        then do;_DDcnt=_DDcnt+1;DDname.offid='B2H'right(_DDcnt,5,'0');end
      ?DDmode.offid = ( oftype \= !read ) /* 0=read, 1=write        */
      if oftype = !read
        then do                        /* allocate an input file    */
          if ?DDprealloc.offid         /* pre-allocated?            */
            then rc=0
            else rc=Do_TSO("ALLOC FI("DDname.offid") DA('"offid"') SHR REUSE")
          if rc=0 then rc=Do_TSO("EXECIO 0 DISKR" DDname.offid "( OPEN")
          end
        else do                        /* allocate an output file   */
          ofrc = Do_ListDSI("'"offid"'")
          if ofrc = 0                  /* file already exist?       */
            then if ofalloce=''        /*   yes, ALLOC parms given? */
              then tempopts='OLD'; else tempopts=ofalloce
            else do
              if ofallocn = ''
                then if Do_ListDSI("'"input_file"'") = 0
                  then tempopts="LIKE('"input_file"')"; else tempopts=""
                else tempopts = ofallocn
              tempopts = tempopts "NEW CATALOG"
              end
          alloccmd = "ALLOC FI("DDname.offid") DA('"offid"') REUSE" tempopts
          rc = Do_TSO(alloccmd)
          if rc = 0
            then rc = Do_TSO("EXECIO 0 DISKW" DDname.offid "( OPEN")
            else call MsgOut !term 318, "RC="rc,
                      "allocating DD="DDname.offid, 'Command="'alloccmd'"'
          end
      result = rc
      end
    otherwise result = ''
    end
  if oftype=!read then incount.offid=0; else outcount.offid=0
  if ?trcpgm then do
    if ofi > 1 then ofrslt = ofrslt','
    ofrslt = ofrslt || offid','arg(ofi+1)'{'result'}'
    end
  end
if ?trcpgm then do; call Here1 rtn,ofrslt,ofsigl,!pgm; call Here2; end
return
 
/*------------------------------------------------------------------*/
/* CloseFile: Close the referenced file(s)                          */
/* Usage:     call CloseFile file <, file2, file3, ... filex >      */
/*------------------------------------------------------------------*/
CloseFile: rtn='CLOSEFILE'; trace value tracelist.rtn
  if ?trcpgm then parse value sigl with cfsigl cfrslt
  do cfi = 1 by 1
    cffid=arg(cfi); if cffid='' then leave cfi
    select                                               /* !OPSYS! */
      when ?pc then call stream cffid,'C','CLOSE'
      when currsys = CMS then do;address COMMAND 'FINIS' cffid;result=rc;end
      when currsys = MVS & DDname.cffid \= '' then do
        rc = Do_TSO("EXECIO 0" word('DISKR DISKW',(?DDmode.cffid)+1),
                    DDname.cffid "( FINIS")
        result = rc
        if \?DDprealloc.cffid then do  /* free if not pre-allocated */
          call Do_TSO "FREE FI("DDname.cffid")"; DDname.cffid=''
          end
        end
      otherwise result=''
      end
    if ?trcpgm then if cfi = 1
      then cfrslt = cfrslt|| cffid'{'result'}'
      else cfrslt = cfrslt','cffid'{'result'}'
    end
  if ?trcpgm then do; call Here1 rtn,cfrslt,cfsigl,!pgm; call Here2; end
  return
 
/*------------------------------------------------------------------*/
/* WrtLine: Write a line to an output file and count it             */
/* Usage:   call WrtLine file, record-to-write<,record2,  ,recordx> */
/*------------------------------------------------------------------*/
WrtLine: rtn='WRTLINE'; trace value tracelist.rtn
  parse arg wrtfile; wrtsigl=sigl
  do wrti = 2 to arg(); wrtrec=arg(wrti); if wrtrec=='' then iterate wrti
    wlrec.0=1; wlrec.1=wrtrec       /* assume writing only this rec */
    /*----- do final processing if writing to HTML output -----*/
    if wrtfile = outputp_file then do
      wrtss=1;do forever while wrtss>0; wrtss=pos('<PRE>',wrtrec,wrtss)
        if wrtss>0 then do;_PREcount=_PREcount+1;wrtss=wrtss+1;end
        end
      wrtss=1;do forever while wrtss>0; wrtss=pos('</PRE>',wrtrec,wrtss)
        if wrtss>0 then do;_PREcount=max(0,_PREcount-1);wrtss=wrtss+1;end
        end
      if _PREcount = 0                 /* within <PRE> & </PRE>?    */
        then do                        /*   no, split the record?   */
          if maxwidth>0 & length(wrtrec)>maxwidth   /* yes          */
            then do wrtj = 1 by 1 until wrtrec==''
              part1 = left(wrtrec,maxwidth)
              part2 = substr(wrtrec,maxwidth+1)
              if right(part1,1)\=' ' & left(part2,1)\=' ' then do
                wrtk = lastpos(' ',part1)
                if wrtk > 0 then do
                  part2=substr(part1,wrtk+1)||part2; part1=left(part1,wrtk)
                  end
                end
              wlrec.wrtj=part1; wlrec.0=wrtj; wrtrec=strip(part2,'L')
              end wrtj
          end
        else do                        /*  yes, within in a PRE     */
          if pos(tab,wlrec.1) > 0      /*  if any tabs, handle them */
            then wlrec.1 = TabDataRec(wlrec.1,tab)
          end
      end
    /*----- write the record(s) to the output file -----*/
    do wrtj = 1 to wlrec.0
      wrtrec=wlrec.wrtj; outcount.wrtfile=outcount.wrtfile + 1
      if ?xlateo then wrtrec = XlateOutput(wrtrec)
      select                                             /* !OPSYS! */
        when ?pc then do; call lineout wrtfile, wrtrec; rc=result; end
        when ?pipe & wrtfile=outputp_file then 'output' wrtrec
        when currsys = CMS then do
          address COMMAND 'EXECIO 1 DISKW' wrtfile '( VAR WRTREC'
          if rc \= 0 then call MsgOut !term 317, "RC="rc,
            "writing to '"wrtfile"'", "Record='"wrtrec"'"
          end
        when currsys = MVS then do
          wrtrec.0=1; wrtrec.1=wrtrec
/* LBD: make sure length does not exceed 1024 as that is the limit of smtp */
/* LBD */ if length(wrtrec.1) > 1024 then do
/* LBD */    wrtrec.0 = 2
/* LBD */    p1 = pos('&',wrtrec.1,1000)
/* LBD */    wrtrec.2 = substr(wrtrec.1,p1)
/* LBD */    wrtrec.1 = left(wrtrec.1,p1=1)
/* LBD */    end
/* LBD */ address TSO "EXECIO * DISKW" DDname.wrtfile "( STEM WRTREC."
/* LBD */ xrc = rc
/* LBD */ if xrc  = 1 then wrtk=' output record truncated while'; else wrtk=''
/* LBD */ if xrc \= 0 then call MsgOut !term 317, "RC="rc||wrtk,
            "writing to DD="DDname.wrtfile "DSN='"wrtfile"'",
                     "Record='"wrtrec"'"
/* LBD */ drop wrtrec.
          end
        otherwise rc = ''
        end
      if ?trcio then if wrtfile\=tracefile & wrtfile\=logfile
        then call TraceMsg '->'wrtfile'{'rc'},',
                  outcount.wrtfile'="'wrtrec'"',wrtsigl,!io
      end wrtj
    end wrti
  return
 
/*------------------------------------------------------------------*/
/* RdLine: Read a line from a file and count it                     */
/* Usage:  parse value RdLine(file,<prof>,<noshow>),                */
/*               with  1 eof 2 record                               */
/*         prof - If anything specified, records are read in        */
/*                'profile' mode: blank and records with "*" in     */
/*                column one ignored, platform checking done and    */
/*                input character translation NOT done.             */
/*       noshow - If anything specified, no 'x of y' msgs shown     */
/*          eof - End-of-file reached? 1/true=yes, 0/false=no       */
/*                If true, no record is returned                    */
/*------------------------------------------------------------------*/
RdLine: rtn='RDLINE'; trace value tracelist.rtn
  parse arg rdfile, rdprofmode, rdnoshow, rdshow
  if ?trcio then call Here1 rtn,arg(1)','arg(2)','arg(3)','arg(4),sigl,!io
  rdfile=strip(rdfile); ?rdeof=false; rdrec=''
  if rdshow='NO' then rdshow=noshowlines; else rdshow=showlines
  do rdloop = 1 by 1
    select                                               /* !OPSYS! */
      when ?pc
        then if lines(rdfile) = 0
          then parse value true with ?rdeof rdrec
          else rdrec = linein(rdfile)
      when ?pipe & rdfile=input_file then do
        'readto rdrec'
        if rc \= 0 then parse value true with ?rdeof rdrec
        end
      when currsys = CMS then do
        address COMMAND 'EXECIO 1 DISKR' rdfile '( VAR RDREC'
        if rc \= 0 then parse value true with ?rdeof rdrec
        end
      when currsys = MVS then do
        address MVS "EXECIO 1 DISKR" DDname.rdfile "( STEM RDREC."
        if rc = 0
          then rdrec = rdrec.1
          else parse value true with ?rdeof rdrec
        end
      otherwise nop
      end
    if ?rdeof then signal End_RdLine
 
    /*----- count record and show status -----*/
    incount.rdfile = incount.rdfile + 1
    source_id.infilecnt = incount.rdfile rdfile
    if rdnoshow = ''
      then if (incount.rdfile // rdshow) == 0
        then call MsgOut !info 310,copies('..',max(0,infilecnt-1)) ||,
                  'Reading line' incount.rdfile 'from' rdfile '...'
    if ?trcio then call TraceMsg '<-'rdfile',' incount.rdfile'="'rdrec'"',,!io
 
    /*----- if requested, process in 'profile' mode ----- */
    if rdprofmode\='' then do
      if left(rdrec,1) = '*' then iterate rdloop /* ignore comments */
      if rdrec = '' then iterate rdloop     /* ignore blank lines   */
      /*----- see if record is for the designated platform -----*/
      if left(rdrec,1) = '(' then do
        parse var rdrec 2 rdenv ')' rdrec
        if \UseOnPlatform(rdenv) then iterate rdloop
        end
      end
    leave rdloop
    end rdloop
 
End_RdLine:
  if rdprofmode = '' then do           /* if not in profile mode    */
    if ?xlatei then rdrec=XlateInput(rdrec)  /* do any input xlates */
    if pass=1 then select         /* do LINENUM work (pass 1 only)  */
      when linenum = 0 then nop
      when linenum = 1
        then if datatype(word(rdrec,1),'W') then rdrec= delword(rdrec,1,1)
      when linenum = 2 then do; rd1=words(rdrec)
        if rd1>0 then if datatype(word(rdrec,rd1),'W')
          then rdrec=subword(rdrec,1,rd1-1)
        end
      when linenum = 3 then do; rd1=substr(rdrec,linenums,linenuml)
        if datatype(rd1,'W') then rdrec=delstr(rdrec,linenums,linenuml)
        end
      otherwise nop
      end
    end
  if ?trcio then call Here2 ?rdeof || rdrec
  return ?rdeof || rdrec
 
/*------------------------------------------------------------------*/
/* XlateInput:  Translate an input  record with .TI and :XLATEI.    */
/* Usage:       record = XlateInput(record)                         */
/* XlateOutput: Translate an output record with .TR and :XLATEO.    */
/* Usage:       record = XlateOutput(record)                        */
/*------------------------------------------------------------------*/
XlateInput:
  parse arg xlirec
  if xlateto.!in \= ''
    then xlirec = translate(xlirec,xlateto.!in,xlatefrom.!in)
  do xli = 1 to xlatecs.!in.0
    parse var xlatecs.!in.xli xlc xls
    xlirec = Xlate(xlirec,xlc,xls)
    end
  if dottis \= '' then xlirec = translate(xlirec,dottit,dottis)
  return xlirec
Set_XlateI:
  ?xlatei = (xlatecs.!in.0>0) | (xlatefrom.!in\='') | (dottis\='')
  return
XlateOutput:
  parse arg xlorec
  if dottrs \= '' then xlirec = translate(xlirec,dottrt,dottrs)
  if xlateto.!out \= ''
    then xlorec = translate(xlorec,xlateto.!out,xlatefrom.!out)
  do xlo = 1 to xlatecs.!out.0
    parse var xlatecs.!out.xlo xlc xls
    xlorec = Xlate(xlorec,xlc,xls)
    end
  return xlorec
Set_XlateO:
  ?xlateo = (xlatecs.!out.0>0) | (xlatefrom.!out\='') | (dottrs\='')
  return
 
/*------------------------------------------------------------------*/
/* UseOnPlatform:  See if OK on this platform or environment        */
/* Usage:  x = UseOnPlatform(string)      e.g. '(AIX)'              */
/* Returns:  1=OK to use; 0=do not use                              */
/*------------------------------------------------------------------*/
UseOnPlatform:
  parse upper arg upenv
  ?upok = true
  do while upenv\='' & ?upok
    parse var upenv atom upenv; up1=left(atom,5)
    select
      when up1='CURR=' then do;atom=substr(atom,6);up2=0;upsys=currsys;end
      when up1='DEST=' then do;atom=substr(atom,6);up2=1;upsys=destsys;end
      when up1='HTML=' then do;atom=substr(atom,6);up2=2;end
      otherwise             do;                    up2=0;upsys=currsys;end
      end
    select                                           /* !OPSYS! */
      when up2=2 & wordpos(atom,htmlenvs)>0 then nop
      when atom=platform.upsys  then nop
      when atom='PC' then select
        when up2=0 & ?pc then nop
        when up2=1 & wordpos(destsys,AIX HPFS LINUX OS2 WIN95 WINNT UNIX)>0
             then nop
        otherwise ?upok=false
        end
      otherwise ?upok=false
      end
    end
  return ?upok
 
/*------------------------------------------------------------------*/
/* CloseAnsFile: close the physical Q&A answer file                 */
/*------------------------------------------------------------------*/
CloseAnsFile:
  if ansfilep \= '' then do
    if outcount.ansfilep > 0
      then call RecordsWritten outcount.ansfilep, 'Q&A answer file "'ansfilep'"'
    call CloseFile ansfilep
    end
  return
 
/*------------------------------------------------------------------*/
/* HeaderRecords: Write any header records to HTML output file      */
/* Usage:         call HeaderRecords                                */
/*------------------------------------------------------------------*/
HeaderRecords: rtn='HEADERRECORDS'; trace value tracelist.rtn
  if ?trcany then call Here1 rtn,arg(1),sigl,!io
  if titleopt \= ''
    then hdrtitle = SymbSub(titleopt)
    else do
      select
        when title_save   \== '' then hdrtitle=strip(SymbSub(title_save))
        when topic_save   \== '' then hdrtitle=strip(SymbSub(topic_save))
        when library_save \== '' then hdrtitle=strip(SymbSub(library_save))
        when firsthead    \== '' then hdrtitle=strip(SymbSub(firsthead))
        otherwise hdrtitle = ''
        end
      if stitle \= ''
        then if length(hdrtitle)>max_titlelen | hdrtitle=''
          then hdrtitle = strip(SymbSub(stitle))
      end
  /*----- create initial header records -----*/
  call WrtLine outputp_file,,
       SymbSub(deftext.!htmlhead),'<HTML><HEAD>','<TITLE>'hdrtitle'</TITLE>'
  call MC 'Begin Header Records'
  if commenthead \= '' then call MC SymbSub(commenthead),' '
  do i=1 to saverec.!htmlcmt.0; call MC SymbSub(saverec.!htmlcmt.i),' '; end
 
  /*----- include meta records -----*/
  if ?wantmeta then do
    if abstract\=='' then call Meta 'abstract',abstract
    if security\=='' then call Meta 'security',security
    if contact \=='' then call Meta 'contact', contact
    if owner   \=='' then call Meta 'owner',   owner
    if charset \=='' then call Meta 'Content-Type', 'text/html; charset='charset
    /*----- calc appropriate dates -----*/
    parse value input_date with yyyy '-' mm '-' dd .
    if mm=2 & dd=29 then xdd=28; else xdd=dd
    select                             /* revision/update date      */
      when revdate = '' then do; delta=0; revdate=yyyy+1||mm||xdd; end
      when pos(left(revdate,1),'+-')>0 & datatype(substr(revdate,2),'W')
        then do; delta=revdate; revdate=today_yyyymmdd; end
      otherwise delta = 0
      end
    if length(revdate)=8 & datatype(revdate,'W')
      then revdate=RFCDate(revdate,delta) input_time
    select                             /* expiration date           */
      when expdate='' then do; delta=0; expdate=yyyy+2||mm||xdd; end
      when pos(left(expdate,1),'+-')>0 & datatype(substr(expdate,2),'W')
        then do; delta=expdate; expdate=today_yyyymmdd; end
      otherwise delta = 0
      end
    if length(expdate)=8 & datatype(expdate,'W')
      then expdate = RFCDate(expdate,delta) input_time
    call Meta 'updated',RFCDate(yyyy||mm||dd) input_time
    call Meta 'review', revdate
    call Meta 'expires',expdate
    if metakeys \== '' then call Meta 'keywords', metakeys
    end
  /*----- include any records for the HTML header section -----*/
  do i = 1 to saverec.!headrec.0
    parse value saverec.!headrec.i with headrec1 headrec2
    select
      when headrec1 = 'T'
        then call WrtLine outputp_file, headrec2
      when headrec1 = 'F'
        then call Copy2Output headrec2,'HeadRec file',,outputp_file
      otherwise nop
      end
    end
  call WrtLine outputp_file, '</HEAD>'bodytag
  if mastimg \= ''
    then if currpartnum=1 | ( ?mastimg & currpartnum>1 )
      then call WrtLine outputp_file, ,
                HtmlX(!img,'SRC="'imgpath||mastimg'" ALT="'mastalt'"')'<BR>'
  /*----- define splitlink variable content -----*/
  select
    when totalpartnum = 1 then i = ''  /* only output file          */
    when currpartnum = 1            then i = SymbSub(splitlink.plink1)
    when currpartnum < totalpartnum then i = SymbSub(splitlink.plink3)
    when currpartnum = totalpartnum then i = SymbSub(splitlink.plink5)
    otherwise i = ''
    end
  call DefSymbol 'b2hparttop',i
  /*----- include any user header records -----*/
  do i = 1 to saverec.!header.0
    call Copy2Output saverec.!header.i,'Header file',,
                     !profmode,outputp_file,,,!yes
    end
  call MC 'End Header Records'
 
  call WrtLine outputp_file, HtmlX(!a,'NAME="'TOPname'"')||anchortext'</A>'
  if docstyle == '' then docstyle = defstyle
  if deftext.docstyle \== '' then call WrtLine outputp_file,deftext.docstyle
  if hdrtitle\='' & tophead\=0 then do
    temp1 = 'H'tophead
    call WrtLine outputp_file,HtmlX(temp1)||hdrtitle'</'temp1'>'
    end
  /*----- write prev/next header linkage if files were split -----*/
  if ?splitlink then call WrtLine outputp_file, SymbSub('&b2hparttop')
  if ?trcany then call Here2
  return
 
/*----- write a META record -----*/
Meta:
  call WrtLine outputp_file,'<META HTTP-EQUIV="'arg(1)'" CONTENT="'arg(2)'">'
  return
 
/*----- write META comment -----*/
MC:
  parse arg mc1, mc2; if mc2=='' then mc2='='
  mctemp = ''
  do while mc1\=''; parse var mc1 atom mc1
    if mctemp='' & length(atom)>cmtlen
      then do; mc1=substr(atom,cmtlen+1) mc1; atom=left(atom,cmtlen); end
    if length(mctemp) + length(atom) > cmtlen then do
      call WrtLine outputp_file,,
           deftext.htmlcmtl || left(mctemp' ',cmtlen,mc2) || deftext.htmlcmtr
      mctemp = ''
      end
    mctemp = mctemp || atom' '
    end
  if mctemp \= ''
    then call WrtLine outputp_file,,
              deftext.htmlcmtl || left(mctemp' ',cmtlen,mc2) || deftext.htmlcmtr
  return
 
/*----- set SPLITLINK. subscripts based on INDEX value -----*/
Set_SplitLink: plink1 = ( 10 * ?index ) + 1
  plink2=plink1+1; plink3=plink1+2; plink4=plink1+3
  plink5=plink1+4; plink6=plink1+5
  return
 
 
/*------------------------------------------------------------------*/
/* FooterRecords:  Write any footer records to HTML output file     */
/* Usage:          call FooterRecords                               */
/*------------------------------------------------------------------*/
FooterRecords: rtn='FOOTERRECORDS'; trace value tracelist.rtn
  if ?trcany then call Here1 rtn,arg(1),sigl,!pgm
  /*----- define splitlink variable content -----*/
  select
    when totalpartnum = 1 then i = ''  /* only output file          */
    when currpartnum = 1            then i = SymbSub(splitlink.plink2)
    when currpartnum < totalpartnum then i = SymbSub(splitlink.plink4)
    when currpartnum = totalpartnum then i = SymbSub(splitlink.plink6)
    otherwise i = ''
    end
  call DefSymbol 'b2hpartbot',i
  /*----- write prev/next header linkage if files were split -----*/
  if ?splitlink then call WrtLine outputp_file, SymbSub('&b2hpartbot')
  if saverec.!footer.0 > 0 then do
    call MC 'Begin Footer Records'
    do i = 1 to saverec.!footer.0
      call Copy2Output saverec.!footer.i,'Footer file',!profmode,,
                       outputp_file,,,!yes
      end
    call MC 'End Footer Records'
    end
  call WrtLine outputp_file,HtmlX(!a,'NAME="'BOTname'"')||anchortext'</A>',,
                            '</BODY></HTML>'
  call CloseFile outputp_file
  call RecordsWritten outcount.outputp_file, outputp_file '('outputl_file')'
  if ?trcany then call Here2
  return
 
/*------------------------------------------------------------------*/
/* Copy2Output:  Copy specified file to HTML output file            */
/* Usage: call Copy2Output in,desc,mode,out,pre,blnk,sub,fc         */
/*    in   - Input file                                             */
/*    desc - Description of the input file                          */
/*    mode - Mode of input file to be passed to "RdLine" routine    */
/*    out  - Output file                                            */
/*    pre  - Specifies if <PRE></PRE> are to enclose records        */
/*            -1  -  Just copy input to output  (default)           */
/*             0  -  Enclose all records in one big "PRE" group     */
/*            >0  -  If this many columns at the start of the       */
/*                   input record are blank, the record is          */
/*                   enclosed in <PRE></PRE>                        */
/*    blnk - If an input record is completely blank, replace it     */
/*           with the value specified here (defaults to null)       */
/*    sub  - Should &variables in records be substituted?           */
/*           YES or NO.  NO is the default                          */
/*    fc   - Copying a "flat" file to the output? YES or NO(default)*/
/*------------------------------------------------------------------*/
Copy2Output: rtn='COPY2OUTPUT'; trace value tracelist.rtn
  parse arg co2in, co2desc, co2mode, co2out, co2pre, co2blnk, co2sub, co2fc
  if ?trcany then call Here1 rtn,,
      arg(1)','arg(2)','arg(3)','arg(4)','arg(5)','arg(6)','arg(7)','arg(8),,
      sigl,!pgm
  if \datatype(co2pre,'W') then co2pre = -1
  ?co2blnk=(co2blnk\=''); ?co2pre=(co2pre>0); ?co2sub=(co2sub=!yes)
  ?co2fc=(co2fc=!yes); ?co2pipe=(?pipe & co2in=input_file)
  if ?co2pipe then qrc=0; else qrc=FindFile(co2in)
  if qrc \= 0
    then call FileNotFound !warning, co2desc, co2in
    else do
      if co2desc\='' then
         call MsgOut !info 312,'Adding lines from' co2desc co2in
      call OpenFile co2in,!read
      if co2pre=0
        then do; call WrtLine co2out,'<PRE>'; ?co2inpre=true; end
        else ?co2inpre = false
      do forever
        parse value RdLine(co2in,co2mode) with 1 ?co2eof 2 currline
        source_id_orig.infilecnt = source_id.infilecnt
        if ?co2eof then leave
        if ?co2sub then currline = SymbSub(currline)
        if ?co2blnk then if \?co2inpre
          then if currline = '' then currline = co2blnk
        if ?co2pre then if left(currline,co2pre) = ''
          then do
            if \?co2inpre then call WrtLine co2out, '<PRE>'
            ?co2inpre = true
            end
          else do
            if ?co2inpre  then call WrtLine co2out, '</PRE>'
            ?co2inpre = false
            end
        /*----- do "flat" file copy processing -----*/
        if ?co2fc then do
          if ?ltgt then do
            currline = XLate(currline,'<','&lt;')
            currline = XLate(currline,'>','&gt;')
            end
          if pos(left(currline,1),'.:') = 0 /*all non-script lines  */
            then if titleopt = ''           /* save 1st non-blank   */
              then if currline \= ''        /*    line if title not */
                then titleopt = strip(currline) /* yet stored       */
          end
        /*----- write out finished record -----*/
        call WrtLine co2out, currline' '
        end
      if ?co2inpre then call WrtLine co2out, '</PRE>'
      if \?co2pipe then call CloseFile co2in
      end
  if ?trcany then call Here2
  return
 
/*------------------------------------------------------------------*/
/* Derive a file for new output part                                */
/* Usage: fid = BHSplit(seq#,<actual>,modelfid,<dsorg>,logphy)      */
/*------------------------------------------------------------------*/
BHSplit: rtn='BHSPLIT'; trace value tracelist.rtn
  parse arg bhnum, bhactfid, bhmodfid, bhorg, bhlogphy
  if ?trcpgm
    then call Here1 rtn,arg(1)','arg(2)','arg(3)','arg(4)','arg(5),sigl,!pgm
  if bhlogphy = !physical
    then do
      ?bhoutput83=?outputp83; bhext=htmpext; tempsys=currsys
      if bhactfid=''  then bhactfid = partnamep.bhnum
      bhdir = SubDir(bhmodfid,currsys,partdirp.bhnum)
      end
    else do
      ?bhoutput83=?outputl83; bhext=htmlext
      if destsys=CMS  then tempsys=OS2; else tempsys=destsys
      if bhactfid=''  then bhactfid = partnamel.bhnum
      bhdir = SubDir(bhmodfid,tempsys,partdirl.bhnum)
      end
  /*----- if output name specified used it -----*/
  if bhactfid\='' then do
    if pos('/',bhactfid)=0 & pos('\',bhactfid)=0
      then bhactfid=bhdir||bhactfid
    bhrslt = OutFileName(bhactfid,,,,bhext,,tempsys,bhlogphy)
    signal Exit_BHSplit
    end
  /*----- build counter suffix -----*/
  select
    when pdtype=1 then bhnum = d2x(bhnum)           /* HEX          */
    when pdtype=2 | pdtype=3 then do; bhpout=''     /* ALPHA/LALPHA */
      if pdtype=2 then temp1=base36uc; else temp1=base36lc
      do bhpnd = 1 by 1 until 36**bhpnd > bhnum; end
      do bhpi = bhpnd to 2 by -1; bhpj=36**(bhpi-1)
        bhpdigit = bhnum % bhpj
        bhpout = bhpout || substr(temp1,bhpdigit+1,1)
        bhnum = bhnum // bhpj
        end
      bhnum = bhpout || substr(temp1,bhnum+1,1)
      end
    otherwise nop                                   /* DECimal      */
    end
  if length(bhnum) > pdnum then do
    pdnumsav=pdnum; pdnum=length(bhnum)
    call MsgOut !warning 118, 'SPLITDIGITS='pdnumsav 'too small,',
                'dynamically increasing to SPLITDIGITS='pdnum
    end
  partsuffix = right(bhnum,pdnum,'0')
  /*----- build output file specification -----*/
  call FileParts bhmodfid, tempsys
  if bhorg='' then if fp.!mem\='' then bhorg='PO'; else bhorg='PS'
  select
    when bhorg = 'PO' then do
      if fp.!mem = '' then fp.!mem = fp.!fn2
      bhrslt = OutFileName(bhdir,,fp.!fn1,fp.!fn2,fp.!ft,,
                           strip(left(fp.!mem,8-pdnum))||partsuffix,,
                           tempsys,bhlogphy)
      end
    otherwise do
      if ?bhoutput83 | tempsys=CMS                       /* !OPSYS! */
        then bhfn = strip(left(fp.!fn2,8-pdnum))
        else bhfn = fp.!fn2
      bhrslt = OutFileName(bhdir,,fp.!fn1,bhfn||partsuffix,bhext,,
                           '',tempsys,bhlogphy)
      end
    end
Exit_BHSplit:
  bhrslt = FileCase(bhrslt,bhlogphy)
  if ?trcpgm then call Here2 bhrslt
  return bhrslt
 
/*------------------------------------------------------------------*/
/* PrintFootNotes: Print out footnotes if any were found            */
/* Usage: call PrintFootNotes {0|1} <, output-file >                */
/*                0 = call 'PROCTAG' routine to save records        */
/*                1 = write records directly to output file         */
/*------------------------------------------------------------------*/
PrintFootNotes: rtn='PRINTFOOTNOTES'; trace value tracelist.rtn
  parse arg ?pfnsw ., pfnout
  if ?trcany then call Here1 rtn,?pfnsw','pfnout,sigl,!pgm
  temp1=SetUpTag('FN',1); temp2=SetUpTag('FN',2)
  do k = 1 to saverec.!fn.0
    if k = 1 then do
      pfntemp = temp1||list.!fn.9'<B>' deftext.!footnotes':</B>'
      if ?pfnsw then call WrtLine pfnout, pfntemp; else call ProcTag pfntemp
      pfntemp = HtmlX(!dl,' COMPACT')
      if ?pfnsw then call WrtLine pfnout, pfntemp; else call ProcTag pfntemp
      end
    if ?pfnsw
      then call WrtLine pfnout, saverec.!fn.k
      else call ProcTag saverec.!fn.k
    if k = saverec.!fn.0 then do
      pfntemp = '</DL>'list.!fn.10||temp2
      if ?pfnsw then call WrtLine pfnout, pfntemp; else call ProcTag pfntemp
      end
    end
  saverec.!fn.0 = 0
  if ?trcany then call Here2
  return
 
/*------------------------------------------------------------------*/
/* ImbedFile:  Process an imbed statement                           */
/* Usage:      call ImbedFile filespec,<origstmt>,<linenum>         */
/*------------------------------------------------------------------*/
ImbedFile: rtn='IMBEDFILE'; trace value tracelist.rtn
  parse arg imbedin
  if ?trcany then call Here1 rtn,imbedin,sigl,!pgm
 
  /*----- determine characteristics of the input file -----*/
  ifi = lastpos(dirchar.currsys,imbedin)
  ifdir=left(imbedin,ifi); iffile=substr(imbedin,ifi+1)
  select                                                 /* !OPSYS! */
    when wordpos(currsys,AIX HPFS LINUX WIN95 WINNT UNIX) > 0 then do
      if ?imbftext
        then imbedin = ImbFtExt(iffile,imbftextcase,defimbft)
        else if pos('.'translate(defimbft)' ',translate(iffile' '))=0
          then imbedin = space(ifdir||word(iffile,1)'.'defimbft,0)
      end
    when currsys = CMS then do
      imbedin=translate(imbedin)
      parse value translate(imbedin,' ','.') with imbfn imbft imbfm
      imbedin = imbfn word(imbft defimbft,1) imbfm
      end
    when currsys = MVS
      then if length(imbedin) <= 8 then imbedin = ImbedMemberDsn(imbedin)
    when currsys = OS2 then do
      if ?imbftext
        then imbedin = ImbFtExt(iffile,imbftextcase,defimbft)
        else do
          parse var iffile imbfn . '.' imbft .
          if imbft = '' then imbft = defimbft
          imbedin = ifdir || imbfn'.'imbft
          end
      end
    otherwise nop
    end
  imbedin = space(imbedin)
 
  /*----- "imbedin" now contains file to process; locate it -----*/
  if ?pipe                             /* am I a pipeline filter?   */
    then qrc = 0                       /*  yes, show file "found"   */
    else do                            /*   no, locate actual file  */
      qrc = FindFile(imbedin)
      if qrc \= 0                      /* if file not found, check  */
       then if ?pc then do             /*  imbed directory if on PC */
         iffile=imbedin; iftemp=imbpath
         do while qrc\=0 & iftemp\=''
           parse var iftemp ifpath ';' iftemp
           if right(ifpath,1) \= dirchar.currsys
             then ifpath=ifpath||dirchar.currsys
           iffid = ifpath || iffile; qrc = FindFile(iffid)
           end
         if qrc = 0 then imbedin = iffid
         end
      end
  /*----- if imbed file found, setup to process it -----*/
  if qrc = 0
    then do
      if \?pipe then call OpenFile imbedin,!read
      infilecnt=infilecnt+1; infile.infilecnt=imbedin
      do while labels.infilecnt \= ''  /* reset labels for this file*/
        parse var labels.infilecnt x labels.infilecnt
        ?labelfnd.infilecnt.x = false
        end
      do ifi = 1 to bypass.imbedin     /* bypass any prev records   */
        parse value RdLine(imbedin) with 1 ?ifj 2 .
        if ?ifj then do                /* reset file if EOF found   */
          call CloseFile imbedin; call OpenFile imbedin,!read
          incount.imbedin=0; bypass.imbedin=0; leave ifi
          end
        end
      GoToLabel.infilecnt=''; GoToLine.infilecnt=''
      call MsgOut !info 303,copies('..',infilecnt-1)"Imbedding '"imbedin"' ..."
      if ?imbedid then do
        ifx = infilecnt - 1
        call Put_Buffer ':BHCMT.Begin' imbedin '(imbedded by' infile.ifx')'
        end
      end
    else call FileNotFound ?prcnoimbed,'Imbedded file',imbedin,arg(2),arg(3)
  if ?trcany then call Here2
  return
 
/*------------------------------------------------------------------*/
/* ImbedMemberDsn: Determine MVS DSN of a member to imbed           */
/* Usage: fulldsn = ImbedMemberDsn(member)                          */
/*------------------------------------------------------------------*/
ImbedMemberDsn: rtn='IMBEDMEMBERDSN'; trace value tracelist.rtn
  parse upper arg immem .; imdsn=''
  if ?trcparse then call Here1 rtn,immem,sigl,!parse
  imdsn = GetDSNbyDD('TEXTLIB',immem,'IN')
  if imdsn = ''
    then if input_dd\='' & input_dsorg='PO'
      then imdsn = GetDSNbyDD(input_dd,immem,'IN')
  if imdsn = ''
    then if Do_ListDSI("'"input_file"'")=0 & input_dsorg='PO' then do
      imtmp=SYSDSNAME'('immem')'
      if Do_SysDsn("'"imtmp"'")="OK" then imdsn=imtmp
      end
  if imdsn = '' then imdsn = arg(1)
  if ?trcparse then call Here2 imdsn
  return imdsn
 
/*------------------------------------------------------------------*/
/* GetDSNbyDD: Return full DSN of passed DDcard and optional member */
/* Usage: fulldsn = GetDSNbyDD(ddname,<mem>,<IN|OUT>,<quitiferr?>)  */
/*------------------------------------------------------------------*/
GetDSNbyDD: rtn='GETDSNBYDD'; trace value tracelist.rtn
  parse upper arg gddd, gdmem ., gdio ., ?gderr; ?gderr=(?gderr='1')
  gddsn=word(DSNs.gddd,1); gddsorg=DSorg.gddsn; gdrslt=''
  parse var gddsn gddsn '(' gdx ')'; if gdmem='' then gdmem=gdx
  select
    when gddsn = '' then if ?gderr
      then call MsgOut !term 314, "DD '"gddd"' not allocated"
    when gdmem='' & gddsorg\='PS' then if ?gderr
      then call MsgOut !term 315, "DD '"gddd"' not DSORG=PS"
    when gdmem\='' & gddsorg\='PO' then if ?gderr
      then call MsgOut !term 315, "DD '"gddd"' not DSORG=PO"
    when gdmem='' & gddsorg='PS' then gdrslt = gddsn
    when gdmem\='' & gddsorg='PO' & gdio='OUT' then gdrslt=gddsn'('gdmem')'
    otherwise if gdio = 'IN' then do
      do gdi = 1 to words(DSNs.gddd) while gdrslt=''
        parse value word(DSNs.gddd,gdi) with gdtemp '('
        gdtemp = gdtemp'('gdmem')'
        if Do_SysDsn("'"gdtemp"'") = "OK" then gdrslt = gdtemp
        end
      if gdrslt = ''
        then if ?gderr then call MsgOut !term 316, ,
          "Member '"gdmem"' not found in dataset(s) allocated to DD '"gddd"'"
      end
    end
  return gdrslt
 
/*------------------------------------------------------------------*/
/* ImbFtExt: Handle extended processing of an imbed's filetype      */
/* Usage:    file = ImbFtExt(file,case,defaultft)                   */
/*------------------------------------------------------------------*/
ImbFtExt: rtn='IMBFTEXT'; trace value tracelist.rtn
  parse arg ifefile, ifecase, ifedefft
  if ?trcparse then call Here1 rtn,ifefile','ifecase','ifedefft,sigl,!parse
  parse value translate(ifefile,' ','.') with ifefn ifeft ifefm
  ifeftu = translate(ifeft)
  select
    when imbftext.ifeftu\='' then ifeft=imbftext.ifeftu
    when ifeft           ='' then ifeft=ifedefft
    otherwise nop
    end
  ifefile = FileCase(ifefn'.'ifeft,ifecase)
  if ?trcparse then call Here2 ifefile
  return ifefile
 
/*------------------------------------------------------------------*/
/* CondExpr: Evaluate a .WHEN conditional-expression                */
/* Usage:    bool = CondExpr(expression)   bool is 0=False/1=True   */
/*------------------------------------------------------------------*/
CondExpr: rtn='CONDEXPR'; trace value tracelist.rtn
  parse upper arg cexstring
  if ?trcparse then call Here1 rtn,cexstring,sigl,!parse
  ?cexprev = true; ?cexand = true; ?cexnot = false
  do forever while cexstring \= ''
    parse var cexstring cexatom cexstring
    select
      when cexatom = 'OR'  then ?cexand = false
      when cexatom = 'NOT' then ?cexnot = true
      otherwise do
        ?cexthis = ( sym.!dvcf.cexatom \= '' )
        if ?cexnot then do; ?cexthis = \?cexthis; ?cexnot=false; end
        if ?cexand
          then     ?cexprev = ?cexprev & ?cexthis
          else do; ?cexprev = ?cexprev | ?cexthis; ?cexand=true; end
        end
      end
    end
  if ?trcparse then call Here2 ?cexprev
  return ?cexprev
 
/*------------------------------------------------------------------*/
/* XLate:  Translate a specified field to another in a string       */
/* Usage:  string = XLate(string,from,to,<ci>)                      */
/*           ci - Anything specified here means case-insensitive    */
/*------------------------------------------------------------------*/
XLate: rtn='XLATE'; trace value tracelist.rtn
  parse arg xlstring, xlfrom, xlto, xlci
  if ?trcparse then call Here1 rtn,xlstring','xlfrom','xlto','xlci,sigl,!parse
  ?xlci=(xlci\==''); xlfrom_len=length(xlfrom); xlstart=1
  if xlfrom \== xlto then do forever
    if ?xlci then xltemp=translate(xlstring); else xltemp=xlstring
    xli=pos(xlfrom,xltemp,xlstart); if xli=0 then leave
    xlstring = left(xlstring,xli-1) || xlto || substr(xlstring,xli+xlfrom_len)
    xlstart = xlstart + xlfrom_len
    end
  if ?trcparse then call Here2 xlstring
  return xlstring
 
 
/*------------------------------------------------------------------*/
/* Init_Environment:  Initialize processing environment             */
/*------------------------------------------------------------------*/
Init_Environment: rtn='INIT_ENVIRONMENT'; trace value tracelist.rtn
  /*---- if OS/2, see if this might be HPFS -----*/
  if currsys = OS2 then do                               /* !OPSYS! */
    i=0; j=0
    temp=substr(input_file,lastpos('\',input_file)+1)
    do while temp\=''
      parse value temp with atom '.' temp
      i = i + 1
      if i=2 & length(atom)>3
        then j = 9
        else j = max(j,length(atom))
      end
    if i>2 | j>8 then currsys = HPFS
    end
  ?pc = ( wordpos(currsys,AIX HPFS LINUX OS2 WIN95 WINNT UNIX) > 0 )
  dirchar.AIX   = '/'
  dirchar.CMS   = ''
  dirchar.HPFS  = '\'
  dirchar.LINUX = '/'
  dirchar.MVS   = '/'
  dirchar.OS2   = '\'
  dirchar.WIN95 = '\'
  dirchar.WINNT = '\'
  dirchar.UNIX  = '/'
  shell = address()
  /*----- platform-dependent utilities -----*/           /* !OPSYS! */
  if currsys=OS2 | currsys=HPFS then do
    call RxFuncAdd 'SysSearchPath','RexxUtil','SysSearchPath'
    call RxFuncAdd 'SysFileDelete','RexxUtil','SysFileDelete'
    end
  /*----- program location & components -----*/
  select                                                 /* !OPSYS! */
    when currsys=AIX | currsys=LINUX | currsys=UNIX then do
      parse source . . expgm; call FileParts expgm
      pgmpath=fp.!path; pgmfn=fp.!fn
      end
    when currsys = CMS then parse value exfn with pgmfn pgmpath
    when currsys = MVS then parse value exfn with pgmfn pgmpath
    when currsys=OS2 | currsys=HPFS then do
      parse source . . expgm; call FileParts expgm
      pgmpath=fp.!path; pgmfn=fp.!fn
      end
    when currsys=WIN95 | currsys=WINNT then do
      parse source . . expgm; call FileParts expgm
      pgmpath=fp.!path; pgmfn=fp.!fn
      end
    otherwise nop
    end
  /*----- if I'm pipeline filter, setup environment ---*//* !OPSYS! */
  ?pipe = (currsys=CMS & where='?') | (currsys=MVS & where='PIPE')
  if ?pipe
    then parse value false 'CALLPIPE' with ?noisy pipcmd
    else pipcmd = 'PIPE'
 
  /*----- current platform-based defaults -----*/
  parse value time('E') with sss '.' uuu .
  if \datatype(sss,'N') then sss = 0
  if \datatype(uuu,'N') then uuu = 0
  sss = sss + time('M')
  uuu = uuu + time('S')
  select                                                 /* !OPSYS! */
    when currsys=AIX | currsys=LINUX | currsys=UNIX then do
      ?outputp83    = 0
      defimbft      = 'script'
      destsys       = currsys
      dsmrefft      = 'b2hxrefs'
      help_file     = pgmfn'.helpcms'
      htmpext       = 'html'
      logdflt       = pgmfn'.log'
      outputp_case  = 0
      temp_file     = 'B'right(uuu,7,'0')'.temp'right(sss,4,'0')
      tracefile     = pgmfn'.trace'
      call DefSymbol 'b2huser', ''
      profilesuffix = '.profile'
      symbolsuffix  = '.symbols'
      sysprofile    = pgmfn || profilesuffix
      syssymbol     = pgmfn || symbolsuffix
      end
    when currsys = CMS then do
      ?outputp83    = 1
      defimbft      = 'SCRIPT'
      destsys       = CMS
      dsmrefft      = 'B2HXREFS'
      help_file     = pgmfn
      htmpext       = 'HTML'
      logdflt       = pgmfn 'LOG A'
      outputp_case  = 2
      profilesuffix = ' PROFILE *'
      symbolsuffix  = ' SYMBOLS *'
      sysprofile    = pgmfn || profilesuffix
      syssymbol     = pgmfn || symbolsuffix
      pipcmd 'command QUERY DISK MAX | drop 1 | append literal * * A| var temp'
      workdisk      = word(temp,3)
      temp_file     = 'B'right(uuu,7,'0') '$TMP'right(sss,4,'0') workdisk
      tracefile     = pgmfn 'TRACE A'
      address COMMAND 'IDENTIFY ( STACK LIFO'
      parse pull thisuser . thisnode .
      call DefSymbol 'b2huser', 'by' thisuser 'at' thisnode
      pipcmd 'CP QUERY DATEFORMAT USER | spec w4 1 | var cms_dateformat'
      if rc\=0 | symbol('CMS_DATEFORMAT')\='VAR'
        then cms_dateformat = 'SHORTDATE'
      end
    when currsys = MVS then do
      tsoprefix=Do_SysVar('SYSPREF')
      if tsoprefix\='' then tsoprefix=tsoprefix'.'
      ?outputp83    = 1
      defimbft      = 'SCRIPT'
      destsys       = MVS
      dsmrefft      = 'B2HXREFS'
      htmpext       = 'HTML'
      logdflt       = tsoprefix'B2H.LOG'
      outputp_case  = 2
      help_file     = FindSysFileMVS(!hlp)
      profilesuffix = ''
      symbolsuffix  = ''
      sysprofile    = FindSysFileMVS(!pro)
      if sysprofile = '' then do
        call SysNotFound 'System profile:',!pro
        sysprofile = MVSsys.!pro.!dsn
        end
      syssymbol    = FindSysFileMVS(!sym)
      if syssymbol = '' then do
        call SysNotFound 'System symbol table:',!sym
        syssymbol  = MVSsys.!sym.!dsn
        end
      temp_file    = tsoprefix'B'right(uuu,7,'0')'.$TMP'right(sss,4,'0')
      tracefile    = tsoprefix'B2H.TRACE'
      call DefSymbol 'b2huser', ,
           'by' Do_SysVar('SYSUID') 'at' Do_SysVar('SYSNODE')
      end
    when currsys=OS2 | currsys=HPFS then do
      if currsys = OS2
        then do                        /* OS/2 (FAT) definitions    */
          ?outputp83 = 1
          defimbft   = 'scr'
          destsys    = OS2
          htmpext    = 'htm'
          end
        else do                        /* OS/2 (HPFS) definitions   */
          ?outputp83 = 0
          defimbft   = 'script'
          destsys    = HPFS
          htmpext    = 'html'
          end
      dsmrefft      = 'B2X'
      outputp_case  = 0
      help_file     = pgmfn'.HLP'
      logdflt       = pgmfn'.LOG'
      profilesuffix = '.PRO'
      symbolsuffix  = '.SYM'
      sysprofile    = pgmfn || profilesuffix
      syssymbol     = pgmfn || symbolsuffix
      temp_file     = 'B'right(uuu,7,'0')'.$'right(sss,2,'0')
      tracefile     = pgmfn'.TRC'
      call DefSymbol 'b2huser', ''
      end
    when currsys=WIN95 | currsys=WINNT then do
      ?outputp83    = 1
      defimbft      = 'scr'
      destsys       = currsys
      dsmrefft      = 'B2X'
      help_file     = pgmfn'.HLP'
      htmpext       = 'htm'
      logdflt       = pgmfn'.LOG'
      outputp_case  = 0
      profilesuffix = '.PRO'
      symbolsuffix  = '.SYM'
      sysprofile    = pgmfn || profilesuffix
      syssymbol     = pgmfn || symbolsuffix
      temp_file     = 'B'right(uuu,7,'0')'.$'right(sss,2,'0')
      tracefile     = pgmfn'.TRC'
      call DefSymbol 'b2huser', ''
      end
    otherwise nop
    end
  return
 
/*----- Find a B2H system file under MVS -----*/
FindSysFileMVS:
  parse arg fsf1 .
  select
    when Do_ListDSI(MVSsys.fsf1.!dd 'FILE') = 0 then do
      DDname.SYSDSNAME = MVSsys.fsf1.!dd
      ?DDprealloc.SYSDSNAME = 1
      fsf2 = SYSDSNAME
      end
    when Do_SysDsn(MVSsys.fsf1.!dsn) = 'OK' then do
      fsf2 = MVSsys.fsf1.!dsn
      DDname.fsf2 = MVSsys.fsf1.!dd
      end
    otherwise fsf2 = ''
    end
  return fsf2
 
/*----- TSO command -----*/
Do_TSO:
  tsoarg = arg(1)
  if ?pipe
    then pipcmd 'var tsoarg | TSO'
    else do; xx=OUTTRAP('Z.'); address TSO tsoarg; xx=OUTTRAP('OFF'); end
  return rc
 
/*----- LISTDSI function -----*/
Do_ListDSI:
  dsiarg = arg(1)
  if ?pipe
    then pipcmd 'var dsiarg | LISTDSI | varload'
    else rc = LISTDSI(dsiarg)
  return rc
 
/*----- SYSDSN function -----*/
Do_SysDsn:
  dsnarg=arg(1)
  if ?pipe
    then pipcmd 'var dsnarg | SYSDSN | buffer | var dsnarg'
    /* LBD: add quotes around dsnarg 07-28-2017 */
    else dsnarg = SYSDSN("'"dsnarg"'")
  return dsnarg
 
/*----- SYSVAR function -----*/
Do_SysVar:
  vararg = arg(1)
  if ?pipe
    then pipcmd 'var vararg | SYSVAR | buffer | var vararg'
    else vararg = SYSVAR(vararg)
  return vararg
 
/*------------------------------------------------------------------*/
/* SetDestSysDefaults: set non-specified destination system values  */
/*------------------------------------------------------------------*/
SetDestSysDefaults: rtn='SETDESTSYSDEFAULTS'; trace value tracelist.rtn
/* "case" values:  0=asis, 1=lowercase, 2=uppercase          */
/* "83" values: respect 8.3 naming convention:  0=no, 1=yes  */
  select                                                 /* !OPSYS! */
    when destsys=AIX | destsys=LINUX | destsys=UNIX then do
      if htmlext      = '' then htmlext      = 'html'
      if outputl_case = '' then outputl_case = ( currsys = CMS )
      if ?outputl83   = '' then ?outputl83   = 0
      end
    when destsys = CMS then do
      if htmlext      = '' then htmlext      = 'html'
      if outputl_case = '' then outputl_case = 1
      if ?outputl83   = '' then ?outputl83   = 1
      end
    when destsys = HPFS then do
      if htmlext      = '' then htmlext      = 'html'
      if outputl_case = '' then outputl_case = ( currsys = CMS )
      if ?outputl83   = '' then ?outputl83   = 0
      end
    when destsys = MVS then do
      if htmlext      = '' then htmlext      = 'HTML'
      if outputl_case = '' then outputl_case = 1
      if ?outputl83   = '' then ?outputl83   = 1
      end
    when wordpos(destsys,OS2 WIN95 WINNT) > 0 then do
      if htmlext      = '' then htmlext      = 'htm'
      if outputl_case = '' then outputl_case = ( currsys = CMS )
      if ?outputl83   = '' then ?outputl83   = 1
      end
    otherwise nop
    end
  return
 
 
/*------------------------------------------------------------------*/
/* Show_Help:  Show user the help file                              */
/*------------------------------------------------------------------*/
Show_Help: rtn='SHOW_HELP'; trace value tracelist.rtn
  if wordpos(currsys,AIX HPFS LINUX OS2 WIN95 WINNT UNIX)>0 /*!OPSYS!*/
    then do
      call FileAndPath help_file,'SET'
      shrc = 28
      do forever
        shtempfid = FileAndPath(help_file)
        if shtempfid = '' then leave
        shrc = FindFile(shtempfid)
        if shrc=0 then do; help_file=shtempfid; leave; end
        end
      end
  select                                                 /* !OPSYS! */
    when currsys=AIX | currsys=LINUX | currsys=UNIX then do
      editor = value('VISUAL',,'ENVIRONMENT')
      address value shell
      if editor = '' then editor = value('EDITOR',,'ENVIRONMENT')
      if editor = ''
        then '\cat' help_file '| pg '
        else editor help_file
      address
      end
    when currsys=CMS  then 'HELP' help_file
    when currsys=HPFS then 'E'    help_file
    when currsys=MVS  then if DDname.help_file = ''
      then call SysNotFound 'Help file:',!hlp
      else do
        "SUBCOM ISPEXEC"               /* Use ISPF browse if avail  */
        if rc = 0 then address ISPEXEC "BROWSE DATASET('"help_file"')"
        end
    when currsys=OS2   then 'E'       help_file
    when currsys=WIN95 then 'NOTEPAD' help_file
    when currsys=WINNT then 'NOTEPAD' help_file
    otherwise nop
    end
  signal Exit_Program
 
/*------------------------------------------------------------------*/
/* FileDate: Return the file's date and time                        */
/* Usage:    parse value FileDate(file) with yyyy-mm-dd hh:mm:ss    */
/*------------------------------------------------------------------*/
FileDate: rtn='FILEDATE'; trace value tracelist.rtn
  if ?trcpgm then call Here1 rtn,arg(1),sigl,!pgm
  select                                                 /* !OPSYS! */
    when currsys = CMS then do
      pipcmd 'command LISTFILE' arg(1) '( NOH DATE |',
             'take 1 | append literal | var x'
      fdate = word(x,8)
      ftime = word(x,9)
      if cms_dateformat = 'ISODATE'
        then fdate = translate('Mm-Dd-CcYy',fdate,'CcYy-Mm-Dd')
      end
    when currsys = MVS then do
      ftime = time('N')
      if Do_ListDSI("'"arg(1)"'") = 0
        then fdate = Jul2MDY(SYSCREATE)
        else fdate = date('U')
      end
    otherwise parse value stream(arg(1),'C','QUERY DATETIME'),
                    with  fdate ftime .
    end
  select
    when pos('-',fdate) > 0 then parse var fdate mm '-' dd '-' yy .
    when pos('/',fdate) > 0 then parse var fdate mm '/' dd '/' yy .
    when pos('.',fdate) > 0 then parse var fdate dd '.' mm '.' yy .
    otherwise return ''
    end
  if yy <  100 then yy = yy + 1900
  if yy < 1970 then yy = yy +  100
  fdrslt = yy'-'right(mm,2,'0')'-'right(dd,2,'0') ftime
  if ?trcpgm then call Here2 fdrslt
  return fdrslt
 
/*----- Jul2MDY: yy/ddd to mm/dd/yy -----*/
Jul2MDY:
  parse arg jyy . '/' jddd .
  if length(jyy) = 2
    then if jyy < '70'
      then jyy = '20'jyy
      else jyy = '19'jyy
  d.2 = 28 + Leap(jyy)
  jsum = 0
  do js=1 to 12 While jsum<jddd
    jsum = jsum + d.js
    end
  jmm = js - 1
  jdd = jddd - ( jsum - d.jmm )
  return jmm'/'jdd'/'jyy
 
/*------------------------------------------------------------------*/
/* FindFile: Locate a physical file.  If found, the "FileParts"     */
/*           routine is called to set the appropriate variables.    */
/* Usage:    qrc = FindFile(file)                                   */
/*      fid - File to locate (e.g. on CMS: ABC PROFILE; on          */
/*            OS/2: ABC.PRO; etc.                                   */
/*      qrc - Return code (0=found, 1=not found)                    */
/*------------------------------------------------------------------*/
FindFile: rtn='FINDFILE'; trace value tracelist.rtn
  parse arg fffid
  if ?trcpgm then call Here1 rtn,fffid,sigl,!pgm
  select                                                 /* !OPSYS! */
    when wordpos(currsys,AIX HPFS LINUX OS2 WIN95 WINNT UNIX) > 0 then do
      exists = stream(fffid,'C','query exists');
      qrc = ( exists = '' )
      if exists \= '' then call FileParts exists
      end
    when currsys = CMS then do
      parse var fffid fffn ffft fffm .
      if fffn = '' then fffn = '*'
      if ffft = '' then ffft = '*'
      if fffm = '' then fffm = '*'
      pipcmd 'command LISTFILE' fffn ffft fffm '( NOH |',
             'take 1 | spec w1-3 1 | append literal | var listrec'
      qrc = ( rc \= 0 )
      if rc = 0 then call FileParts listrec
      end
    when currsys = MVS then do
      rc = Do_ListDSI("'"word(fffid,1)"'")
      qrc = ( rc \= 0 )
      if rc = 0 then call FileParts fffid
      end
    otherwise qrc = 1
    end
  if ?trcpgm then call Here2 qrc
  return qrc
 
/*------------------------------------------------------------------*/
/* FileAndPath: Set and return one or more file/paths for a file    */
/* Usage:  To set:  call FileAndPath file, 'SET'                    */
/*         To get:  fid = FileAndPath(file)                         */
/*                      If 'fid' is null, no more locations avail   */
/*------------------------------------------------------------------*/
FileAndPath: rtn='FILEANDPATH';trace value tracelist.rtn
  parse arg fapfile, fapset
  if ?trcpgm then call Here1 rtn,fapfile','fapset,sigl,!pgm
  faprslt = ''
  if fapset = 'SET'
    then do
      fapfilestr = fapfile || nl
      select                                             /* !OPSYS! */
        when currsys=AIX   then envid='ENVIRONMENT'
        when currsys=HPFS  then envid='OS2ENVIRONMENT'
        when currsys=LINUX then envid='ENVIRONMENT'
        when currsys=OS2   then envid='OS2ENVIRONMENT'
        when currsys=WIN95 then envid='ENVIRONMENT'
        when currsys=WINNT then envid='ENVIRONMENT'
        when currsys=UNIX  then envid='ENVIRONMENT'
        otherwise envid = ''
        end
      if envid \= '' then do
        fapdir = strip(value(envname,,envid))
        do while fapdir \= ''
          parse var fapdir atomdir ';' fapdir
          if right(atomdir,1) \= dirchar.currsys
            then atomdir = atomdir || dirchar.currsys
          fapfilestr = fapfilestr || atomdir || fapfile || nl
          end
        fapfilestr = fapfilestr || pgmpath || fapfile || nl
        end
      end
    else parse var fapfilestr faprslt (nl) fapfilestr
  if ?trcpgm then call Here2 faprslt
  return faprslt
 
/*------------------------------------------------------------------*/
/* EraseFile: Erase specified file(s)                               */
/* Usage:     rc = EraseFile(fid<,fid2,fid3,...fidx>)               */
/*      fid    - File to erase                                      */
/*------------------------------------------------------------------*/
EraseFile: rtn='ERASEFILE'; trace value tracelist.rtn
  if ?trcpgm then parse value sigl with efsigl efrslt
  do efi = 1 by 1
    effid = arg(efi)
    if effid='' then leave efi
    select                                               /* !OPSYS! */
      when currsys=AIX | currsys=LINUX | currsys=UNIX then do
        address value shell
        '\rm' effid '2>>/dev/null'
        address
        end
      when currsys = CMS then address COMMAND 'ERASE' effid
      when currsys = MVS
        then if Do_ListDSI("'"effid"'") = 0
          then rc = Do_TSO("DELETE '"effid"'")
      when wordpos(currsys,HPFS OS2 WIN95 WINNT) > 0
        then if rexximp = !regina
          then do
            if FindFile(effid) = 0 then 'ERASE' effid
            end
          else rc = SysFileDelete(effid)
      otherwise rc = ''
      end
    if ?trcpgm
      then if efi = 1
        then efrslt = efrslt|| effid'{'rc'}'
        else efrslt = efrslt','effid'{'rc'}'
    end efi
  if ?trcpgm then do; call Here1 rtn,efrslt,efsigl,!pgm; call Here2; end
  return rc
 
/*------------------------------------------------------------------*/
/* GetReadyForOutput: Ensure an output file is empty and erased.    */
/*    If the file can not be written (e.g. R/O disk), the program   */
/*    is terminated.  Otherwise, as a side-effect of the "FindFile" */
/*    routine, the "FP.x" variables are set.                        */
/* Usage: call GetReadyForOutput file, MVSALLOC.suffix              */
/*------------------------------------------------------------------*/
GetReadyForOutput: rtn='GETREADYFOROUTPUT'; trace value tracelist.rtn
  parse arg grfofid, grfoalloc
  if ?trcpgm then call Here1 rtn,grfofid','grfoalloc,sigl,!pgm
  call OpenFile  grfofid,!write,MVSalloc.grfoalloc
  call WrtLine   grfofid,'dummy record'
  call CloseFile grfofid
  grforc = FindFile(grfofid)
  if grforc \= 0
    then call MsgOut !term 301,"Unable to create '"grfofid"'!"
  call EraseFile grfofid
  outcount.grfofid = 0                 /* reset record count        */
  if ?trcpgm then call Here2
  return
 
/*------------------------------------------------------------------*/
/* FileParts: Set the "FP." array with the file's component parts   */
/* Usage:     call FileParts file <,opsys>                          */
/*      file   - Fully-qualified file name                          */
/*      opsys  - Desired operating system (e.g. AIX, CMS).          */
/*               If omitted, the current opsys is assumed.          */
/* Assume the following file names:                                 */
/*   For CMS:                         fn ft fm                      */
/*   For "8.3" names:                 c:\dir1\dir2\fn.ft            */
/*   For "Extended" names (non-AIX):  c:\dir1\dir1\h1.h2.hx.fn.ft   */
/*   For "Extended" names (AIX):      c:/dir1/dir1/h1.h2.hx.fn.ft   */
/*   For MVS/TSO names (DSORG=PO):    h1.h2.hx.fn.ft                */
/*   For MVS/TSO names (DSORG=PS):    h1.h2.hx.fn.ft(member)        */
/* This routines sets:                                              */
/*   FP.ALL  - The fully qualified name                             */
/*   FP.PATH - The directory path of the file                       */
/*             e.g. c:\dir1\dir2\, c:/dir1/dir2/                    */
/*   FP.FILE - The non-path portion of the file                     */
/*             e.g. fn ft fm, fn.ft, h1.h2.hx.fn.ft                 */
/*   FP.FN   - The whole filename, e.g. fn, h1.h2.hx.fn             */
/*   FP.FN1  - The leading part of the filename, e.g. h1.h2.hx.     */
/*   FP.FN2  - The last part of the filename, e.g. fn               */
/*   FP.FT   - The filetype/extension of the file, e.g. ft          */
/*   FP.MEM  - The "member" of the MVS/TSO pds, e.g. member         */
/*   FP.FM   - The "fm" of a physical CMS file, e.g. fm             */
/*------------------------------------------------------------------*/
FileParts: rtn='FILEPARTS'; trace value tracelist.rtn
  parse arg fpall, fpopsys .
  if ?trcpgm then call Here1 rtn,fpall','fpopsys,sigl,!pgm
  fp.=''; fp.!all=fpall
  if fpopsys = '' then fpopsys = currsys
  select                                                 /* !OPSYS! */
    when wordpos(fpopsys,AIX HPFS LINUX MVS OS2 WIN95 WINNT UNIX) > 0 then do
      /*----- get path info -----*/
      fpi = lastpos(dirchar.fpopsys,fpall)
      if fpi > 0
        then do; fp.!path=left(fpall,fpi); fpall=substr(fpall,fpi+1); end
      /*----- get non-path info -----*/
      parse var fpall fpall '(' fp.!mem . ')' /*possible member name*/
      fp.!file = fpall
      fpi = lastpos('.',fpall)         /* location of last period   */
      if fpi = 0                       /* was one found?            */
        then parse var fpall fp.!fn 1 fp.!fn2  /* no, all done      */
        else do
          fp.!ft = substr(fpall,fpi+1) /*   yes, save 'extension'   */
          fpall  = left(fpall,fpi-1)   /*        & remove from name */
          fp.!fn = fpall               /* save full filename        */
          fpi = lastpos('.',fpall)     /* location of last period   */
          if fpi = 0
            then fp.!fn2 = fpall
            else do
              fp.!fn1 = left(fpall,fpi)
              fp.!fn2 = substr(fpall,fpi+1)
              end
          end
      end
    when fpopsys = CMS then do
      parse var fpall fp.!fn fp.!ft fp.!fm .
      fp.!fn2  = fp.!fn
      fp.!fm   = left(fp.!fm,1)
      fp.!all  = fp.!fn fp.!ft fp.!fm
      fp.!file = fp.!all
      end
    otherwise nop
    end
  if ?trcpgm then call Here2 fp.!all
  return fp.!all
 
/*------------------------------------------------------------------*/
/* Miscellaneous message-to-the-log routines                        */
/*------------------------------------------------------------------*/
FileNotFound:      /* action,<descript>,file,<msg1>,<msg2> */
  parse arg fnf1, fnf2, fnf3, fnf4, fnf5
  if fnf1 = '' then fnf1 = !error
  call MsgOut fnf1 300,space(fnf2 '"'fnf3'" not found!'),fnf4,fnf5
  return
SysNotFound:       /* descript, index */
  parse arg fnf1, fnf2
  call MsgOut !error 313, fnf1 'DD='MVSsys.fnf2.!dd,
              'not allocated and unable to locate DSN='MVSsys.fnf2.!dsn
  return
NotInHTML2:        /* bad-option, <optional trail msg>  */
  parse arg nh21, nh22
  if nh22 \= '' then nh22 = ', 'nh22
  call MsgOut !warning 126, nh21 'not available when HTML=2'nh22
  return
LoadingFile:       /* desc, file */
  call MsgOut !info 160,'Loading' arg(1) '"'subword(arg(2),1,2)'" ...'
  return
ReadingFile:       /* <desc>, file */
  call MsgOut !info 302, space('Reading' arg(1)) 'file "'arg(2)'" ...'
  return
RecordsRead:       /* count, file */
  call MsgOut !info 304, arg(1) 'lines read from' arg(2)
  return
RecordsWritten:    /* count, file */
  call MsgOut !info 306, arg(1) 'lines written to' arg(2) arg(3)
  return
ShowB2HCtlRec:     /* file, record */
  parse arg sb21, sb22
  call MsgOut !info 161, '  'sb21'('incount.sb21'):' strip(sb22)
  return
 
/*------------------------------------------------------------------*/
/* Issue tracing-type messages                                      */
/* Usage: call TraceMsg message,<lineno>,type                       */
/* Usage: call Here1 routine-name,input-parms,caller's-line-no,type */
/* Usage: call Here2 returned-value                                 */
/* Usage: call Trc general-message                                  */
/*------------------------------------------------------------------*/
TraceMsg:  /* trace 'O' */
  parse arg tiomsg,tiosigl,tiotype
  if tiosigl='' then tiosigl=sigl
  tracehead = tiotype right(tiosigl,4)
  call Trc tiomsg
  return
 
/*----- show start-of-routine -----*/
Here1: trace 'O'
  parse arg h1a,h1b,h1c,h1d
  here_cnt = here_cnt + 1
  here_list.here_cnt = h1a h1d
  tracehead = h1d right(h1c,4)
  call Trc 'Begin' h1a', Parm="'h1b'"'
  return
 
/*----- show end-of-routine -----*/
Here2: trace 'O'
  parse value here_list.here_cnt with h1a h1d
  tracehead = h1d '    '
  call Trc 'End  ' h1a', Return "'arg(1)'"'
  here_cnt = max(here_cnt-1,0)
  return
 
/*----- write trace line -----*/
Trc:
  if ?traceactive then return
  ?traceactive=1
  trcmsg = time('L') tracehead copies('   ',here_cnt) || arg(1)
  if ?trace2disk
    then do
      if \?traceisopen then call OpenFile tracefile,!write,MVSalloc.!trace
      ?traceisopen = 1
      call WrtLine tracefile,trcmsg
      end
    else say trcmsg
  ?traceactive = 0
  return
 
/*------------------------------------------------------------------*/
/* LoadProfile: Load and process a profile file                     */
/* Usage: call LoadProfile fileid, msg-describing-the-file,x,y,z    */
/*------------------------------------------------------------------*/
LoadProfile: rtn='LOADPROFILE'; trace value tracelist.rtn
  if ?trcpgm
    then call Here1 rtn,arg(1)','arg(2)','arg(3)','arg(4)','arg(5),sigl,!pgm
  lpc = lpc + 1                          /* uniqueness counter        */
  parse arg lpin.lpc, lpmsg.lpc, ?lp1.lpc, ?lp2.lpc, ?lp3.lpc
  call FileAndPath lpin.lpc,'SET'; lprc=28
  do forever
    lptempfid=FileAndPath(lpin.lpc)
    if lptempfid = '' then leave
    lprc = FindFile(lptempfid)
    if lprc = 0 then do
      lpin.lpc = lptempfid
      leave
      end
    end
  if lprc \= 0                           /* was profile found?        */
    then call FileNotFound !error, lpmsg.lpc, lpin.lpc
    else do                              /* read in profile file      */
      call OpenFile lpin.lpc,!read
      call LoadingFile lpmsg.lpc, lpin.lpc
      ?prfeof.lpc = false
      do forever while \?prfeof.lpc
        parse value RdLine(lpin.lpc,!profmode,'NO'),
              with  1 ?prfeof.lpc 2 lptemp.lpc
        if \?prfeof.lpc then do
          if ?showprof then do
            lpfid = lpin.lpc
            call ShowB2HCtlRec lpfid, lptemp.lpc
            end
          call SetOpts lptemp.lpc,?lp1.lpc,?lp2.lpc,?lp3.lpc
          end
        end
      call CloseFile lpin.lpc
      end
  call SetOpts_GlobalCheck
  lpc = lpc - 1
  if ?trcpgm then call Here2
  return
 
/*------------------------------------------------------------------*/
/* LoadSymbols: Load a symbol definition file.                      */
/* Usage: call LoadSymbols fileid, msg-describing-the-file          */
/*------------------------------------------------------------------*/
LoadSymbols: rtn='LOADSYMBOLS'; trace value tracelist.rtn
  parse arg lsin, lsmsg
  if ?trcpgm then call Here1 rtn,lsin','lsmsg,sigl,!pgm
  call FileAndPath lsin,'SET'; lsrc=28
  do forever
    lstempfid=FileAndPath(lsin); if lstempfid='' then leave
    lsrc=FindFile(lstempfid); if lsrc=0 then do;lsin=lstempfid;leave;end
    end
  if lsrc \= 0                         /* symbol file found?        */
    then call FileNotFound !error, lsmsg, lsin
    else do                            /* read in symbol file       */
      call OpenFile lsin,!read; call LoadingFile lsmsg, lsin
      ?symeof = false
      do forever while \?symeof
        parse value RdLine(lsin,!profmode,'NO'),
              with  1 ?symeof 2 fullline '--'
        if ?symeof then leave
        do forever
          fullline = strip(fullline)
          if right(fullline,1) \= ',' then leave
          fullline = left(fullline,length(fullline)-1)
          parse value RdLine(lsin,!profmode,'NO'),
                with  1 ?symeof 2 contdata '--'
          if ?symeof then leave
          fullline = fullline strip(contdata)
          end
        if ?showsym then call ShowB2HCtlRec lsin, fullline
        if SetSyms(fullline) > 0       /* process the statement     */
          then call MsgOut ?prcunksym 151, ,
                   'Unknown symbol table record!',fullline,!recnum
        end
      call CloseFile lsin
      end
  if ?trcpgm then call Here2
  return
 
/*------------------------------------------------------------------*/
/* SetSyms: Process a symbol table record:  call SetSyms record     */
/*------------------------------------------------------------------*/
SetSyms: rtn='SETSYMS'; trace value tracelist.rtn; setsymsrc=0
  parse arg ssline
  parse var ssline symtype symnames '='
  symtype = translate(symtype)
  i = words(symnames)
  symnames   = subword(symnames,1,max(0,i-1))
  symvalue   = subword(ssline,i+1)
  symnamesuc = translate(symnames)
  symvalueuc = translate(symvalue)
 
  select
    /*----- :CMD. - SCRIPT/VS control word or GML/Bookie macro -----*/
    when symtype = ':CMD.' then do
      vval  = VValue('V=')
      tvval = VValue('TV=')
      do while symnamesuc\=''
        parse var symnamesuc atom symnamesuc
        sym.!dot.atom    = vval
        sym.!dottbl.atom = tvval
        end
      end
    /*----- :SYM. - &variable symbol -----*/
    when symtype = ':SYM.' then do
      parse var symvalue 'V=' data
      parse var data 1 _ 2 data (_)
      do while symnames\=''
        parse var symnames atom symnames
        sym.!amp.atom = SymbSub(data)
        end
      end
    /*----- :TAG. - GML/Bookmaster tag -----*/
    when symtype = ':TAG.' then do
      attval = YesNo('ATT=', 'Y')
      itval  = YesNo('IT=',  'N')
      vatval = YesNo('VAT=', 'Y')
      seval  = YesNo('SE=',  'N')
      vval   = VValue('V=')
      tvval  = VValue('TV=')
      do while symnamesuc\=''
        parse var symnamesuc atom symnamesuc
        ?TAGatt.atom     = attval
        ?TAGimmed.atom   = itval
        ?TAGvat.atom     = vatval
        ?TAGse.atom      = seval
        sym.!tag.atom    = vval
        sym.!tagtbl.atom = tvval
        ?TAGvalid.atom   = 1
        end
      end
    /*----- :XLATEx. - character translations -----*/
    when symtype=':XLATEI.' | symtype=':XLATE.' | symtype=':XLATEO.' then do
      if symtype=':XLATEO.'            /* determine which XLATEx    */
        then xtemp = !out
        else xtemp = !in
      sysstring = subword(ssline,2)
      do while sysstring \= ''         /* scan the value(s)         */
        parse var sysstring xfrom xstring
        xstring = strip(xstring,'L')
        if translate(left(xstring,2)) = 'V='
          then do
            i = xlatecs.xtemp.0 + 1
            xlatecs.xtemp.0 = i
            parse var xstring . '=' data
            parse var data 1 _ 2 data (_) sysstring
            xlatecs.xtemp.i = HexChar(xfrom) data
            end
          else do
            parse var sysstring xfrom xto sysstring
            xlatefrom.xtemp = xlatefrom.xtemp || HexChar(xfrom,ssline)
            xlateto.xtemp   = xlateto.xtemp   || HexChar(xto,ssline)
            end
        end
      call Set_XlateI
      call Set_XlateO
      end
    otherwise setsymsrc = 4
    end
  return setsymsrc
 
 
/*----- char = HexChar({c|xx},<record>,<noerror>) -----*/
HexChar:
  parse arg hc1,hc2,hc3
  rslt = ''
  hc1len = length(hc1)
  if hc1len = 1
    then rslt = hc1
    else do
      hc1 = translate(hc1)
      if verify(hc1,hexchars)>0 | hc1len\=2  /* valid hex char(s)?  */
        then if hc3 = ''                     /*   no                */
          then call MsgOut !error 457,hc1 'is an invalid hex value',hc2,!recnum
          else nop
        else rslt = x2c(hc1)                 /*   yes, save value   */
      end
  return rslt
 
/*----- VValue: extract named value; convert if necessary -----*/
VValue:
  parse arg vv
  parse var symvalue (vv) vvdata
  parse var vvdata 1 _ 2 vvdata (_)
  vvdatauc = translate(vvdata)
  select
    when vvdatauc='=INTERNAL'   then vvdata=''
    when vvdatauc='=IGNORE'     then vvdata=!ignore
    when vvdatauc='=IGNOREW'    then vvdata=!ignorew
    when vvdatauc='=IGNOREALL'  then vvdata=!ignoreall
    when vvdatauc='=IGNOREALLW' then vvdata=!ignoreallw
    otherwise nop
    end
  return vvdata
 
/*----- YesNo: extract value and convert Y/N value to 1/0 -----*/
YesNo:
  parse arg ynparm, yndefault
  parse var symvalueuc (ynparm) yndata .
  if yndata='' then yndata = yndefault
  return yndata='Y'
 
 
/*----- Allow B2H support to inspect internal variables -----*/
Dump_Vars:
  ?varsshown = 0
  if currsys = CMS then do                               /* !OPSYS! */
    address COMMAND 'EXEC REXXVARS (' arg(1)
    ?varsshown = ( rc = 0 )
    end
  if \?varsshown then do
    say arg(1)
    signal off syntax
    signal off novalue
    do forever
      say 'Enter a REXX expression: (QUIT to quit, null to continue)'
      parse upper pull dv
      if dv = '' then leave
      if dv = 'QUIT' then signal Exit_Program
      interpret dv
      end
    end
  signal on syntax  name TRAPIT
  signal on novalue name TRAPIT
  return
 
/*----- 'Mon, 29 Jul 1996' = RFCDate(19960729,<delta>) -----*/
RFCDate: procedure expose !days !months d. deftext.
  parse arg rfcyyyymmdd, delta; if \datatype(delta,'W') then delta = 0
  bdate = B2S(rfcyyyymmdd,'S') + delta
  if delta = 0
    then parse var rfcyyyymmdd           1 yyyy 5 mm 7 dd 9
    else parse value B2S(bdate,'B') with 1 yyyy 5 mm 7 dd 9
  return word(deftext.!days,bdate//7+1)',',
      right(dd,2,'0') word(deftext.!months,mm) yyyy
 
/*------------------------------------------------------------------*/
/* B2S: Convert between a 'base' date (all days) and "YYYYMMDD"     */
/* Usage:  result = B2S(input,<B|S>)                                */
/*           input  - Date(B) or Date(S) date to be converted to    */
/*                    other format.                                 */
/*           B or S - Identifies format of input field              */
/*------------------------------------------------------------------*/
B2S: procedure expose d.; arg dd .
select
  when arg(2) = 'B' then do           /* Convert Date(B) to Date(S) */
    dd = dd + 1                              /* Date(S) = Date(B)+1 */
    yyyy = dd  % 146097 * 400                    /* 400 year groups */
    dd   = dd // 146097          /* all 400 year groups are similar */
    temp = dd % 36524; dd = dd // 36524          /* 100 year groups */
    if temp = 4  /* back up 1, 4th 100 year group not same as 1st 3 */
      then do; temp=3; dd=dd+36524; end
    yyyy = temp * 100 + yyyy
    temp = dd  % 1461; dd = dd // 1461             /* 4 year groups */
    if temp = 25 then do
      temp  = 24 /* back up 1, 25th 4 year group not same as 1st 24 */
      dd = dd + 1461
      end
    yyyy = temp * 4 + yyyy; yyyy = dd % 365.25 + yyyy /* 1 yr groups*/
    dd   = dd - ((dd % 365.25) * 365.25) % 1
    if dd = 0
      then parse value 12 31 with mm dd .               /* Dec 31st */
      else do
        yyyy=yyyy+1; d.2=28+leap(yyyy)      /* partial year = mm/dd */
        do mm = 1 while dd > d.mm                   /* count months */
          dd = dd - d.mm                  /* while subtracting days */
          end
        end
    return right(yyyy,4,0)right(mm,2,0)right(dd,2,0) /*Date(Sorted) */
    end
  when arg(2) = 'S' then do           /* Convert Date(S) to Date(B) */
    if length(dd) <> 8 then return ''
    parse value dd with 1 yyyy 5 mm 7 dd 9 .
    mm = mm + 0; lp=leap(yyyy)
    if d.mm = 0 | dd=0 | dd>(d.mm+lp) then return ''
    /* What was the Basedate December 31st of the "PREVIOUS" year?  */
    pyyy = yyyy - 1                                /* previous year */
    if pyyy = 0 then days = 0         /* there was no previous year */
    else days = pyyy * 365 + (pyyy % 4) - (pyyy % 100) + (pyyy % 400)
    /* What 'nth' day of this year is mm/dd? */
    days=days+word('0 31 59 90 120 151 181 212 243 273 304 334 365',mm)
    if lp & mm>2 then days=days+1
    return days + dd - 1              /* Date(Basedate) = Date(S)-1 */
    end
  otherwise nop
  end
return
 
Leap: procedure  /* returns: 1=leap year; 0=not a leap year */
  parse upper arg 1 yyyy 5 .
  select
    when yyyy //   4 > 0 then yyyy = 0
    when yyyy // 100 > 0 then yyyy = 1
    when yyyy // 400 = 0 then yyyy = 1
    otherwise                 yyyy = 0
    end
  return yyyy
 
/*------------------------------------------------------------------*/
/* A termination-type error has occurred                            */
/*------------------------------------------------------------------*/
TRAPIT: trace 'O'
  quit_rc = rc
  parse source . . exfn .
  parse version ver .
  ?compiled = ( ver = 'REXXC370' )       /* am I compiled? 1=Yes/0=No */
  signal off syntax
  signal off novalue
  signal off halt
  trap.  = ''
  trap.1 = 'Abend in line' sigl 'of' exfn', RC='rc
  trap.2 = 'CondxC :' condition('C')
  trap.3 = 'CondxD :' condition('D')
  if rc>0 & rc<=99 then trap.4 = 'ErrText:' errortext(rc)
  if \?compiled    then trap.5 = 'Source :' sourceline(sigl)
  trap.0 = 5
  do trapI = 1 to trap.0
    say exfn':' trap.trapI
    end
  signal Exit_Program
 
/*------------------------------------------------------------------
Definitions of major variables and arrays not already described
 
----- Variables starting with:
  "?" *usually* are boolean: 0=false/no 1=true/yes
  "!" *usually* have the same value minus the "!"
  "_" are counters used with various tags/commands
 
----- Definitions regarding :tags/.commands/&symbols
  SYM.!AMP.symbol    - Value of &symbol
  SYM.!AMPD.symbol   - "1" means &symbol is defined
  SYM.!DVCF.process  - If null, "process" is FALSE, else it is TRUE
  SYM.!DOT.cmd       - Replacement text when ".cmd" is encountered
  SYM.!DOTTBL.cmd    - Replacement text when ".cmd" is inside an HTML2 table
  SYM.!TAG.tag       - Replacement text when ":tag" is encountered
  SYM.!TAGTBL.tag    - Replacement text when ":tag" is inside an HTML2 table
  SYM.!NAMEFILE.name - Filename saved for NAME= on .NAMEFILE macro
  ?TAGATT.tag        - Attributes (e.g. abc=def) allowed for this tag?
  ?TAGIMMED.tag      - This tag require immediate text?
  ?TAGVAT.tag        - Value attributes (e.g. COMPACT) allowed for this tag?
 
----- Environmental variables:
     ?outputp83   - Format of output file: 1=8.3 syntax, 0=not 8.3
     currsys      - Current platform type
     destsys      - Destination platform type
     outputp_case - "Case" of output file: 0=asis, 1=lower, 2=upper
 
----- HTML 2 table characters:
  TABLE2.x
     1=Frame: left edge character   5=Frame: Horiz char - normal data cell
     2=Frame: middle junction char  6=Frame: Horiz char - header/footer cell
     3=Frame: right edge character  7=Cell gutter string - left
     4=Frame: Vertical character    8=Cell gutter string - right
  TABLE2LEN.x - length of string in TABLE2.x
 
----- default list definitions:
  LIST.tag.c.x
     tag - List "type" (DL, GL, OL, SL, UL, NOTEL, TOC or INDEX)
     c   - 0=standard list, 1=compact list
     x   - 1=list-start-tag
           2=list-end-tag
           3=item-start-tag       (:DT start if a :DL)
           4=item-end-tag         (:DT end if a :DL)
           5=definition-start-tag (:DD start for a :DL)
           6=definition-end-tag   (:DD end for a :DL)
  LISTITEM.nest_count.x - Contains info for each active list
                          "x" is the same as above, with the addition of:
                      0        Item-end text for this item
                      !cnt     Number of items currently in this list
                      !termhi  Any termhi tag
                      !etermhi Any end-termhi tag
                      !type    What type of list is this? (e.g. "DL", "OL")
                      !oltype  If an ordered list, this is "x" of "TYPE=x"
                      !table   List created using <TABLE>-type tags?
                               0=No; 1=Yes
  LISTNEST contains the list "nesting" count
 
----- default horizontal-rule definitions
  HRTAG.x   (default is "<HR>" for all 'x' values
     x - 1=:ARTWORK usage     6=Prior to table-of-contents
         2=:FIG usage         7=Separating each :H0 in TOC
         3=:Hx usage          8=After table-of-contents
         4=:MSGL & :CODEL     9=Separate footnotes from body
         5=:SYNTAX usage     10=Prior to :LEN
 
----- MVS-related variables:
  _DDCNT                 -  Counter for "B2Hxxxxx" DDcards
  ?DDMODE.datasetname    -  0=Dataset is input; 1=Dataset is output
  ?DDPREALOC.datasetname -  0=Dataset not preallocated; 1=Dataset preallocated
  DDNAME.datasetname     -  File/DDcard name if dataset currently allocated
  DSN.ddcard             -  dataset1 dataset2 ... datasetx  (concat DDs)
  DSORG.dataset          -  DSORG value of dataset
 
----- Syntax diagram variables:
  synctl.                 - All the control data
  synctl._ADDVERTICALSPACING - Add some vertical spacing?
  synctl._MAXWIDTH        - Maximum width of a syntax diagram
  synctl._CHOICE.         - Formatting characters for choice groups
  synctl._CHOICE.type     - Formatting characters for choice "type"
                                 (i.e., _REPSEP, _ABOVE, _ONDEF,
                                 _ONNODEF, _BELOW, _LOWEST)
  synctl._CHOICE.type._TOPLEFT     - Top left
  synctl._CHOICE.type._TOPPAD      - Top padding
  synctl._CHOICE.type._TOPRIGHT    - Top right
  synctl._CHOICE.type._MIDDLELEFT  - Middle left
  synctl._CHOICE.type._MIDDLEPAD   - Middle padding
  synctl._CHOICE.type._MIDDLERIGHT - Middle right
  synctl._CHOICE.type._BOTTOMLEFT  - Bottom left
  synctl._CHOICE.type._BOTTOMPAD   - Bottom padding
  synctl._CHOICE.type._BOTTOMRIGHT - Bottom right
  synctl._CHOICE.type._BASELEFT    - Base left
  synctl._CHOICE.type._BASEPAD     - Base padding
  synctl._CHOICE.type._BASERIGHT   - Base right
  syndat.                - Data for a single syntax diagram
  syndat.0               - # of items in syndat.
  syndat.n               - Data for item "n"
  syndat.n._TEXT         - Text for this item, if any
  syndat.n._CONTENTS     - List of items contained in this one, if any
  syndat.n._INSIDE       - Number of item containing this one
  syndat.n._ID           - ID for this item, if any
  syndat.n._REPSEP       - Repeat separator if _ORDER=CHOICE
  syndat.n._PLACEMENT    - Placement for this item relative to
                           baseline (i.e., ABOVE, BELOW, ON), or ''
  syndat.n._ORDER        - Order of items if _CONTENTS <> ''
                           (i.e., SEQ, CHOICE, COMPOSITE), or ''
  SYNTAX_CONTAINER       - Item number of syntax group containing
                           (or to contain) current item
  SYNTAX_STYLE           - Style of current syntax diagram (e.g, LBLBOX)
  SYNTAX_VIEW            - View of current syntax diagram (i.e,
                           FULL, START, MIDDLE, END)
 
--------------------------------------------------------------------*/
